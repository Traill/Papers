[[[ ID ]]]
148
[[[ INDEX ]]]
0
[[[ TITLE ]]]
Adaptive Cut Generation for Improved Linear Programming Decoding of Binary Linear Codes
[[[ AUTHORS ]]]
Xiaojie Zhang
Paul H. Siegel
[[[ ABSTR ]]]
Abstract—Linear programming (LP) decoding approximates optimal maximum-likelihood (ML) decoding of a linear block code by relaxing the equivalent ML integer programming (IP) problem into a more easily solved LP problem. The LP problem is deﬁned by a set of linear inequalities derived from the constraints represented by the rows of a parity-check matrix of the code. Adaptive linear programming (ALP) decoding signiﬁ- cantly reduces the complexity of LP decoding by iteratively and adaptively adding necessary constraints in a sequence of smaller LP problems. Adaptive introduction of constraints derived from certain additional redundant parity check (RPC) constraints can further improve ALP performance. In this paper, we propose a new and effective algorithm to identify RPCs that produce linear constraints, referred to as “cuts,” that can eliminate non- ML solutions generated by the ALP decoder, often signiﬁcantly improving the decoder error-rate performance. The cut-ﬁnding algorithm is based upon a speciﬁc transformation of an initial parity-check matrix of the linear block code. Simulation results for several low-density parity-check codes demonstrate that the modiﬁed ALP decoding algorithm signiﬁcantly narrows the performance gap between LP decoding and ML decoding.
[[[ BODY ]]]
Linear programming (LP) decoding was ﬁrst introduced by Feldman et al. [1] as an approximation to maximum- likelihood (ML) decoding. Many observations suggest simi- larities between the performance of LP and iterative belief propagation (BP) decoding methods [2]. However, there are some key differences that distinguish LP decoding from BP decoding. One of these differences is that the LP decoder has the ML certiﬁcate property, i.e., it is detectable if the decoding algorithm fails to ﬁnd the ML codeword. When it fails to ﬁnd a valid codeword, the LP decoder ﬁnds a non-integer solution, commonly called a pseudocodeword. Another difference is that while adding redundant parity checks satisﬁed by all the codewords can only improve LP decoding, it may have a negative effect on the BP decoder, especially in the waterfall region, due to the creation of short cycles in the Tanner graph. This property of LP decoding allows improvements by tightening the LP relaxation, i.e., reducing the feasible space of LP problem by adding more linear constraints.
In the original formulation of LP decoding proposed by Feldman et al., the number of constraints in the LP problem is linear in the block-length but exponential in the maximum check node degree. In [3], Taghavi and Siegel introduced an adaptive linear programming (ALP) decoder in which these constraints are added in an adaptive and selective way. This
approach also allows the adaptive incorporation of linear constraints generated by redundant parity checks (RPC) into the LP problem, making it possible to reduce the feasible space and improve the system performance. A linear inequality de- rived from an RPC that eliminates a pseudocodeword solution is referred to as a “cut.” An algorithm proposed in [3] uses a random walk on a subset of the code factor graph to ﬁnd these RPC cuts. However, the random nature of this algorithm limits its efﬁciency. Recently, authors in [4] proposed a separation algorithm which searches immediately for cuts that can be derived from an arbitrarily chosen dual codeword during each iteration of the LP decoding problem, and these cuts improve the error-correcting performance of the original LP decoder.
In this paper, we propose a novel adaptive cut-ﬁnding algo- rithm that greatly improves the error-correcting performance of LP decoding. First, we introduce an efﬁcient approach to check whether a parity-check can generate a cut at nonintegral solution of the relaxed LP problem. We then propose a new, more efﬁcient adaptive algorithm that identiﬁes useful RPCs by performing speciﬁc elementary row operations on the orig- inal parity-check matrix of the binary linear code. By adding the corresponding linear constraints into the LP problem, we can signiﬁcantly improve the error-rate performance of the LP decoder, even approaching the ML decoder performance in the high SNR region for some codes.
The remainder of the paper is organized as follows. In Section II, we review the original formulation of LP decoding and several adaptive LP decoding algorithms. In Section III, we describe our proposed algorithm for ﬁnding RPC cuts. Section IV presents our simulation results, and Section V concludes the paper.
Consider a binary linear block code C of length n and a cor- responding parity-check matrix H. A codeword y ∈ C is trans- mitted across a memoryless binary-input output-symmetric channel, resulting in a received vector r. Assuming that the transmitted codewords are equiprobable, the ML decoder ﬁnds the solution to the following optimization problem
where u i ∈ {0, 1}, and γ is the vector of log-likelihood ratios (LLR) deﬁned as
| u i = 0) Pr ( r i | u i = 1)
Since the ML decoding problem (1) is an integer pro- gramming problem, it is desirable to replace its nonlinear constraints with a set of linear constraints, transforming the IP problem into a more readily solved LP problem. As an approx- imation to ML decoding, Feldman et al. relaxed the codeword polytope onto the fundamental polytope, denoted as P. This polytope has both nonintegral and integral vertices, with the latter corresponding precisely to the codewords in C, yielding the ML-certiﬁcate property mentioned above. The fundamental polytope is described by a set of linear inequalities, obtained as follows. For each row j = 1, . . . , m of the parity-check matrix, corresponding to a check node in the associated Tanner graph, the linear inequalities used to form the fundamental polytope P are given by
(3) These are equivalent to
(4) where N (j) ⊆ {1, 2, . . . , n} is the set of neighboring variable nodes of the check node j in the Tanner graph; that is, N (j) = {i : H j,i = 1} where H j,i is the element in the jth row and ith column of the parity-check matrix, H.
In the original formulation of LP decoding presented in [1], every check node j generates 2 |N (j)|−1 parity inequalities that are used as linear constraints in the LP problem described above. The total number of constraints and the complexity of the LP problem grows exponentially with the maximum check node degree. In [3], an adaptive approach, called adaptive linear programming (ALP) decoding, was proposed as an alternative to the direct implementation of the original LP decoding algorithm. The ALP decoder exploits the structure of the LP decoding problem, reﬂected in the statement of the following lemma.
Lemma 1 ( [3]): If at any given point u ∈ [0, 1] n , one of the parity inequalities introduced by a check node j is violated, the rest of the parity inequalities from this check node are satisﬁed with strict inequality.
Deﬁnition 1: Given a parity-check node j, a set V ⊆ N (j) of odd cardinality, and a vector u ∈ [0, 1] n such that the corresponding parity inequality of the form (3) or (4) does not hold, we say that the constraint is violated or, more succinctly, a cut at u.
In [3], an efﬁcient algorithm for ﬁnding cuts at a vector u ∈ [0, 1] n was presented. It relies on the observation that
violation of a parity inequality (4) at u implies that |V| − 1 <
The algorithm ﬁrst puts the entries of u in non-increasing order, i.e., u 1 ≥ · · · ≥ u n . It then successively considers sub- sets of odd cardinality having the form V = {u 1 , . . . , u 2k+1 }, increasing the size of V by two each step, until a cut (if one exists) is found. This algorithm can ﬁnd a cut among the con- straints corresponding to a check node j by examining at most |N (j)|/2 inequalities, rather than exhaustively checking all 2 |N (j)|−1 inequalities in the original LP decoding formulation.
The ALP decoding algorithm starts by solving the optimiza- tion problem with the following constraints
The solution of this initial problem can be obtained simply by making a hard decision on the components of a received vector. The ALP decoding algorithm starts with this point, searches every check node for cuts, adds all the cuts found during the search into the LP problem, and solves it again. This procedure is repeated until an optimal integer solution is generated or no more cuts can be found. (See [3] for more details). The adaptive LP decoding algorithm has exactly the same error-correcting performance as the original LP decoder.
In this section, we provide an efﬁcient method to search for violated parity inequalities (or cuts) corresponding to an existing parity-check. This result serves as the basis for a new adaptive approach to generating RPCs that provide cuts. Computer simulation results, presented in Section IV, indicate that the new cut-generating algorithm can signiﬁcantly improve the error-rate performance of LP decoding.
Consider the original parity inequalities in (3) given by Feldman et al. in [1]. If a parity inequality derived from check node j induces a cut at u, the cut can be written as
From (8) and Lemma 1, we can derive the following necessary condition for a parity-check constraint to induce a cut.
Theorem 1: Given a vector u, let S = {i ∈ N (j)|0 < u i < 1} be the set of nonintegral neighbors of parity-check node j, and let T = {i ∈ S|u i > 1 2 }. A necessary condition for parity-check constraint j to induce a cut at u is
Input: parity-check node j and vector u Output: variable node set V
| 1 2
− u i | > 1 2
where, for x ∈ R, |x| denotes the absolute value, and for a set X , |X | denotes its cardinality.
Remark 1: Given a nonintegral vector u, to see whether a parity check node could provide a cut at u, we only need to check its fractional neighbors.
We can further extend Lemma 1 to get a sufﬁcient condition for a parity-check node to give a cut at u.
Theorem 2: Given a vector u, let S = {i ∈ N (j)|0 < u i < 1} and T = {i ∈ S|u i > 1 2 }. If the inequality
holds, there must be a violated parity inequality derived from parity-check j. This sufﬁcient condition can be written as
Theorem 1 and Theorem 2 provide a necessary condition and a sufﬁcient condition, respectively, for a parity-check node to produce a cut at any given vector u. Together, they form the basis for a highly efﬁcient technique for ﬁnding cuts, the Cut Search Algorithm described in Algorithm 1. If there is a violated parity inequality, the Cut Search Algorithm returns the set V corresponding to the cut; otherwise, it returns an empty set.
Although the addition of a redundant row to a parity-check matrix does not affect the null-space and, therefore, the linear code it deﬁnes, different parity-check matrix representations of a linear code may give different fundamental polytopes underlying the corresponding LP relaxation of the ML de- coding problem. This fact inspires the use of cutting-plane techniques to improve the error-correcting performance of LP and ALP decoders. Speciﬁcally, when the LP decoder gives a nonintegral solution (i.e., a pseudocodeword), we try to ﬁnd the RPCs that introduce cuts at that point. The cuts obtained in this manner are called RPC cuts. The effectiveness of this method depends on how closely the new relaxation approxi- mates the ML decoding problem, as well as on the efﬁciency of the technique used to search for the cut-generating RPCs.
An RPC can be obtained by modulo-2 addition of some of the rows of the original parity-check matrix, and this new check introduces a number of linear constraints that may give a cut. In [3], a random walk on a cycle within the subgraph deﬁned by the fractional-valued entries in a pseudocodeword served as the basis for a search for RPC cuts. However, there is no guarantee that this method will ﬁnd a cut (if one exists) within a ﬁnite number of iterations. In fact, the average number of random trials needed to ﬁnd an RPC cut grows exponentially with the code length. The separation algorithm in [4] provides another way to search for RPC cuts, but in many cases the RPC cuts found by this algorithm do not lead to an integral solution, and therefore it provides only limited performance improvement. Motivated by the Cut Search Algorithm introduced in Section III-A, we next propose a new, efﬁcient RPC cut-generating algorithm that has been found empirically to provide useful RPC cuts.
Given a nonintegral solution of the LP problem, we can see from Theorem 1 and Theorem 2 that an RPC with a small number of nonintegral neighboring variable nodes may be more likely to satisfy the necessary condition for generat- ing a cut at the pseudocodeword. Moreover, the nonintegral neighbors should have values either close to 0 or close to 1; in other words, they should be as far from 1 2 as possible.
Let p = (p 1 , p 2 , . . . , p n ) ∈ [0, 1] n be a pseudocodeword solution to LP decoding, with a nonintegral positions, b zeros, and n − a − b ones. We ﬁrst group entries of p according to whether their values are nonintegral, zero, or one. Then, we sort the nonintegral positions in ascending order according to the value of | 1 2 − p i | and deﬁne the permutated vector p = Π(p) satisfying | 1 2 − p 1 | ≤ · · · ≤ | 1 2 − p a |, p a+1 = · · · = p a+b = 0, and p a+b+1 = · · · = p n = 1. By applying the same permutation Π to the columns of the original parity- check matrix H, we get
where H (f ) , H (0) , and H (1) consist of columns of H corre- sponding to positions of p with nonintegral values, zeroes, and ones, respectively.
The following familiar deﬁnition from matrix theory will be useful [5, p. 10].
Deﬁnition 2: A matrix is in reduced row echelon form if its nonzero rows (i.e., rows with at least one nonzero element) are above any rows of all zeroes, and the leading entry (i.e., the ﬁrst nonzero number from the left) of a nonzero row is the only nonzero entry in its column and is always strictly to the right of the leading coefﬁcient of the row above it.
By applying a suitable sequence of elementary row opera- tions Φ (over F 2 ) to H , we get
where ¯ H (f ) is in reduced row echelon form. Applying the inverse permutation Π −1 to the columns of ¯ H, we get an equivalent parity-check matrix ˜ H = Π −1 ( ¯ H), whose rows are likely to be cut-generating RPCs.
Theorem 3: If there exists a weight-one row in submatrix ¯ H (f ) , the corresponding row of the equivalent parity-check matrix ˜ H is a cut-generating RPC.
Proof: Given a pseudocodeword p, suppose the jth row of submatrix ¯ H (f ) has weight one and the corresponding nonintegral position in p is p i . Since it is the only nonintegral neighbor of RPC j, the left-hand side of (12) is equal to −| 1 2 − p i |. Since 0 < p i < 1, this is larger than − 1 2 , the right- hand side. Hence, according to Theorem 2, RPC j satisﬁes the sufﬁcient condition for providing a cut. In other words, there must be a violated parity inequality induced by RPC j.
For other rows of ˜ H, we can apply the Cut Search Algorithm to ﬁnd any further potential cuts. Algorithm 2 describes an improved LP decoding algorithm which includes the adaptive cut generation techniques just described.
Algorithm 2 LP Decoding with Adaptive Cut Generation Input: cost vector L, parity-check matrix H
9: 	 Terminate. 10: else
To demonstrate the improvement offered by the proposed RPC search algorithm, we compare its error-correcting per- formance to that of LP/ALP decoding , BP decoding (sum- product algorithm with a maximum of 1000 iterations), the Separation Algorithm (SA) [4], and ML decoding for two
LDPC codes on the additive white Gaussian noise (AWGN) channel. We use the Simplex algorithm from the open-source GNU Linear Programming Kit (GLPK [6]) as the LP solver. The LDPC codes we evaluated are a length-96, (3,6)-regular LDPC code [7] and the (155,64) Tanner LDPC code [8].
In Fig. 1, we show the results for MacKay’s length-96, (3,6)-regular LDPC code (the 96.33.964 code from [7]). As a benchmark, we also plot a lower bound on ML decoding performance. In order to obtain this ML lower bound, we counted the number of times that our proposed algorithm converged to an incorrect codeword and then divided that by the total number of transmitted codewords, as shown in Table I. The ML certiﬁcate property of LP decoding implies that ML decoding would also fail in these cases, and it would
also probably fail on some other cases where LP decoding outputs pseudocodewords. Therefore, this estimate gives us a lower bound on the frame error rate (FER) of ML decoding. We can see that the proposed search algorithm approaches the ML lower bound in the high SNR region. Actually, from the simulation results, reﬂected in Table I, we observed that, when E b /N 0 is greater than 4.5 dB, all decoding errors correspond to incorrect codewords, which means that the proposed algorithm basically achieved ML decoding performance. In Fig. 2, which shows results for the (3,5)-regular (155,64) Tanner code, we plot the ML performance curve from [4]. It can be seen that the proposed algorithm closes the 1.25 dB gap between LP decoding and ML decoding to approximately 0.25 dB.
Since the improvement in error-rate performance comes from the additional RPC cuts found in each iteration, our algorithm generally requires more iterations and the solution of larger LP problems in comparison to ALP decoding. In the remaining part of this section, we investigate the relative complexity of our proposed algorithm in comparison to ALP decoding and the SA. The simulation statistics are averaged over the number of transmitted codewords required for the decoder to fail on 200 codewords. In Fig. 3, we compare the average number of iterations needed to decode one codeword, i.e., the average number of LP problems solved to decode one codeword of the Tanner (155,64) code on the AWGN channel. Fig. 4 shows the average number of total constraints provided by generated RPCs to decode one codeword.
The results show that the improvement in performance achieved by the proposed algorithm does come at the cost of increased decoding complexity. In comparison to the SA, the proposed algorithm requires more iterations to decode and therefore have better error-rate performance, because it can still ﬁnd cuts and continue decoding iterations when SA stops. Moreover, as reﬂected in Fig. 4, we observe that our proposed algorithm actually utilizes fewer cuts from RPCs, which suggests that the RPC cuts found by our algorithm are generally stronger than those found by SA. And at higher SNR, the proposed decoder can more often successfully decode the received frames without generating RPC cuts than SA.
In this paper, we derived a new sufﬁcient condition and a new necessary condition for a parity-check constraint in an LDPC code deﬁnition to give a cut at a pseudocodeword produced by LP decoding. Using these results, we developed an efﬁcient algorithm to search for cuts and proposed an effec- tive RPC cut generating algorithm. The key innovation in the cut generating algorithm is a particular transformation of the parity-check matrix used to deﬁne the LP decoding problem. By properly re-ordering the columns of the original parity- check matrix and transforming it to a partial reduced row echelon form, we could efﬁciently identify RPC cuts that were found empirically to signiﬁcantly improve the LP decoder performance. Error-rate simulation results for two moderate- length codes show that the proposed algorithm outperforms previously proposed decoding algorithms based upon linear programming, closing the performance gap to ML decoding to less than 0.3 dB when the FER is less than 10 −2 .
This work was supported in part by the National Science Foundation under Grant CCF-0829865.
[[[ REFS ]]]
J. Feldman
M. Wainwright
D. Karger
--
Using linear programming to decode binary linear codes
----
P. O. Vontobel
R. Koetter
--
Graph-cover decoding and ﬁnite-length analysis of message-passing iterative decoding of LDPC codes
----
M. H. Taghavi
P. H. Siegel
--
Adaptive methods for linear program- ming decoding
----
A. Tanatmis
S. Ruzika
H. W. Hamacher
M. Punekar
F. Kienle
N. Wehn
--
A separation algorithm for improved LP-decoding of linear block codes
----
A. Hor
R. Johnso
--
R
----

--
GNU Linear Programming Kit, http://www
----
D. J. C. MacKa
--
Encyclopedia of Sparse Graph Codes
----
R. M. Tanner
D. Sridhara
T. Fuja
--
A class of group-structured LDPC codes
[[[ META ]]]
parsed -> yes
file -> E:\isit2011\148.pdf
[[[ LINKS ]]]

