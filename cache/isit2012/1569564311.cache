{"id":"1569564311","paper":{"title":{"text":"Rate Allocation for Component Codes of Plotkin-Type UEP Codes"},"authors":[{"name":"Jin Soo Park"},{"name":"Ki-Hyeon Park"},{"name":"Hong-Yeop Song"}],"abstr":{"text":"Abstract\u2014In this paper, we present an analysis on the perfor- mance of Plotkin-type UEP codes by using threshold and equiva- lent channel model under the Gaussian assumption. Speciﬁcally, we give a framework on how to assign the rate of each component code of this Plotkin-type UEP code so that the goal of UEP is successfully achieved with far better overall BER performance. The result is surprising in that which component code should be assigned for MSB can be changed according to the assigned rate of each component code and overall rate."},"body":{"text":"Multimedia streaming services on their wireless devices is becoming more and more popular recently, and multimedia packets can be distinguished into two different types according to their role of importance in the decoding: more signiﬁ- cant bits(MSB) and less signiﬁcant bits(LSB). This motivates so called the unequal error protection(UEP) channel coding schemes.\nBecause of their powerful performance, LDPC and turbo codes have been considered for the base schemes of the UEP codes. UEP-Turbo codes with non-uniform puncturing was proposed in [2]. Irregular UEP-LDPC codes with faster convergence property of the higher degree nodes have been discussed in [1]. Further optimized result is presented in [4].\nAnother interesting approach was a Plotkin-type construc- tion using LDPC codes, as suggested in [3]. We have just simulated the performance of this scheme with the same component codes C 1 and C 2 of length 1000 and rate 0 .5. The result was so curious in that the component codes work much more poorly (more than 1 dB) than the code C 1 by itself as an equal error protection (EEP) code. This implies that the Plotkin-type construction in [3] could result in much poorer performance, unless the rate of each component code is carefully assigned.\nIn this paper, we will give a theoretical framework on how to assign the rate of each component code so that the component code works as expected i.e. comparable to the performance of not only each component code as an EEP code but also the ideal average code with the same parameter. This result enables the system designer to predict immediately the performance of both component codes of the Plotkin-type UEP codes without computer simulation. Therefore, it may further help the designer to decide which component code should be assigned for MSB and which for LSB.\nThis paper is organized as follows. In Section II, we review the Plotkin-type UEP codes with encoding scheme, multistage\ndecoding algorithm, and some properties with the notion of equivalent channel noise. In Section III, we give an analysis for the rate allocation of component codes of the Plotkin- type UEP codes using equivalent channel models based on Gaussian assumption. Simulation results and conclusions are given in Sections IV and V, respectively.\nIn this section, we will brieﬂy review the Plotkin-type UEP codes described in [3].\nwhere C 1 and C 2 are [ n, k 1 , d 1 ] and [n, k 2 , d 2 ] binary linear codes, respectively, and u + v over GF(2) is performed component-wise. The codes C 1 and C 2 are named component codes. Letting w = u + v over GF(2), one transmits u in the ﬁrst time slot and w in the second. In [3], they used the LDPC codes as the component codes, and called as Plotkin- type UEP-LDPC codes.\nThe basic decoding process of the Plotkin-type UEP codes is called as multistage(MS) decoding. Let y = {y i } n i=1 and y = {y i } n i=1 be the ﬁrst and second received vectors for u and w, respectively, and L y = {L y i } n i=1 and L y = {L y i } n i=1 be their log-likelihood ratio(LLR)s, respectively. The MS decoding procedure is given as follows:\n2) Decoding of v: Using L v i , decode v for C 2 . Denote the result by ˆ v = { ˆ v i } n i=1 .\n3) Calculation of LLR L u = {L u i } n i=1 for u: L u i = L y i + ( −1) ˆ v i L y i .\nThe advantage of this algorithm is the LLR gain of the u in the 3rd step of the above as mentioned in [3]. This algorithm can be applied repeatedly, and it is called as the multiround- multistage(MR-MS) decoding.\nIn the previous paper [3], authors used the concept of equivalent channel under the Gaussian assumption [6]. A Gaussian random variable X ∼ N (m x , σ 2 x ) can be represented as an equivalent form N (1, σ 2 x,eq = σ 2 x /m 2 x ), in the sense of the equivalent SNR, where σ 2 x,eq is the equivalent variance of X as shown in Fig. 1. Let σ 2 1 and σ 2 2 are the equivalent channel noise that C 1 and C 2 in C p experience, respectively. The brief summaries of Lemma 1, 2, 3 in [3] are listed as follows. For the Lemma 2 and 3, perfect decoding of C 2 (i.e., v) is assumed.\nLemma 2 [3] If the equivalent channel noise σ 2 ch → ∞, then σ 2 1 → σ 2 ch /2 and σ 2 2 → σ 4 ch .\nLemma 3 [3] If the equivalent channel noise σ 2 ch → 0, then σ 2 1 → σ 2 ch /2 and σ 2 2 → σ 2 ch .\nThe meaning of these lemmas is the UEP properties of MS decoding which comes from the unequality of the equivalent channel SNRs by the component codes.\nIn this section, we will discuss the rate of the component codes and their error correction performance. In this paper, we just consider the AWGN channels. We list some of the notation we ﬁx throughout the paper:\n\u2022 C 1 and C 2 : two component codes of the same length for C p . These are sometimes referred to as C 1 in C p or C 2 in C p in order to clearly specify that they are component codes of C p .\n\u2022 C a and R a : an (ideal) average EEP code with the same rate as C p .\nLet R 1 and R 2 be the code rate of C 1 and C 2 , respectively. Then the rate of C p is the average of these:\nNow we consider an (ideal) average EEP code C a which achieves the channel capacity and has rate R a . We further assume that its rate and length are the same as those of C p . That is, we have R a = R p . Let σ 2 a,th be the threshold of C a in BPSK modulation system under AWGN channel [7], then we can write the relation of σ 2 a,th and R a as\nR a = f (σ 2 a,th ), \t (3) where the function f (σ 2 ) is given by\nLet σ 2 1,th and σ 2 2,th be the threshold of C 1 and C 2 in the equivalent noise variance form, respectively. Then we can rewrite the code rate relation as follows,\n2 \t (4) σ 2 2,th = f −1 (2f (σ 2 a,th ) − f(σ 2 1,th )). \t (5)\nB. Equivalent Channel Models and Thresholds of Component Codes\nBy the relation (2), if we select R a and R 1 , then R 2 will be ﬁxed. The Gaussian assumption enables the approximation of equivalent noise variance σ 2 2 that is experienced by the decoder of C 2 in C p . [6] Let C p and C a be transmitted over the equivalent channel with σ 2 ch . For the fair comparison and design purpose, we may put σ 2 ch = σ 2 a,th . Then, the LLRs of received vectors {L y i } n i=1 for C 1 in C p and {L y i } n i=1 for C 1 + C 2 in C p both follow independent N (2/σ 2 a,th , 4/σ 2 a,th ).\nBy using Monte Carlo simulation and Gaussian assumption, we may obtain E [L v i ] and V ar [L v i ], and hence the equivalent noise σ 2 2 = V ar [L v i ]/E 2 [L v i ] of the channel for C 2 in C p .\nFor the perfect decoding of C p , the two component codes C 1 and C 2 in C p should be error free. If the equivalent channel σ 2 a,th satisﬁes the error free condition of C 2 in C p , we can claim that the equivalent channel noise of C 1 in C p is σ 2 1 = σ 2 a,th /2 by lemmas 2 and 3. It is clear that C p will be error free if the following (6) is satisﬁed:\nσ 2 1 ≤ σ 2 1,th and σ 2 2 ≤ σ 2 2,th . \t (6) Now, we need to determine the values of σ 2 1,th and σ 2 2,th satisfying (6) for a given R a and hence σ 2 a,th . This will then determine the rate R 1 and R 2 by the similar relations as (3) or (4). This process is shown in Fig. 3. Note that we set\nFigure 2 shows the result of all the computations above for various values of σ 2 1,th for a given value of σ 2 a,th = 0.8 and hence R a = 0.5604. Here, the solid line corresponds to the various values of the threshold of the each component code where σ 2 1,th is set to be the x-axis. Note that σ 2 2,th can be determined from σ 2 a,th and σ 2 1,th . The dashed line is the equivalent channel noise for the decoding of C 2 and the dotted line is for the decoding of C 1 , respectively, for the given\nchannel condition σ 2 a,th . Now, it is obvious to see the range of σ 2 1,th and σ 2 2,th satisfying the inequalities (6). One intersection of these inequalities is designated by the vertical line with mark Choice-o. This line determined the value σ 2 1,th = 0.4 and σ 2 2,th = 1.724. This will then determine the rate of C 1 and C 2 to be R 1 = 0.79 and R 2 = 0.33. From this, we may foresee that both of C 1 and C 2 with these rates will perform (ideally) error-free in C p .\nTo the left of this vertical line lies the region in which the following holds:\nThis implies that C 1 works poorly even though C 2 might work with acceptable level of performance. To the right of the vertical line lies the region in which the completely opposite might happen. However, it could a bit different from this prediction because the dotted line for σ 2 1 will go up passing this vertical line due to the poor performance of C 2 which can obviously be seen by the fact that σ 2 2 > σ 2 2,th . Above analysis process is described in ﬁgure 3. And we have selected three cases from this ﬁgure, one from each region, and performed BER simulation of various codes involved. The result is given in the next section.\nFor BER performance simulation, we used LDPC codes for the component codes. Table I shows the target code rates for the simulation of Plotkin-type UEP-LDPC codes. C a , C 1 and C 2 are optimized LDPC codes by using Gaussian approximation [6] and progressive edge growth(PEG) [5]. The length of C a and C p are 5000, C 1 and C 2 are 2500. We decoded the codes C p (and thus C 1 and C 2 in C p ) by using the MS decoding in Section II. For the decoding of the component codes as EEP codes, the belief propagation(BP) decoding [8] and 100 iterations are applied.\nWe would like to compare the performance difference between C p and C a , where C p is determined by C 1 and C 2 whose rate is determined by the vertical line in Fig.2 and shown in the middle line of Table I. It turned out that σ 2 1,th = 0.4 ≈ σ 2 1 and σ 2 2,th = 1.724 ≈ σ 2 2 . This results in the rate of C 1 and C 2 to be R 1 = 0.79 and R 2 = 0.33, respectively. In Fig. 4, the curve for C p is the average of C 1 and C 2 in C p . C a is the code that has the same parameter as C p and optimized by itself. From Fig. 4, we observe the following:\n1) Between C p and C a : They have quite similar perfor- mance as predicted by the design and analysis in the previous section.\n2) Between C i in C p and C i only as EEP: They show some difference in the performance due to Plotkin-type construction. The code C 2 with \u2018good\u2019 performance becomes worse as a component of C p and the code C 1 with \u2018bad\u2019 performance becomes better as a component of C p . However, a careful look shows that the curve of C 2 in C p has larger slope than that of C 2 only. Therefore, they will meet at some point of cross-over and this point can be calculated exactly. In this sense, one might say that the code C 2 with \u2018bad\u2019 performance becomes better as a component of C p , similar to the case of C 1 .\n3) Between C 1 in C p and C 2 in C p : The original design in [3] suggests C 1 for MSB and C 2 for LSB because of the hope that C 1 in C P will become better than C 1 only due to the LLR gain of the u in the 3rd step of MS decoding in Section II. However, this result shows that C 2 is more appropriate for MSB, which is quite surprising. We will later show when C 1 is appropriate for MSB with far more degradation in the overall performance. This will answer the question raised in Introduction why the simulation of a certain Plotkin-type UEP code resulted in so poor performance.\nFigures 5 and 6 show the BER performances of rate assignment of Choice-Left and Choice-Right. The rates are shown in Table I. Comparing these two cases with each other, and with Fig. 4, we may draw the following observations:\n1) Between C p and C a : The Plotkin-type UEP code C p in either Choice-Left or Choice-Right becomes much worse than C a as predicted by the design and analysis in the previous section.\n2) Between C i in C p and C i only as EEP: Two cases show a big difference. For Choice-Left, C 2 in C p works much better than C 2 only as EEP, and C 1 in C p works better(?) than C 1 only as EEP (which is a contrary to the prediction). We suspect this happens because the w has more power than C 2 only. This case might be better for UEP purpose than the case Choice-o with a bit of degradation in the overall performance. For Choice- Right, the situation is a complete opposite. In this case, both C 1 and C 2 in C p work far much worse than C 1 and C 2 only as EEP, respectively, and hence so do the overall performance of C p .\n3) Between C 1 in C p and C 2 in C p : The result of Choice- Left shows similar behavior to those of Choice-o as predicted. For Choice-Right, the result is surprising. C 1 in C p now performs better than C 2 in C p so the original suggestion of [3] might work for UEP. Note however in this case that the component codes in C p and hence the code C p work far much worse than C a as well as C 1 or C 2 only as EEP. This clearly answers the question raised in Introduction. This result is due to the poor assignment of the rate for the component codes of the Plotkin-type UEP code C p .\nBefore conclusion, we add the following additional result for different values of R a in the beginning. One example is\nshown in Fig. 7. This ﬁgure shows that there does not exist any vertical line on which the inequalities (6) are satisﬁed. Here, R p = R a = 0.2905 and σ 2 a,th = 2.0. This implies that one has to be very careful in setting the rate of the overall code C p in the beginning since otherwise Plotkin-type construction becomes far much worse than the component code only as EEP no matter how the rate might be assigned. We suspect that this will happen for the values of R p below certain threshold around 0 .4 which need further analysis or simulation in the future.\nIn this paper, we suggest a guideline for the combination of the component code rates of Plotkin-type UEP codes to match the target BER or SNR difference of MSB and LSB performance by using the threshold and equivalent noise variance analysis.\nFor a ﬁxed average code rate of \u201cgood\u201d choice, we show that one can draw a graph similar to Fig. 2. In general, we believe that then the region satisfying (6) exists with some interval of σ 2 1,th (x-axis). Then any vertical line in the region will determine the rates of the component codes whose performance in the construction of Plotkin-type UEP codes can be predicted to be similar to those of the capacity achieving average code. Here, C 2 might be better appropriate for MSB and C 1 for LSB. When the vertical line is selected from the \u2018left\u2019 of this region, the UEP capability might be increased with a bit degradation in the overall performance. The choice from the \u2018right\u2019 of this region must be avoided since not only the component codes of Plotkin-type UEP codes but also the code itself become far much worse.\nFinal remark is about the Monte Carlo simulation to obtain the statistics of"},"refs":[{"authors":[{"name":"N. Rahnavard"},{"name":"F. Fekri"}],"title":{"text":"New Results on Unequal Error Protection Using LDPC Codes"}},{"authors":[{"name":"G. Caire"},{"name":"G. Lechner"}],"title":{"text":"Turbo codes with unequal error protection"}},{"authors":[{"name":"V. Kumar"},{"name":"O. Milenkovic"}],"title":{"text":"On Unequal Error Protection LDPC Codes Based on Plotkin-Type Constructions"}},{"authors":[{"name":"C. Poulliat"},{"name":"D. Declercq"},{"name":"I. Fijalkow"}],"title":{"text":"Enhancement of Unequal Er- ror Protection Properties of LDPC Codes"}},{"authors":[{"name":"X.-Y. Hu"},{"name":"E. Eleftheriou"},{"name":"D. M. Arnold"}],"title":{"text":"Progressive edge-growth Tanner graphs"}},{"authors":[{"name":"S.-Y. Chung"},{"name":"T. J. Richardson"},{"name":"R. L. Urbanke"}],"title":{"text":"Analysis of Sum- Product Decoding of Low-Density Parity-Check Codes Using a Gaussian Approximation"}},{"authors":[{"name":"D. J. C. MacKa"}],"title":{"text":"Information Theory, Inference, and Learning Algo- rithms, Cambridge University Press, ch"}},{"authors":[{"name":"U. Madho"}],"title":{"text":"Fundamentals of Digital Communication, Cambridge Uni- versity Press, Cambridge, 2008"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569564311.pdf"},"links":[],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S9.T5.4","endtime":"11:10","authors":"Jin Soo Park, Ki-Hyeon Park, Hong-Yeop Song","date":"1341399000000","papertitle":"Rate Allocation for Component Codes of Plotkin-Type UEP Codes","starttime":"10:50","session":"S9.T5: Linear Codes and UEP Codes","room":"Kresge Little Theatre (035)","paperid":"1569564311"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
