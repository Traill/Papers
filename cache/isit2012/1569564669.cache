{"id":"1569564669","paper":{"title":{"text":"Can geographic routing scale when nodes are mobile?"},"authors":[{"name":"Dinesh Ramasamy"},{"name":"Upamanyu Madhow"}],"abstr":{"text":"Abstract\u2014We begin by asking whether geographic routing can scale when nodes are mobile; that is, can the overhead involved in tracking node locations be accommodated within the transport capacity of large-scale mobile ad hoc networks (MANETs)? We answer this question in the afﬁrmative by proposing an efﬁcient position publish protocol which ﬁts within the transport capacity and a routing protocol that operates with imperfect information of the destination\u2019s location. The routing protocol guarantees, with high probability, routes whose lengths are within a constant \u201cstretch\u201d factor of the shortest path from source to destination. The key idea underlying the scalability of the publish protocol is for each potential destination node to send location updates (with frequency decaying with distance) only to a subset of network nodes, structured as annular regions around it (the natural approach of updating circular regions in distance- dependent fashion does not scale). The routing protocol must then account for the fact that the source and/or relay nodes may not have estimates of the destination\u2019s location (or may have stale estimates). Spatial and temporal scaling of protocol parameters are chosen so as to guarantee scalability, route reliability and route stretch."},"body":{"text":"Geographic routing is attractive for networks in which nodes know their own locations (e.g., using GPS) because a node only requires estimates of the locations of its immediate neigh- bors and of the destination node in order to forward a message. When the nodes in a network can move, a node can still maintain estimates of its neighbors\u2019 locations quite easily (the overhead for the local information exchanges for this purpose is small), but the bottleneck becomes global dissemination of information regarding the locations of moving destination nodes. As observed in prior work, this bottleneck can be alleviated by structuring location updates such that distant nodes get fewer updates, and live with a fuzzier view of the destination\u2019s location without excessively compromising route quality. This intuition is the starting point for the present paper, which provides an approach for provably scaling geographic routing to large mobile ad hoc networks (MANETs), while providing performance guarantees on route suboptimality due to imperfect location information.\nScalability of any routing protocol demands that the trafﬁc generated by routing updates be within the network transport capacity obtained with a ﬁxed communication bandwidth,\nbounds on which have been established in the pioneering work of Gupta and Kumar [2]. In this paper, we provide a \u201cposition publish\u201d scheme which potential destination nodes use for global location updates, and show that (a) if all network nodes use this publish scheme, the resulting overhead is within the Gupta-Kumar bounds, and (b) information from the publish scheme enables routing with paths of length within a constant \u201cstretch\u2019\u2019 factor of the shortest path from source to destination. Scalability is achieved by sending location updates to annular (rather than circular) regions (the number of such regions scales as log n, where n is the number of nodes). Counting outward, the inner radius and thickness of these rings increase exponentially with their index. Key parameters of the location publish protocol are these exponents, as well as those of parameters determining the spatial and temporal validity of a location update. Our routing protocol employs greedy geographic forwarding, with relay nodes overwriting information regarding the destination\u2019s location if they have better information than what is contained in the packet. We determine constraints on the protocol parameters so as to achieve scalability and correct routing, and provide bounds on the worst-case route stretch.\nTypical paths taken by a packet to a destination using our protocol are shown in Fig. 1 as a preview, prior to a more detailed discussion. Note that, while our protocol is designed\non the assumption that there are no voids in the network, voids can be handled using well-known techniques such as greedy face traversal [1].\nSince we are concerned with large-scale networks, our communication model and notion of scalability are guided by the relevant asymptotic results of Gupta and Kumar [3], [2]. Mobility can improve scalability if large delays are allowed [4] and in a similar spirit, mobility can be exploited to reduce the overhead of location updates, as argued in [5], [6]. This is not the regime of interest to us: we are interested in delivering packets to their destinations with minimal delay (quantiﬁed via the notion of route stretch), hence mobility is a nuisance for us.\nThe literature on MANET routing and on geographic rout- ing (for stationary or mobile nodes) is vast, hence we restrict attention here to prior work that is most closely related to our approach. With the aim of reducing the position publish overhead, DREAM [7] proposes a publish scheme in which frequency of updates is reduced as the distance from the updating node increases. While this intuition is the starting point for our scheme as well, location updates made to all nodes as in DREAM are not scalable. MLS[8] proposes a \u201clazy\u201d hierarchical position lookup service in which updates are published to certain ﬁxed geographical regions. The rout- ing algorithm is similar in spirit to our scheme, in that it is able to guarantee a constant route stretch without requiring that all nodes in the network obtain location updates. MLS builds on an earlier scheme termed LLS[9] and improves the stretch of the routing protocol to a constant stretch. The key difference of [8], [9] from our work is they do not relate the publish overhead due to persistent mobility to network transport capacity, and also do not provide means to vary the tradeoff between route stretch and publish overhead.\nWe consider a network of n nodes in the two-dimensional plane, with node density ﬁxed at Λ as n gets large. Thus, the area of the deployment region n/Λ grows with n.\nConnectivity: We assume that the communication radius for all nodes is ﬁxed at r(n), satisfying Λπr 2 (n) = (1 + ǫ) log n [3] to ensure connectivity. We will denote the communication radius r(n) by r henceforth. We assume ǫ > ǫ 0 (with ǫ 0 ≈ 1.6), so that greedy geographic routing works with probability 1 [10].\nScalability: Using the protocol model in [2], the maximum number of simultaneous transmissions available per time slot, denoted by T A (n), scales as Θ W n Λr 2 , where W denotes the communication bandwidth. Denote by T U (n) the average of the total number of simultaneous transmissions needed per unit time for the position update protocol across all nodes. It is also useful to deﬁne the average number of transmissions on a per node basis as t U (n) = T U (n)/n and t A (n) = T A (n)/n, respectively. We deﬁne a protocol to be scalable if T U (n) = O (T A (n)), or equivalently, t U (n) = O (t A (n)).\nThis deﬁnition assumes that the load induced on the network as a result of position updates is uniform in space and time. This does hold for the protocol we propose under our mobility model, which is described next.\nMobility Model: Every node in the network is mobile, exe- cuting Brownian motion (MS velocity 2σ 2 ) with reﬂection at the boundaries of the deployment region(assumed to be square for convenience). This model is well-suited for investigating scalability, which depends on how distant nodes perceive the mobility of a destination node, since a large class of randomized models for local mobility \u201clook like\u201d Brownian motion when viewed from far away and at large time scales.\nWe now provide some basic computations that motivate the proposed protocol.\nWhen information about the destination\u2019s location is imper- fect, the natural approach is to route the packet along the best estimate of the direction of the destination, possibly updating this estimate after each hop, until we get close enough that the destination is within the communication radius. If the angle between the correct and estimated directions is θ, then the progress towards the destination per unit distance traveled is cos θ, so that we would like θ to be small. This is depicted in Fig. 2, where p denotes the packet\u2019s current location, d denotes the destination\u2019s location, and e the currently available estimate of the destination\u2019s location. Denoting the relative uncertainty in location as U = ||d−e||/||p−e||, we note that, for a ﬁxed relative uncertainty, the localization error can be larger when the packet is further away from the destination. Further, bounding the relative uncertainty leads to bounded route stretch: if the relative uncertainty is always less than U 0 < 1, then the worst-case angle between the correct and estimated directions always satisﬁes sin θ ≤ U 0 . This implies that cos θ ≥ 1 − U 2 0 , and that the route stretch is at most 1/ 1 − U 2 0 . Thus, a natural approach to guarantee a worst- case route stretch is to employ a position update protocol that maintains relative uncertainty below a level U 0 < 1 throughout the network. For ﬁxed relative uncertainty, the localization error can be larger when the packet is further away from a destination, which means we can reduce the update frequency to far-away nodes. However, we observe next that such a reduction, by itself, is not enough to provide scalability.\nWe note here for future use that the minimum number of transmissions C (A) needed to multicast a message to all nodes in a connected region A of area |A| is Θ |A| /r 2 . Both upper and lower bounds use tiling arguments similar to those in [2], omitted here due to lack of space.\nIn order to maintain a relative uncertainty of at most U 0 , location updates from a particular node must reach all nodes that are a distance z away from it if it moves a distance U 0 z. Estimating the average frequency of these updates, and using the cost of multicast, we can show that the per-node overhead is given by t U (n) = Ω σ 2 log n/r 2 . This does not scale as the available number of transmissions per node, scales as t A (n) = Θ W/(Λr 2 ) .\nThus, while the angle between the true and estimated direc- tions towards the destination cannot be too large if we wish to provide guarantees on route stretch, the preceding overhead computations imply that we must appropriately choose a subset of nodes to update in order to reduce the routing overhead enough that the protocol can scale.\nGiven space limitations, we discuss only the key ingredients of the proposed protocol.\nWe ﬁrst make the obvious observation that, in order to implement any geographic forwarding protocol, each node must maintain a list of its neighbors and their positions. Such neighbor lists can be maintained using periodic local broadcasts which can be accommodated within a constant bandwidth, and are therefore irrelevant to considerations of scalability. Our main focus, therefore, is on how position updates to distant nodes are performed. We now describe position updates performed by a typical node that is a potential destination (we call this the destination node henceforth). The destination node typically directs its updates to geographic regions structured as annular rings around its current position, indexed as i = 0, 1, ..., K with increasing radii. The i-th ring has a ﬁxed inner radius of r i and thickness d i . So the geographical region covered by a ring is speciﬁed by its center c and its index i. Updates published to the i-th ring have a lifetime, which is at most T i , after which they are discarded by the relay nodes which received them. We refer to this as the temporal validity of an update. Updates are also constrained in space and can only be used by relay nodes when they are in the ring to which the update was made. We refer to this as the spatial validity of an update.\nLet d (t) denote the position of the destination node at time t. There are two kinds of location updates: normal and abnormal updates. While the two kinds of updates use the location of the destination d (t 0 ) at the time of dispatch t 0 as their position estimate, they differ in two aspects: (i) normal updates are centered around c = d (t 0 ), while abnormal updates are not (ii) normal updates have lifetimes of T i while abnormal updates have lifetimes shorter than T i .\nTypes of updates and their triggers: We will explain this via a running example: We focus on a speciﬁc ring index i, with the understanding that updates occur in parallel for all ring indices. Suppose that at time t 0 , the destination decides to send a normal update to ring index i as shown in Fig. 3. It updates the relay nodes(marked red) in the ring i centered around its current location d (t 0 ). The relay nodes in this ring expect that in the lifetime of the update(up to time t 0 +T i ), the destination will remain within a circle of radius βr i around the current location(marked pink), termed conﬁdence region for the update. This is ensured by the appropriate choice of T i . So, typically, the destination will remain in the conﬁdence region of an update and hence at time t 0 + T i , the update will expire and a new normal update will be published to ring i with center d (t 0 + T i ) as shown in Fig. 4(a). The recipients of the new update are marked blue. However, it is possible that the destination crosses the boundary of the conﬁdence region at time t 1 < t 0 + T i as shown in Fig. 4(b). In this case, the destination sends an abnormal update to nodes(marked green) in the ring centered at the prior update(also referred to as a stale update). The lifetime T i − (t 1 − t 0 ) of the abnormal update is chosen to span the remaining lifetime of the stale update. The purpose of the abnormal update is to prevent misrouting due to stale updates. However note that there can be stale inactive(due to spatial validity) updates elsewhere in the network(nodes marked in red). At time t 1 , the destination\nalso sends a normal update to the ring i (marked blue). This is to ensure that each ring index i always has one normal update, whose conﬁdence region guarantee is met. This enables us to give route stretch bounds. Certain relay nodes may receive both normal and abnormal position updates of index i, which are made at the same time (nodes in Fig. 4(b) which at time t 1 lie in the intersection of the i-th rings centered at d (t 0 ) and d (t 1 )), in which case the recipients preferentially keep the normal update as its lifetime is longer. We choose our system parameters such that the probability of abnormal updates tends to zero as the ring index increases, so that they are essentially irrelevant from the point of view of scalability.\nThe destination node maintains a list of active updates published by it, so that it can publish new updates when these updates time out or become spatially invalid.\nSpatial validity of updates: An update (whose timer has not yet expired) can only be used for geographical forwarding if the relay node is in the ring for which the update was destined. Thus, when a node moves out of this ring, it can not use the information it received about the destination\u2019s location. However, if it returns to the update ring, it will use this information. We place such a restriction on the spatial validity of updates to prevent stale updates from inﬂuencing packet trajectories. Since updates have spatial validity, we are able to use abnormal updates to \u201coverwrite\u201d misleading information about the destination\u2019s location. When abnormal updates are used to compensate for stale updates which have spatial validities, it can be shown that our analysis for route reliability in Section IV-B can be extended to provide bounds on probability of misrouting due to stale updates.\nUpdate propagation: In order to limit the trafﬁc generated by a location update, the destination node sends the update packet in a speciﬁed direction u until it hits the ring it is intended for, at which point it \u201cexpands\u201d into a multicast message. Each intermediate node examines the packet to see if it is in the speciﬁed ring. If not, it simply forwards the packet in the direction u. Once the packet reaches a node in the update ring, that node repackages the update as a multicast packet for all nodes in the update ring. As shown later by our overhead computations, this approach scales when the protocol parameters are appropriately chosen.\nWe now consider the problem of routing a packet to a des- tination which proactively publishes its location as described in Section III-A. The packet contains a ﬁeld indicating the destination identity, the \u201cbest\u201d estimate of its location, and the ring index and time of update corresponding to this estimate. Intermediate nodes use these ﬁelds for geographic forwarding, and are allowed to overwrite them if they have a \u201cbetter\u201d active(spatially and in time) estimate of the destination\u2019s location. An estimate is considered \u201cbetter\u201d only if its ring index is smaller than that of the packet. If the ring indices of the packet and the estimate are the same, this means that the destination node had moved beyond the conﬁdence region of an update and an abnormal update was issued to the same\nregion to avoid misrouting. So in case of such a tie in the packet index, the estimate at the relay is considered better than the one available to the packet only if is more recent.\nInitialization: If the source node does not possess an active update, then it chooses a random direction to relay the packet along: this is indicated in the packet by means of a vector indicating this direction, time of update ∞ and ring index ∞. Until the packet hits a node with an active update all intermediate nodes relay the packet along this direction. When the packet hits a node with an active estimate, it is said to have \u201cbootstrapped\u201d. If the packet reaches the boundary of the network before bootstrap, it bounces off the boundary by reﬂection(this can be implemented if the boundary of the network is known to all nodes).\nWe now analyze the proposed protocol to provide design guidelines on choosing protocol parameters so as to achieve scalability, reliable routing, and guarantees on route stretch. Four parameters, α, β, γ and µ, are involved. The inner radii of the rings scale up exponentially with ring index: r i = r 0 α i , where α > 1. So does the ring thickness, but at a slower rate: d i = d 0 α µi , 0 < µ < 1. The timer durations also scale up exponentially: T i = T 0 α γi . The conﬁdence region for an update to a ring of index i is given by βr i .\nder to maintain neighbor lists. To see how the number of rings K scales with n, note that we need πr 2 K = πr 2 0 α 2K roughly equal to the network area n/Λ, which yields K = Θ log n/(Λr 2 0 ) = Θ (log n).\nFor 2D Brownian motion, it can be shown (details omitted) that the probability of exiting a circle of radius βr i within the timer duration T i tends to zero for large i, as long as T i grows slower than r 2 i . For T i = T 0 α γi and r i = r 0 α i , this is satisﬁed as long as γ < 2. This implies that the rate of abnormal updates tends to zero, and that the update rate U i for ring i is approximately 1/T i for i large.\nAs described in Section III-A, a position update to ring i goes on a straight line until it hits the ring, and then is multicast in the ring. The area of the ith ring (i ≥ 1) is A i = π (r i + d i ) 2 − r 2 i = πd 2 i + 2πr i d i = Θ (r i d i ) (since radius r i scales faster than thickness d i ). For ring 0 (or nearest neighbors), we have A 0 = πr 2 0 , but we can ignore this for scalability computations. From Section II-B, the number of transmissions to multicast in this area is C(A i ) = Θ |A i | /r 2 . Proceeding along the straight line takes Θ (r i /r) transmissions, which can be ignored in comparison to the preceding. Thus, the number of transmissions for an update to the ith ring is ν i = Θ(r i d i /r 2 )\nThe average rate of transmissions corresponding to updates for a typical destination node, which we term the average overhead rate, is therefore given by:\nPlugging in the scaling for r i , d i and T i , we obtain that the average overhead rate converges if and only if α 1+µ−γ < 1 (since α > 1 in order to exponentially expand the rings, 1 + µ − γ < 0 is a necessary condition). If this condition is satisﬁed, we can show that\nwhich matches the throughput available per node t A for a ﬁxed bandwidth. Notice that t U /t A = Θ Λσ 2 /W .\nWe now analyze the routing protocol to determine condi- tions that ensure correct routing with high probability. After an update is made to nodes in a ring, some of these nodes may leave the ring. When a packet being routed to the destination hits the ring, therefore, the relay nodes it sees may be ones which moved in after the currently active update was made. According to our routing protocol, when the packet meets such nodes which have estimates of the destination\u2019s location worse than its own (including not having any estimate of the destination\u2019s location), it simply continues in the direction it is going. Thus, in order for a packet to take advantage of an active update for ring i once it hits it, it sufﬁces that at least one of the nodes it meets as it is cutting through the ring has an active update corresponding to ring i. If this does not happen, we say that the packet has missed the i-th ring. The lifetime T i of normal updates must be short enough that the probability of a miss tends to zero. The worst-case scenario for missing a ring is when the packet is relayed radially across it, since it meets fewer relay nodes along the ring, and hence has a smaller probability of meeting a node with an active update. Using this, and accounting for the \u201cdissipation\u201d of updates due to node motion, we can show that the miss probability for the ith ring satisﬁes\ni → ∞, d i /r i → 0 and d i /\ni → 0. We want the right-hand side of (1) to go to −∞ to drive the probability of miss to zero, which requires that d 2 i /\nIn order to bound the route stretch, we must account for the fact that, since location updates are sent to only a subset of nodes, the source node need not have an active update for the destination. In this case, the packet travels an additional distance in a random direction until it hits a node with an active update. Our bound on route stretch must account for this additional distance. Once the packet does encounter a node with an active update, we use uncertainty-like measures to bound the route stretch provided the packet does not miss smaller indexed rings thereafter. Using these ideas, we can bound the route stretch in terms of α and β (formula omitted).\nThe protocol parameters are α > 1, 0 < β < 1, γ > 0 and 0 < µ < 1. We have shown that scalability requires that 1 + µ < γ < 2, that reliable routing requires that γ < 4µ, and that the worst-case route stretch is bounded if αβ < 1 − β.\nTo the best of our knowledge, this is the ﬁrst work that provides a provably scalable geographic routing protocol while providing guarantees on route stretch. Key to scalability is a probabilistic approach to updating a subset of nodes, and to geographic routing with imperfect information. Our emphasis here was on providing analytical insight and design criteria. However, we have developed the protocol in sufﬁcient detail (although we skip most of the detailed description here) that the approach can be veriﬁed by computer simulations. Mapping our ideas to practice require detailed protocol spec- iﬁcations at the level of packet level format and processing, and more extensive simulations for a wide variety of mobility models. In addition, while we focus on distant nodes in proving scalability, it may be possible to signiﬁcantly optimize our protocol as the distance to the destination decreases. Finally, it is interesting to note that, while we have assumed a uniform set of protocol parameters for all destination nodes to prove scalability, in practice, each potential destination can choose its parameters differently, depending on the tradeoffs between routing overhead, reliability and stretch that it desires to obtain.\nWe have had to omit many technical details due to space considerations, and refer to a technical report posted online for further details [11]."},"refs":[{"authors":[{"name":"B. Karp"},{"name":"H. T. Kung"}],"title":{"text":"GPSR: greedy perimeter stateless routing for wireless networks"}},{"authors":[{"name":"P. Gupta"},{"name":"P. Kumar"}],"title":{"text":"The capacity of wireless networks"}},{"authors":[],"title":{"text":"Critical power for asymptotic connectivity"}},{"authors":[{"name":"M. Grossglauser"},{"name":"D. N. C. Tse"}],"title":{"text":"Mobility increases the capacity of ad hoc wireless networks"}},{"authors":[{"name":"M. Grossglauser"},{"name":"M. Vetterli"}],"title":{"text":"Locating mobile nodes with EASE: learning efﬁcient routes from encounter histories alone"}},{"authors":[{"name":"H. Dubois-Ferriere"},{"name":"M. Grossglauser"},{"name":"M. Vetterli"}],"title":{"text":"Age matters: efﬁcient route discovery in mobile ad hoc networks using encounter ages"}},{"authors":[{"name":"S. Basagni"},{"name":"I. Chlamtac"},{"name":"V. R. Syrotiuk"},{"name":"B. A. Woodward"}],"title":{"text":"A distance routing effect algorithm for mobility (DREAM)"}},{"authors":[{"name":"R. Flury"},{"name":"R. Wattenhofer"}],"title":{"text":"MLS: an efﬁcient location service for mobile ad hoc networks"}},{"authors":[{"name":"I. Abraham"},{"name":"D. Dolev"},{"name":"D. Malkhi"}],"title":{"text":"LLS: a locality aware location service for mobile ad hoc networks"}},{"authors":[{"name":"P.-J. Wan"},{"name":"C.-W. Yi"},{"name":"F. Yao"},{"name":"X. Jia"}],"title":{"text":"Asymptotic critical transmission radius for greedy forward routing in wireless ad hoc networks"}},{"authors":[{"name":"D. Ramasamy"},{"name":"U. Madhow"}],"title":{"text":"Geographic Routing in Large-Scale MANETs"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569564669.pdf"},"links":[{"id":"1569566381","weight":4},{"id":"1569566385","weight":4},{"id":"1569565067","weight":4},{"id":"1569559259","weight":8},{"id":"1569566373","weight":4},{"id":"1569566765","weight":4},{"id":"1569566303","weight":4},{"id":"1569559541","weight":12},{"id":"1569566173","weight":4},{"id":"1569551763","weight":4},{"id":"1569565953","weight":4},{"id":"1569566759","weight":4},{"id":"1569566531","weight":12},{"id":"1569565833","weight":4},{"id":"1569566325","weight":4},{"id":"1569566231","weight":4},{"id":"1569566209","weight":4},{"id":"1569566649","weight":12},{"id":"1569566371","weight":4},{"id":"1569566257","weight":8},{"id":"1569563897","weight":4},{"id":"1569555879","weight":4},{"id":"1569566655","weight":4},{"id":"1569565739","weight":4},{"id":"1569560997","weight":4},{"id":"1569566387","weight":4},{"id":"1569563395","weight":4},{"id":"1569566383","weight":4},{"id":"1569565571","weight":4},{"id":"1569565885","weight":4},{"id":"1569566929","weight":4},{"id":"1569565611","weight":4},{"id":"1569566479","weight":4},{"id":"1569566129","weight":4},{"id":"1569565661","weight":4},{"id":"1569564131","weight":4},{"id":"1569566253","weight":4},{"id":"1569566691","weight":4},{"id":"1569566823","weight":4},{"id":"1569565375","weight":4},{"id":"1569566639","weight":4},{"id":"1569565041","weight":4},{"id":"1569566713","weight":4},{"id":"1569564437","weight":4},{"id":"1569566619","weight":4},{"id":"1569560235","weight":4},{"id":"1569567483","weight":4},{"id":"1569566171","weight":4},{"id":"1569566057","weight":4},{"id":"1569565561","weight":4},{"id":"1569566847","weight":4},{"id":"1569567013","weight":4},{"id":"1569566583","weight":4},{"id":"1569565337","weight":4},{"id":"1569566555","weight":4},{"id":"1569566987","weight":4},{"id":"1569564807","weight":4}],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S2.T3.4","endtime":"12:30","authors":"Dinesh Ramasamy, Upamanyu Madhow","date":"1341231000000","papertitle":"Can geographic routing scale when nodes are mobile?","starttime":"12:10","session":"S2.T3: Multi-Hop Multi-Flow Wireless Networks","room":"Stratton S. de P. Rico (202)","paperid":"1569564669"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
