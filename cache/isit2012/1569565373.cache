{"id":"1569565373","paper":{"title":{"text":"Trade-offs between Instantaneous and Total Capacity in Multi-Cell Flash Memories"},"authors":[{"name":"Eyal En Gad"},{"name":"Anxiao (Andrew) Jiang"},{"name":"Jehoshua Bruck"}],"abstr":{"text":"Abstract\u2014The limited endurance of ﬂash memories is a major design concern for enterprise storage systems. We propose a method to increase it by using relative (as opposed to ﬁxed) cell levels and by representing the information with Write Asymmetric Memory (WAM) codes. Overall, our new method enables faster writes, improved reliability as well as improved endurance by allowing multiple writes between block erasures. We study the capacity of the new WAM codes with relative levels, where the information is represented by multiset permutations induced by the charge levels, and show that it achieves the capacity of any other WAM codes with the same number of writes. Speciﬁcally, we prove that it has the potential to double the total capacity of the memory. Since capacity can be achieved only with cells that have a large number of levels, we propose a new architecture that consists of multi-cells - each an aggregation of a number of ﬂoating gate transistors."},"body":{"text":"Flash memory is the most widely-used type of non-volatile electronic memory [1]. The amount of charge stored in a ﬂash memory cell can be quantized into q 2 discrete values in order to represent up to log 2 q bits. (The cell is called a single- level cell (SLC) if q = 2, and called a multi-level cell (MLC) if q > 2). We call the q states of a cell its levels: level 0, level 1, . . ., level q − 1. The charge is quantized into the discrete levels by an appropriate set of threshold levels. The level of a cell can be increased by injecting charge into the cell, and decreased by removing charge from the cell. Flash memories have the prominent property that although it is relatively easy to increase a cell\u2019s level, it is very costly to decrease it. This follows from the fact that ﬂash-memory cells are organized as blocks, where every block has about 10 5 ∼ 10 6 cells. To decrease any cell\u2019s level, the whole block needs to be erased (which means to remove the charge from all the cells of the block) and then be reprogrammed. Block erasures not only are slow and energy consuming, but also signiﬁcantly reduce the longevity of ﬂash memories, because every block can endure only 10 4 ∼ 10 5 erasures with guaranteed quality [1]. Therefore, it is highly desirable to minimize the number of block erasures.\nWe can store log 2 q bits on a ﬂash cell with q levels. That way, each time we want to update the data on the memory, we would have to erase the whole block. We call\nthis representation method \u201cthe trivial scheme\u201d. We could also use a bit more sophisticated update schemes. For example, we could store only 1 bit in each cell, according to the parity of the level of the cell. If the cell is in level 3, for example, it stores the value 1. Using this scheme, we can update the data q − 1 times before a block erasure will be required. We call this scheme \u201cthe parity scheme\u201d. Update schemes like the parity scheme can be especially useful for enterprise applications of ﬂash memory, where the endurance of the memory becomes a major design concern. Update schemes are also known as write once memory (WOM) codes for q = 2 [6], and write asymmetric memory (WAM) codes for q > 2 [3]. In this paper we focus on the WAM model. The capacity of WAM codes was studied at [4], but no capacity achieving constructions are known.\nA main trade-off in the design of WAM codes is between the number of times we can update the memory and the amount of data the memory can store at a time. We call the amount of data stored at a time the instantaneous rate of the code. In general, the higher the instantaneous rate, the lower the number of times we can update the memory. In order to settle this trade-off, we focus on optimizing the product of these two values. In other words, we optimize the total amount of data the memory stores between two erasures. We call that number the total rate of the code. Once the total rate is optimized, we optimize the instantaneous rate under that constraint. Back to the previous examples, we remember that the trivial scheme has an instantaneous rate of log 2 q bits in each cell. Its total rate is the same, since we can only write the data once between block erasures. The parity scheme, however, has an instantaneous rate of only 1 bit per cell. Its total rate is q − 1 bits per cell, since it allows for q − 1 writes between block erasures. So the parity scheme is better according to our standards.\nIn MLC ﬂash memory, the process of writing a speciﬁc level on a cell is designed to cautiously approach the target level from below so as to avoid undesired block erasures in case of overshoots. Consequently, these attempts require many programming cycles, and they work only up to a moderate number of levels per cell. In order to avoid that problem, it was suggested to represent the data by a set of n cells, according\nto the permutation induced by the relative charge levels of the individual cells [5]. When we inject charge into a cell, we only need to make its charge level higher than that of the previous cell in the permutation, and therefore there is no risk of overshooting. Another advantage of representing data by relative levels is that the threshold levels are no longer needed. This mitigates the effects of retention in the cells (slow charge leakage). That method was called rank modulation.\nIn this paper we extend this idea and suggest to use permutations of a given multiset. That is, we still use the relative levels of the cells instead of the absolutes level, but allow multiple cells to be in the same relative level. We use multisets with the same multiplicity for all the elements. That is, the number of cells in each relative level is equal. Using multiset permutations, we still beneﬁt from all of the advantages of rank modulation. In addition, we gain more ﬂexibility, and we show in this work that this ﬂexibility could result in better performance.\nWhile the values of the cells don\u2019t need to be quantized using thresholds, we still use discrete levels for the analysis. This is to allow easy and fair analysis, and because there should still be a certain charge difference between the cells in order to limit errors. When we use a discrete model, the problem of designing update schemes with relative levels become a special case of the WAM problem. Namely, we are interested in a class of WAM codes, where the data is represented only by the multiset permutation induced by the levels of the cells. We call this class of codes: rank modulation WAM (RMWAM) codes. We deﬁne the capacity of the model as the tightest upper bound on the amount of information that can be stored on the memory over multiple writing cycles, and study the capacity of rank modulation WAM model. We show that when q is large, it can achieve the capacity of the more general WAM model for the same number of writes. Speciﬁcally, it is possible to store almost 2 bits per cell at a given time, while reusing the memory close to q times. That is twice the amount of information that is stored with the \u201cparity scheme\u201d from the example above. One caveat for that results is that in practical ﬂash memory devices, q is a moderately small number. In order to tackle this obstacle, we propose a method to achieve high values of q with the existing cell technology. The main idea is to combine several ﬂoating gate transistors into a virtual cell, which we call a multi-cell.\nThe rest of the paper is organized as following: In section II we present the notations and deﬁnitions. In section III we study the cost of updating the memory under the RMWAM model. In section IV we state and discuss the main result of the paper, the capacity of the model. Section V describes the proof of the capacity theorem, and ﬁnally, in section VI we present the proposed structure of multi-cell ﬂash memory.\nA write asymmetric memory (WAM) is a q-ary information storage medium consists of n cells. The q states of a cell are also called levels: from level 0 to level q − 1. A cell can change from level i to level j if and only if i < j. The initial\nstate of all the cells is 0. We want to reuse the WAM for T successive cycles. We only consider the following case: The encoder knows and the decoder does not know the previous state of the memory. The encoder and decoder can use arbitrary codes for every cycle, and there are no decoding errors (zero- error case). For the vectors\nx n = ( x 1 , x 2 , . . . , x n ) ∈ Z n q y n = ( y 1 , y 2 , . . . , y n ) ∈ Z n q\nWe will use the binary logarithm in the rest of the paper. The T-tuple ( R 1 , · · · , R T ) is called the rate vector of this code. The closure of the set of all rate-vectors A T is called the capacity region of the WAM. The maximum total number of information bits stored in one storage cell of the WAM during the T updating cycles is\nSince we want to use only the relative values of the cells, we use permutations of a multiset. We use a multiset of l elements (not including repetitions), where the multiplicity of each element is z. The cardinality of the multiset is thus n = lz. We denote the set of all permutations of a multiset of l elements with multiplicities z as S l,z . Let c = ( c 1 , c 2 , . . . , c n ) , with c i ∈ { 0, 1, . . . , q − 1 } be the state of an array of n ﬂash cells, each having q discrete levels. We further assume that the variables induce a multiset permutation σ = [ σ ( 1 ) , σ ( 2 ) , . . . , σ ( n )] ∈ S l,z . The multiset permutation σ is uniquely deﬁned by the constraint c i > c j for all ( i, j ) s.t. σ ( i ) > σ ( j ) , where l − 1 σ ( i ) > σ ( j ) 0. We deﬁne σ −1 such that σ −1 ( i ) is the set of all cells with relative level i.\nSince M t = M for t = 1, · · · , T, it follows that R t = R = ( 1/lz ) log M for t = 1, · · · , T. Therefore we call R\nthe instantaneous rate of the code, and RT the total rate (also known as sum rate). In addition, we deﬁne C = C T /T, and call C the instantaneous capacity of the RMWAM model, and C T its total capacity.\nTo change the multiset permutation from σ to σ , we program the cells based on their relative levels in σ , so that every cell\u2019s level increases as little as possible. Let c = ( c 1 , c 2 , . . . , c n ) denote the new cell\u2019s levels to be set. First, for each i ∈ σ −1 ( 0 ) , we set c i = c i . Then, for j = 1, 2, · · · , l − 1, and for i ∈ σ −1 ( j ) , we set\nGiven two cell states c and c , let cost ( c → c ) denote the cost of changing the cell state from c to c . We deﬁne the cost as the difference between the levels of the highest cell, before and after the update operation. Namely, if σ ( j ) = σ ( i ) = l − 1,\nIn order to calculate the cost, we need to simulate the update operation. We now present an equivalent deﬁnition of the cost, that can be calculated directly from the current multiset permutation and the multiset permutation to be written. The Lemma is a generalization of Theorem 1 from [2], and it further assumes that c i = σ ( i ) for i = 1, · · · , n.\nIn other words, the cost is the asymmetric inﬁnity metric. Proof:\nIn the base case, σ ( i ) = 0, so there is no j s.t. σ ( j ) < σ ( i ) . Therefore, c i = σ ( i ) = c i , as described in the programming process. For σ ( i ) > 0,\nWe now show an example of an update operation, and calculate the cost according to the two equivalent deﬁnitions:\nIn the following we present an expression for the capacity of the RMWAM model.\nAs a corollary of the theorem, we look at three different cases:\nz \t = 1. Therefore we can store up to 1 bit in each cell in each updating cycle. In fact, in this case, a trivial code that assign a different message index to each multiset permutation achieves the capacity.\n1 = 1. Therefore in this case we can also store up to 1 bit in each cell in each updating cycle. However, here it is not easy to design a code that archives the capacity, and that problem is still open.\nz \t = 1 × 2 = 2. So we can store up to 2 bits per cell in each updating cycle in this case. So C T = 2 ( q − l + 1 ) , and in the case of q l, C T → 2q. We notice that in that case the total capacity of the WAM model is the same [4]. That is since for WAM, C T = log ( T+q −1 q −1 ) = log ( 2q −l−1 q −1 ) → 2q , q/l → ∞. So in this case, the total capacity of the RMWAM model is the same as that of the WAM model.\nIf we want to guarantee that the cost of each update operation is no more than r, we must set M | B l,z,r ( σ )| . Otherwise, if we would like to write the message m, we cannot guarantee that there is a multiset permutation in B l,z,r ( σ ) that represents m. We let K r = 1 lm log | B l,z,r ( σ )| . By setting R K r , we cannot guarantee to write more than ( q − l + 1 ) /r times, so RT is at most ( q − l + 1 ) K r /r. In Lemma 2 we calculate B l,z,r ( σ ) in order to achieve an explicit bound on the rate. The lemma is a generalization of Theorem 2 from [2] for general z.\nProof: We use induction on l. When l = r + 1, the state- ment is trivial, and | B l,z,r ( σ )| = ( lz ) !/ ( z! ) l . Now we assume that the statement is true for l l 0 , and consider l = l 0 + 1 and l > r + 1. Let σ ∈ B l,m,r ( σ ) . According to Lemma 1, for any i ∈ σ −1 ( 0 ) , σ ( i ) ∈ { 0, 1, · · · , r } . Therefore, there are (( r + 1 ) z ) !/ ( z! ( rz ) ! ) choices to form σ −1 ( 0 ) . Let ˆσ ∈ S l −1,z be obtained from σ by setting ˆσ ( i ) = σ ( i ) − 1 for all i s.t. σ ( i ) \t r + 1 and ﬁll the lower levels of ˆσ arbitrarily with the remaining cells. In addition, let ˆσ ( i ) = σ ( i ) − 1 for all i / ∈ σ −1 ( 0 ) . Given a certain choice of σ −1 ( 0 ) , there is a one-to-one mapping between updating the levels of the remaining z ( l − 1 ) cells from σ to σ and updating the levels of those z ( l − 1 ) cells from ˆσ into ˆ σ . Therefore we have cost ( ˆσ → ˆ σ ) = cost ( σ → σ ) \t r. So we\nSince RT \t ( q − l + 1 ) K r /r, we are now interested in the behavior of K r /r. In Lemma 3 we show that K r /r is decreasing in r, and thus RT ( q − l + 1 ) K 1 .\nz − log z! + r log z! − r log z!\n( rz ) ! ( z! ) r\nIn the case of z = 1 we use the inequality ( 1 + ( 1/x )) x < e:\nz B. Direct part\nWe now show there exists a code whose rate approaches the upper bound.\nProof: Let M = | B l,z,1 ( σ )| / ( lz ) 1+ , where is a positive constant. In the following we show that there exists a ( l, z, q −\nl + 1, M ) -RMWAM code. We ﬁrst calculate R: R = ( 1/lz ) log M\nSo the instantaneous rate of such a code is asymptotically optimal. If we show that the cost is always 1, it follows that the total rate is also asymptotically optimal.\nSuppose { F m } M m=1 is a partition of S l,z , i.e., F m ∩ F m = ∅, m = m ; and ∪ M m=1 F m = S l,z . We now show that there exists a partition of S l,z , such that for any σ ∈ S l,z and any m ∈ M, there exists a vector σ ∈ F m , such that cost ( σ → σ ) = 1. We use a random coding method. With every σ ∈ S l,z , we connect a random index r σ which is uniformly distributed over the data set I = { 1, · · · , M } , and all these random indices are independent. Deﬁne\nThen { F m } M m=1 forms a random partition of S l,z . Fix m ∈ M and σ ∈ S l,z , then\nThis implies that when n = lz is sufﬁciently large, there exists a partition of S l,z such that the cost of each update is 1.\nNAND ﬂash memory is the most widely used type for general storage purpose. In NAND ﬂash, several ﬂoating gate transistors are connected in series, where we read or write only one of them at a time. We propose to replace each transistor with a multi-cell of m transistors connected in parallel, and to connect their control gates, as shown in Figure 1. That way, their current sums together in read operations, and the read precision increases by m times, allowing to store mq levels in a single multi-cell. In write operations, we write the same value to all the transistors, such that the sum of their charge levels gives us the desired total level. We suspect that the error rate would be similar to that of a traditional ﬂash cell.\nIf we store data on n transistors that form n/m multi-cells of mq levels without a WAM code, we would get a rate of R = RT = ( n/m ) log 2 ( mq ) . This is less than the n log 2 q we would get using traditional cells. However, if we use RMWAM codes, we could get a total capacity approaching 2nq both with\nmulti-cells and with traditional cells. In order to approach a total capacity of 2nq with RMWAM, the number of updates the code can take must be much greater than the number of relative levels we use. By using multi-cells, we increase T at the expense of the R, and thus approach C T faster.\nIn this paper, we studied the capacity of rank-modulation write asymmetric memory codes. A class of WAM codes, RMWAM codes can allow faster update and better protection against errors in ﬂash memories, since they don\u2019t require discrete threshold levels. We showed that the capacity of RMWAM codes approaches the capacity of WAM codes. In addition, we presented a new ﬂash cell structure (multi-cell) that can increase the number of levels in the cells.\nThis work was partially supported by an NSF grant ECCS- 0801795 and a BSF grant 2010075. The author would like to acknowledge that Qing Li from Texas A&M University derived Lemmas 1 and 2 independently."},"refs":[{"authors":[{"name":"P. Cappellett"},{"name":"C. Goll"},{"name":"P. Oliv"},{"name":"E. Zanon"}],"title":{"text":"Flash Memories"}},{"authors":[{"name":"E. En Gad"},{"name":"A. Jiang"},{"name":"J. Bruck"}],"title":{"text":"Compressed encoding for rank modulation"}},{"authors":[{"name":"A. Fiat"},{"name":"A. Shamir"}],"title":{"text":"Generalized \u201cwrite-once\u201d memories"}},{"authors":[{"name":"F.-W. Fu"},{"name":"A. J. Han Vinck"}],"title":{"text":"On the capacity of generalized write-once memory with state transitions described by an arbitrary directed acyclic graph"}},{"authors":[{"name":"A. Jiang"},{"name":"R. Mateescu"},{"name":"M. Schwartz"},{"name":"J. Bruck"}],"title":{"text":"Rank modulation for ﬂash memories"}},{"authors":[{"name":"R. L. Rivest"},{"name":"A. Shamir"}],"title":{"text":"How to reuse a \u201cwrite-once\u201d memory"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569565373.pdf"},"links":[{"id":"1569566597","weight":5},{"id":"1569559889","weight":5},{"id":"1569565775","weight":23},{"id":"1569566207","weight":5},{"id":"1569565317","weight":35},{"id":"1569555811","weight":5},{"id":"1569556713","weight":5},{"id":"1569564249","weight":41},{"id":"1569565809","weight":5},{"id":"1569566787","weight":17},{"id":"1569566015","weight":5},{"id":"1569566895","weight":5},{"id":"1569566423","weight":52},{"id":"1569558901","weight":29},{"id":"1569554881","weight":5},{"id":"1569564857","weight":5},{"id":"1569565847","weight":5},{"id":"1569565393","weight":11},{"id":"1569561123","weight":5},{"id":"1569565155","weight":5},{"id":"1569565765","weight":5},{"id":"1569557275","weight":5},{"id":"1569565385","weight":52},{"id":"1569564919","weight":5},{"id":"1569564595","weight":52},{"id":"1569566813","weight":5},{"id":"1569564861","weight":5},{"id":"1569566075","weight":11},{"id":"1569567483","weight":5},{"id":"1569564923","weight":5},{"id":"1569561713","weight":17},{"id":"1569566933","weight":5},{"id":"1569560785","weight":5}],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S6.T5.1","endtime":"11:50","authors":"Eyal En Gad, Anxiao Andrew Jiang, Jehoshua Bruck","date":"1341315000000","papertitle":"Trade-offs between Instantaneous and Total Capacity in Multi-Cell Flash Memories","starttime":"11:30","session":"S6.T5: Coding for Flash Memories","room":"Kresge Little Theatre (035)","paperid":"1569565373"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
