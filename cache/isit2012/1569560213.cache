{"id":"1569560213","paper":{"title":{"text":"Projected Subcodes of the Second Order Binary Reed-Muller Code"},"authors":[{"name":"Matthieu Legeay"},{"name":"Pierre Loidreau"}],"abstr":{"text":"Abstract\u2014In this paper we construct new subcodes of the second-order binary Reed-Muller code by using the permutation group and by projecting the code onto codes with smaller parameters. The permutation group of Reed-Muller codes is the general afﬁne group and can be decomposed into the semi-direct product of the translation group and the general linear group. The action of the translation group projects the second order Reed-Muller code onto copies of the ﬁrst order Reed-Muller code. The general linear group projects the code onto codes for which we can control the useful length and the dimension. These parameters depend on the dimension of the eigenspace of the chosen element of the general linear group for the eigenvalue 1."},"body":{"text":"Binary Reed-Muller codes are an ancient family of codes. Since their invention in 1954, many articles were dedicated to the study of their properties. They have especially efﬁcient decoding algorithms. The most efﬁcient in complexity (linear or quasi-linear) are the so-called recursive, or GMC (General- ized Multiple Concatenation) decoding algorithms,[1], [2], [3]. Although extremely fast, no algorithm of this type and none of their variants reaches the lower bound on the minimum distance decoding capability given for the BSC channel in [4] Corollary 2.\nThere exists another class of algorithms using algebraic properties of Reed-Muller codes, attempting to improve their decoding capacity, [4]. Although for second order Reed-Muller code, the best variants of the original algorithm practically correct more errors than the recursive decoding algorithms, the complexity of the decoder is quadratic in the code length rather than quasi-linear [7], [8]. The very interesting idea in the original paper is the algebraic approach that the authors use: they explicitly use a subgroup of the permutation group of Reed-Muller codes and project the r-order Reed-Muller code onto many copies of the r − 1-order Reed-Muller code. They chain this projection until ﬁrst order Reed-Muller code is reached. Then they decode in the many copies of the ﬁrst order Reed-Muller code with a minimum distance decoder. To do this projection, they deﬁne an action of the group of translations on Reed-Muller codes and use it to construct the projection. Although this algebraic approach is seducing the number of different copies of the code that they obtain by projection is not sufﬁcient enough to improve on the asymptotic performances of recursive decoding.\nIn this paper, we aim at studying the projection of second order Reed-Muller codes by using elements of the permua- tions group of the code. It not only contains the group of translations, but also the general linear group. We show that it is possible to project the second order Reed-Muller code onto many codes with smaller parameters - typically of the order of the parameters of the ﬁrst order Reed-Muller code. This many codes could then be used in the design of algebraic decoding algorithms with better performances. The reason why we chose to focus on the second order Reed-Muller code is that it is the simplest non-trivial code of the Reed-Muller codes family, that its structure is perfectly known, and also that it is an optimal code in the sense of minimum distance decoding, [6].\nIn section II, we introduce binary Reed-Muller codes as evaluation codes of boolean functions of a ﬁxed degree. We also recall some well known properties, in particular that their permutation group is exactly the general afﬁne group, which is the semi-direct product of the group of translations and the general linear group. In section III, we describe the properties of the codes obtained by the projection of the second order Reed-Muller code using elements of the permutation group. In the case of a translation, we always obtain a ﬁrst order Reed- Muller code. In the case where the permutation is an invertible linear permutation, the code that we obtain depends on the dimension of the eigenspace associated to the eigenvalue 1. We then derive bounds on the so-called projected subcodes. In Section IV we illustrate our approach with different examples.\nBinary Reed-Muller codes are among the oldest and best understood codes. They are relatively easy to decode but, except for the ﬁrst order Reed-Muller code, they are not very good codes in terms of the number of errors that it is possible to practically correct over a BSC channel. In this section, we introduce the codes as evaluation codes of boolean functions.\nThere are many ways to introduce binary Reed-Muller codes. One of them consists in using properties of boolean functions.\nDeﬁnition 1: A Boolean function f in m variables x 1 , . . . , x m is a function f :\nDeﬁnition 2: Let 0 ≤ r ≤ m, n = 2 m and let (α 1 , . . . , α n ), where α i ∈ F m 2 be some ordering of the vector space (F m 2 ) n . The r-th order binary Reed-Muller code R(r, m) is the set of all binary strings\nwhere f (x 1 , . . . , x m ) describes the set of binary multivariate polynomials of degree ≤ r.\n, d = 2 m−r ] binary linear code.\n\u2022 R(2, m) is the code of length n = 2 m given by the Boolean functions of order ≤ 2, that is all quadratic forms\nWe now identify a codeword of R(r, m) and its associated Boolean function:\nSince the second order Reed-Muller code R(2, m) is central in our study, we detail its structure. A codeword in R(2, m) is represented by the following function:\nwhere f ij , l i , a f ∈ F 2 . Since x 2 i = x i in characteristic 2, an equivalent form is:\nwhere f ii def = l i Therefore any codeword is uniquely repre- sented by the following boolean function\nwhere F = (f i,j ) i,j=1,..,m is an upper triangular binary matrix (the diagonal forming the linear part) and a f is a constant. The number of bits involved in F being m(m + 1)/2, we have the correct dimension.\nLet C be a binary linear code of length n. Let σ ∈ S n be a permutation of the set {1, . . . , n}. The per- mutation σ acts on vectors of F n 2 as follows: if c = (c i ) i∈{1,...,n} is a vector of F n 2 then\nGenerally speaking, the permutation group of a code without any particular structure is trivial. Instead, the permutation group of Reed-Muller codes is known and is far from being trivial, [5]. Namely, let A be the following transformation:\nwhere G = (g i,j ) i,j∈{1,...,m} is a non-singular m × m binary matrix and α = (α (i) ) i∈{1,...,m} ∈ F m 2 . We deﬁne the following action of A on the set of Boolean functions:\nThis action does not increase the degree: if f is a Boolean function of degree r, A · f has degree ≤ r. The set of all transformations A, with the composition operation forms the group GA m (F 2 ). This groups is clearly a subgroup of the permutation group of R(r, m). The converse is trickier to show.\nA transformation A in GA m (F 2 ) can be decomposed into two parts:\n\u2022 Second, x = (x 1 , . . . , x m ) is mapped to x + α = (x 1 + α (1) , . . . , x m + α (m) ).\nTherefore GA m (F 2 ) can be decomposed into the semi- direct product T GL m (F 2 ), where\n\u2022 GL m (F 2 ) is the group of all non-singular binary matrices of size m × m with coefﬁcients in F 2 . The cardinality of GL m (F 2 ) is equal to\nThe group operation ◦ is deﬁned by: let (α, G), (α , G ) ∈ T GL m (F 2 ), then\nThe permutation group of Reed-Muller codes has therefore cardinality n\nAs shown in previous section, the permutation group of the second order Reed-Muller code R(2, m) is GA m (F 2 ) = T GL m (F 2 ), where T is the group of all translations T α of the element α ∈ F m 2 , and where and GL m (F 2 ) is the group of all invertible matrices of size m × m with coefﬁcients in F 2 .\nThe action of the group T is clearly described in [4]. In the ﬁrst part we recall its main properties and in the second part forming the heart of the paper we describe how the action of GL m (F 2 ) the second order Reed-Muller code can produce subcodes with smaller parameters.\nEvery element T α of T is a permutation of order 2, with orbits of size 2. We show how to use this group to project R(2, m), on a subcode which is in fact isomorphic to R(1, m − 1).\nRecall from previous section that for α ∈ F m 2 , the action of T α on a codeword f is given by\nT α · f (x) = f (T α (x)) = f (x + α). Given α ∈ F m 2 , we write\nProposition 1: The set (Id + T α ) · R(2, m) is a subcode of R(2, m) and is isomorphic to R(1, m − 1).\nThus the function characterizing the codeword f + T α · f is an afﬁne function. Moreover, the obtained codeword is formed by two copies of the same codeword of length 2 m−1 . Namely,\nThis means that f + T α · f takes always the same values on the positions x and x + α. Therefore we can divide the set of positions by two without loosing information. It is the reason why we conclude that (Id + T α ) · R(2, m) is isomorphic to R(1, m − 1).\nThis is also the reason why we say that we project the second-order Reed-Muller code on copies of the ﬁrst order Reed-Muller codes. All these copies are isomorphic. We now explicit the isomorphism: suppose that a codeword of length n is written under the form\nwhere α i runs through F m 2 for i = 1, . . . , n. The codeword (Id + T α ) · f corresponds to:\nSince any position in the codeword is symmetric in α if we keep only one element per orbit in F m 2 /(α), we get a codeword of R(1, m − 1).\nAs we now understand perfectly how the group of transla- tions T can project second order Reed-Muller codes, we show in next section how to copy the previous construction by using elements of GL m (F 2 ) rather than translations.\nWe show that if the permutations are carefully chosen, we obtain new codes of smaller parameters by projection. As usual, the action of an element G ∈ GL m (F 2 ) on a codeword is deﬁned by\nProposition 2: Given G ∈ GL m (F 2 ), the set (Id + G) · R(2, m) is a subcode of R(2, m).\nProof: Since ∀f ∈ R(2, m) we have G · f ∈ R(2, m) this implies\nSecond, let f 1 , f 2 ∈ R(2, m). It is straightforward to verify that\nFrom now on, our motivations are to study properties of this subcode. They clearly depend on the choice of the element G in the permutation group. From the deﬁnition of the second order Reed-Muller code and from the representation (1) we can explicit the structure of the codewords of (Id + G) · R(2, m):\n(f + G · f )(x) = x t F x + a f + (Gx) t F (Gx) + a f = x t F x + x t G t F Gx = x t (F + G t F G)x\nIf we ﬁx G ∈ GL m (F 2 ), and if M m (F 2 ) denotes the vector space of m × m binary matrices then the mapping\nis linear. However studying its properties in the general case is difﬁcult. Namely, a codeword f corresponds a unique uppertriangular matrix F . However the transformation P G does not keep upper-triangularity. An upper-triangular matrix is transformed into a matrix which is not necessarily upper- triangular. However the size of P G (M m (F 2 )) is an upper bound on the size of (Id+G)·R(2, m). Since under this form obtaining a bound on the size of P G (M m (F 2 )) is difﬁcult, we chose to rewrite the matrix G under the particular form G = Id + E. Now we have:\n(f + G · f )(x) = x t (F + (Id + E) t F (Id + E))x = x t (E t F + F E + E t F E)x\nThe idea is now to study, for a ﬁxed E ∈ M m (F 2 ), the mapping\nLet r be the rank of E. We have the following upper bound on the dimension of (Id + G) · R(2, m):\nProposition 3: The dimension k of the subcode (Id + G) · R(2, m) satisﬁes\nMoreover (Id+G)·R(2, m) is isomorphic to a code of length n − 2 m−r\nBy construction, the number of codewords in (Id + G) · R(2, m) is upper bounded by the number of m × m binary matrices of the form E t F + F E + E t F E. This quantity is itself upper-bounded by the number of matrices of rank ≤ 2r. Therefore, the size of (Id + G) · R(2, m) is upper-bounded by the number of binary matrices of size m × m and of rank ≤ 2r.\nFrom [9] for instance, it is well known that the number of binary matrices of size m × n and of rank r is equal to\nNow, we show that there are coordinates in the code which are always equal to 0. Let α ∈ F m 2 , be such that Gα = α, that is α is a ﬁxed point of G or equivalently α is in the kernel of E. In this case (f + G · f )(α) = 0, for all f . The number of coordinates on which every codeword is equal zero is at least equal to the size of the kernel of E, that is 2 m−r . We can remove all these positions equal to 0 and obtain an isomorphic subcode of dimension k and of length n = n − 2 m−r .\n\u2022 If r = 1, then k ≤ 4(m − 1) + 1, for a length of 2 m−1 . \u2022 If r = 2, then k ≤ 8(m − 2) + 1, for a length of 2 m −\nThe bound show that if one ﬁxes the rank of E, then the dimension of the projected subcodes cannot grow faster than linearly in the number of variables. Therefore we come close to construct codes which are similar to ﬁrst order Reed-Muller code, and which could be minimum distance decoded in linear time.\nThe bound remains interesting if it does not exceed the dimension of the second order Reed-Muller code, that is if\nBy solving this equation, we ﬁnd that the bound gives a smaller dimension than the dimension of RM(2, m) if:\n2 4\nDeﬁnition 4: Let G = Id + E ∈ GL m (F 2 ), and let r = Rk(E). The subcode of length n − 2 r obtained from (Id + G) · R(2, m) by removing the 2 r positions equal to 0 corresponding to the kernel of E is called G-projected subcode of R(2, m).\nWe now improve the bound (2) by constructing explicitly matrices E. We choose to consider E under the under trian- gular form with zero diagonal:\n   \n0 \t 0 · · · 0 e 1 \t 0 · · · 0\n   \nwhere e i is a binary vector of length i. This construction implies in particular that G = Id + E((e 1 , . . . , e m−1 ) is non- singular. Written under this form, the matricial product\n(m − i) bits where r is the rank of E. Our improvement on bound (2) is:\nThis bound is always less than the dimension of RM(2, m). To illustrate this property, suppose that we take\nE(0, . . . , 0, e m ), where e m = (e m,j ) m−1 j=1 = 0. Then E has rank 1 and if we deﬁne F = (f i,j ) upper triangular, and if we deﬁne e m,m = 0, we have\n(F E + E t F + E t F E) i,j = e m,j (f i,m + e m,i f m,m ), (3) ∀i, j ∈ [1, . . . , m]. This quantity depends on the m bits (f 1,m , . . . , f m,m ). Hence the dimension k ≤ m. Moreover, since the eigenspace with eigenvalue 1 has dimension m − 1, the corresponding G-projected subcode has length 2 m−1 and dimension ≤ m.\nWe made some simulations in the Magma language. These simulations are presented in the next section. In practice the bound is never reached. For the case where E(0, . . . , 0, e m ), where e m = (0, . . . , 0, 1), we have\nThis means that on the positions where x 1 = 0, the subcode is equal to 0 and on the positions where x 1 = 1, the subcode corresponds to the ﬁrst-order Reed-Muller code R(1, m − 2) (doubled because it is the same for x m = 0 and x m = 1). Therefore its dimension k = m − 1. If we do the same\nfor every matrix E(e 1 , . . . , e m−1 ) of rank 1, we see that the corresponding projected subcdoes are always isomorphic to R(1, m − 2).\nFor ranks higher than 1, it is difﬁcult to ﬁnd a general structure in the matrix which would allow to prove that the dimension does not reach the bound.\nThe ﬁnal parameter of the G-projected codes that we would like to study are their minimal distance. Since they are isomorphic to subcodes of RM(2, m) we have a lower bound which is 2 m−2 . In our simulations, we always found d = d = 2 m−2 but so far we have been unable to proove it.\nTo illustrate our results we made some simulations in the Magma language whose results are presented below.\nLet α = (1, 0, 1, 0, 1). Then (Id + T α ) · R(2, 5) is a [32, 5, 16] subcode. However, on the ﬁrst 16 coordinates of its generator matrix, we have the submatrix\n    \n1 0 0 1 0 1 1 0 0 1 1 0 1 0 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1\n    \nwhich is exactly a generator matrix of the ﬁrst-order Reed- Muller code R(1, 4) ;\n    \n1 0 0 1 0 1 1 0 0 1 1 0 1 0 0 1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1 1 1 1 1 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1\n    \nwhich is the same matrix as above but permuted with (1, 6)(2, 5)(3, 8)(4, 7)(9, 14)(10, 13)(11, 16)(12, 15). Thus the permutation of the global matrix is\n\u2022 α 1 = (1, 0, 0, 0, 0) ↔ σ 1 = (1, 2)(3, 4) . . . (31, 32) \u2022 α 3 = (0, 0, 1, 0, 0) ↔ σ 3 = (1, 5)(2, 6) . . . (28, 32)\nIt is easy to verify that α = α 1 + α 3 + α 5 and so that σ = σ 1 ◦ σ 3 ◦ σ 5 .\nB. Example for the general linear group Let\n    \n1 0 0 0 0 g 1 1 0 0 0 0 g 2 1 0 0 0 0 g 3 1 0 0 0 0 g 4 1\n    \n\u2022 G 1 is the matrix G with g 1 = 1 and g 2 = g 3 = g 4 = 0. Then (Id + G 1 ) · R(2, 5) is a [32, 4, 8] subcode, isomor- phic to the ﬁrst-order Reed-Muller code R(1, 3)\n  \n1 0 0 1 0 1 1 0 0 1 0 1 0 1 0 1 0 0 1 1 0 0 1 1 0 0 0 0 1 1 1 1\n  \nby deleting the columns as said in the previous section. In this case, the subcode became a [8,4,4] code.\n\u2022 G 2 is the matrix G with g 1 = g 2 = 1 and g 3 = g 4 = 0. Then (Id + G 2 ) · R(2, 5) is a [32, 8, 8] subcode. We have k = 2m − 2 ≤ 2m − 1.\n\u2022 G 1 is the matrix G with g 1 = g 2 = g 3 = 1 and g 4 = 0. Then (Id+G 3 )·R(2, 5) is a [32, 10, 8] subcode. We have k = 3m − 5 ≤ 3m − 3.\n\u2022 G 1 is the matrix G with g 1 = g 2 = g 3 = g 4 = 1. Then (Id + G 4 ) · R(2, 5) is a [32, 12, 8] subcode. We have k = 4m − 8 ≤ 4m − 6.\nWe have constructed numerous codes from the second order Reed-Muller code by projecting the code under the action of an element of the general linear group. We have obtained a bound on the dimension of the projected codes, and in some cases we were able to tighten it."},"refs":[{"authors":[{"name":"G. Schnab"},{"name":"M. Bosser"}],"title":{"text":"Soft Decision Decoding of Reed-Muller Codes as Generalized Multiple Concatenated Codes, IEEE Transactions on Information Theory , 41(1):304-308, 1995"}},{"authors":[{"name":"I. Dume"}],"title":{"text":"Recursive Decoding and its performance for low-rate Reed- Muller codes, IEEE Transactions on Information Theory, 50(5):811-822, 2004"}},{"authors":[{"name":"I. Dume"},{"name":"K. Shabuno"}],"title":{"text":"Recursive error construction for general Reed-Muller codes, Discrete Applied Mathematics, 154:253-269, 2006"}},{"authors":[{"name":"V. M. Sidel\u2019niko"},{"name":"A. S. Pershako"}],"title":{"text":"Decoding Reed-Muller codes with a large number of errors, Problems of Information Transmission, 28(3):80-94, 1992"}},{"authors":[{"name":"F. J. MacWilliam"},{"name":"N. J. Sloan"}],"title":{"text":"The theory of error-correcting codes, 3nd edition Amsterdam, The Nederlands : North-Holland, 2009"}},{"authors":[{"name":"T. Helleset"},{"name":"T. Klov"},{"name":"V. I. Levenshtei"}],"title":{"text":"Error-Correction Capability of Binary Linear Codes, IEEE Transactions on Information Theory, 51(4):1408-1423, 2005"}},{"authors":[{"name":"P. Loidrea"},{"name":"B. Sakkou"}],"title":{"text":"Modiﬁed version of the Sidel\u2019nikov- Pershakov decoding algorithm for binary second order Reed-Muller codes, Algebraic and Combinatorial Theory - ACCT-9, pp 266-271, Kranevo, June 2004"}},{"authors":[{"name":"B. Sakkou"}],"title":{"text":"Decoding of Second Order Reed-Muller Codes with a Large Number of Errors, In ITW 2005,pp 176-179, Rotoua, New Zealand, 2005"}},{"authors":[{"name":"R. Lid"},{"name":"H. Niederreite"}],"title":{"text":"Finite Fields, Cambridge University Press, 2nd edition, 1997"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569560213.pdf"},"links":[],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S2.T5.1","endtime":"11:50","authors":"Matthieu Legeay, Pierre Loidreau","date":"1341228600000","papertitle":"Projected Subcodes of the second order binary Reed-Muller Code","starttime":"11:30","session":"S2.T5: Reed-Muller Codes","room":"Kresge Little Theatre (035)","paperid":"1569560213"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
