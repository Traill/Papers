{"id":"1569564353","paper":{"title":{"text":"Efﬁcient Algorithms for Calculating Euclidean Distance Spectra of Muliti-User Continuous Phase Modulation Systems"},"authors":[{"name":"Li Bing"},{"name":"Tor Aulin"},{"name":"Baoming Bai"}],"abstr":{"text":"Abstract\u2014The performance of maximum likelihood detection of a coded modulation scheme over an additive white Gaussian noise channel can be predicted precisely by its Euclidean distance spectrum. In this paper, three algorithms are developed to generate the Euclidean distance spectra. The ﬁrst algorithm is an exhaustive tree-search algorithm which is simpliﬁed by exploiting the correspondence between a code tree and the trellis. This algorithm is then modiﬁed to incorporate the A* algorithm and results in two heuristic algorithms. Moreover, the technique of trellis minimization is further developed for the multi user case and employed to reduce the complexity and memory requirements. Numerical results conﬁrm that the proposed algorithms can generate the distance spectra of all systems with lower complexity relative to previous methods and are particularly suited for multi user CPM systems."},"body":{"text":"Continuous Phase Modulation (CPM) is a class of modula- tion schemes, which is widely used in wireless communication systems due to its good power-efﬁciency and bandwidth- efﬁciency [1].\nIt is generally recognized that the performance of max- imum likelihood (ML) detection of a modulation scheme over the additive white Gaussian noise (AWGN) channel can be predicted by its Euclidean distance spectrum (EDS) [6]. Existing algorithms mainly focus on deriving closed-form expression [5], [6], [7] of EDS using transfer matrix or transfer diagram. However, as the number of encoder states becomes high, the calculations quickly become cumbersome even using some newly developed techniques [10], [11]. On the other hand, instead of generating closed-form expression, numerical algorithms are designed to calculate the EDS using exhaustive search for a given length of observation. Unfortunately, a considerable amount of memory is required to enumerate and identify the error events being examined [8].\nIn this paper, three algorithms are proposed to calculate the EDS for multi-user CPM (MUCPM) systems. The ﬁrst algorithm is an exhaustive tree-search algorithm which is sim- pliﬁed by exploiting the correspondence between a code tree and the trellis. This algorithm is then modiﬁed to incorporate the A* algorithm [12] and results in two simpliﬁed heuristic\nalgorithms. Moreover, the concept of trellis minimization [11] is generalized to the MUCPM systems and employed by the proposed algorithms to reduce the search effort.\nThis paper is organized as follows. Section II presents the systems model. Section III describes the algorithms and the technique of trellis minimization. Numerical results and performance comparison are given in Section IV. Sections V concludes the paper.\nShown in Figure 1 is an MSK-based multiple-access type MUCPM system proposed in [9], which consists of K users\nsharing a common channel. The kth user maps independently its information sequence a k to a CPM signal waveform s k (t), which reads\nwhere T k = T , E k , q k (t) and h are the symbol duration, average signal energy, phase response and modulation index\nof the CPM employed by the kth user, respectively. Different users are distinguished by the frequency difference f k and phase difference ϕ k deﬁned as [9]\nwhere f and ϕ are the predetermined frequency spacing and phase spacing, respectively. The resulting superimposed signal is\nwith the deﬁnitions presented above, the normalized Euclidean distance (NED) [1], [2] reads\nwhere E b is the average energy possessed by a transmitted bit, and N is the length of observation. All deﬁnitions presented above degenerate to single-user CPM (SUCPM) when K = 1.\nProposed algorithms and the technique of generalized trellis minimization are presented in this section.\nDue to the nonlinearity of CPM, the reduced-pair trellis [9] is adopted in this paper. Assuming that all users employ the same CPM scheme of memory length L M , the state σ n during interval [nT, (n + 1)T ] is a [(2K − 1) + 2K(L M − 1)]−tuple vector deﬁned as\nσ n = [U n , V n ] \t (6) where\nV n = [v 1 , ˆ v 1 , v 2 , ˆ v 2 , . . . , v K , ˆ v K ] \t (8) and\nv k = a n −L+1 k \t , a n −L+2 2 \t , . . . , a n k , k ∈ {1, 2, . . . , K} (9) where θ 1k is the difference phase state [3] between user 1 and user k. U n and V n are deﬁned as phase state and correlative state , respectively. The branch connecting a pair of states (σ n i , σ n j ) is labeled by the branch gain\n[I 1 , I 2 , . . . , I K ] is a dummy vector indicating the occurrence of symbol errors, L indicates the length of the error event and D carries incremental distance d 2 in exponent.\nTTSA is a simpliﬁed tree search algorithm using forward and backward processes to enumerate and identify the ﬁrst error events [6]. The forward process traverses the code tree and ﬁnds the forward partial error path/event originating from a correct state and ending with a node corresponding to an incorrect state, while the backward process ﬁnds the backward partial error paths/events connecting incorrect states and correct states. The multiplicity, input weight and distance of forward and backward partial error event are denoted\nA f , I f , d 2 f and A b , I b , d 2 b , respectively. Since each node in the code tree corresponds uniquely to a state, a complete error event of distance d 2 f + d 2 b is identiﬁed and formed by merging the forward and backward partial events.\nWe emphasize that TTSA is not a bi-directional algo- rithm [8] in the sense that the backward process is terminated as soon as it ﬁnds the merging path(s) for each incorrect state. The merging path of an incorrect state is deﬁned as the path connecting the incorrect state and a correct state when backward traverse visits the incorrect state the ﬁrst time. Since the branch gain depends on time index n due to the nonzero\nfrequency spacing (see (4)), TTSA restarts an iteration from step 2. Otherwise, the labels are constant and the backward process is performed only once and the algorithm restarts from step 3. TTSA is designed to deal with the ﬁrst error events, but can be modiﬁed to handle multiple error events if required.\nOn the other hand, we noticed that in most cases, including uncoded and coded systems [2], [3], [4], the truncated distance spectrum (TDS) are proven to be sufﬁcient to evaluate the error performance. This implies that instead of an exhaustive search, it is sufﬁcient to enumerate those error events which contribute to the pre-required TDS. Based on this idea the following two algorithms are proposed.\nParallel updated TTSA (PTTSA) and serially updated TTSA (STTSA) are two simpliﬁed algorithms combing TTSA and the well known A* algorithm [12]. Similar to TTSA, both PTTSA and STTSA utilize forward and backward processes to complete the error events. The backward distance d 2 b is used as the admissible heuristic [12] to ﬁnd the eligible error events. A list is used to enumerate the candidate paths and updated each time the forward process is ﬁnished. The main difference lies in the method upon which the list is updated. PTTSA ﬁrst extends all paths on the list, then replaces the list by a new one with newly generated eligible paths. Thus the paths on this list have the same length. While STTSA ﬁrst extends the ﬁrst path on the list whose distance is the smallest, then inserts all the newly generated paths to the list and removes the ﬁrst path from the list. Consequently, STTSA needs to compare paths of different lengths. This trivial difference incurs two consequences. First, STTSA performs the sorting more frequently than PTTSA does. Second, STTSA needs to store and identify the paths being examined to prevent recalculations of the same error event. It should be noted that the algorithms impose no constraint on the size of the list such that all eligible error events are enumerated.\nObviously, PTTSA is a preferable option provided they gen- erate the same results. The details of these two algorithms are presented in the Appendix. We will compare their performance in Section IV.\nThe concept of trellis minimization based on equivalent states was thoroughly explained in [11]. In this paper, this idea is further developed to handle the parallel transitions by deﬁning the equivalent branches and equivalent nodes.\nDeﬁnition 1. Two states connecting a pair of equivalent states are considered equivalent if the ingoing and outgoing branches are labeled with the same parameter {r, I, D}\nDeﬁnition 2. Two branches connecting a pair of states are considered equivalent if they are labeled with the same pa- rameter {r, I, D}\nDeﬁnition 3. Two nodes in a code tree are equivalent if they labeled with the same parameter and correspond to the same state.\nThe deﬁnitions of equivalent branches and equivalent states are illustrated by (a) MSK and (b) binary CPFSK with h= 2/3, respectively. Apparently, the technique of trellis and tree minimization is actually another description of Mason\u2019s rule [5]. By using this technique, an equivalent trellis/tree is formed in the sense that it generates the same DS as the original one, but the number of transitions is reduced to a great extent. Trellis and tree minimization are incorporated into the proposed algorithms and performed iteratively each step forward such that the complexity and memory requirements are reduced as much as possible.\nThe operations of the proposed algorithms include add, multiply and sort. The complexity and memory requirements of the proposed algorithm are mainly determined by the sorting algorithm. Assuming the maximum size of the list is N max and the sorting is performed m times, then the complexity and memory requirements of the sorting algorithm, i.e. quick sort , are approximately O (m · N max log N max ) and O(N 2 max ) [13], respectively. Obviously, the computational complexity and memory requirements of the proposed algorithms are lower than the algorithm in [8]. Unfortunately, it is impos- sible to make analytical comparison with existing simpliﬁed algorithms [8], [10], [11] due to the unpredictable size of the list. For a trellis whose labels are independent of the time index n, PTTSA, STTSA and existing algorithms are able to generate the required DS. However, if the labels are dependent on n, which is usually the case for MUCPM, the algorithms based on state reduction [10], [11] may not be applicable.\nIn this section we calculate the DS of some CPM systems, including SUCPMs and MUCPMs, shown in Table I. The resolution of the numerical results produced by these algo- rithms is restricted to 10 −3 . The analytical results are given by transfer functions. The maximum used Euclidean distance is d 2 min = 40 in SUCPM systems, and the maximum number of spectral lines for MUCPM is N T = 50. For MUCPM systems, it is assumed that the average signal energy is the same for different users.\nIt can be observed that for both SUCPMs, all three algo- rithms generate the same result as the transfer function does. However, PTTSA has the lowest complexity among them as we pointed out before. We use PTTSA and TTSA to generate\nobserved that the size of the list for TTSA approaches inﬁnity with increasing N , while the size of the list for PTTSA and STTSA is a fraction of TTSA.\nThis paper has presented three algorithms and a technique of generalized trellis minimization to facilitate the calculation of the distance spectra of CPM systems. Analysis and numerical results conﬁrm that all algorithms can generate the pre- required spectrum as the transfer function does, while the computational effort is reduced signiﬁcantly.\nThis work was supported in part by the 973 Program of China under Grant 2012CB316100, the NSFC under Grant 60972046, and the National S &T Major Special Projects (No.2010ZX03003-003-03)."},"refs":[{"authors":[{"name":"T. Aulin"},{"name":"N. Rydbeck"},{"name":"C. E. Sundberg"}],"title":{"text":"Continuous Phase Modula- tion I, II"}},{"authors":[{"name":"P. Moqvist"},{"name":"T. M. Aulin"}],"title":{"text":"Serially concatenated continuous phase modulation with iterative decoding"}},{"authors":[],"title":{"text":"Symbol error probability bounds for coherently Viterbi detected continuous phase modulation"}},{"authors":[{"name":"M. Xiao"},{"name":"T. M. Aulin"}],"title":{"text":"Serially concatenated continuous phase modulation with convolutional codes over rings"}},{"authors":[{"name":"S. Li"},{"name":"D. J. Costello Jr"}],"title":{"text":"Error Control Coding: Fundamentals and Applications "}},{"authors":[{"name":"A. J. Viterb"},{"name":"J. K. Omur"}],"title":{"text":"Principles of Digital Communication and Coding "}},{"authors":[{"name":"R. McEliece"}],"title":{"text":"How to Compute Weight Enumerators for Convolutional Codes"}},{"authors":[{"name":"M. Rouanne"},{"name":"D. J. Costello"}],"title":{"text":"An algorithm for computing the distance spectrum of trellis codes"}},{"authors":[{"name":"P. Moqvist"}],"title":{"text":"Multiuser serially concatenated continuous phase mod- ulation"}},{"authors":[{"name":"C. Pimentel"}],"title":{"text":"On the computation of weight enumerators for convolu- tional codes"}},{"authors":[],"title":{"text":"Efﬁcient Computation of Trellis Code Generating Functions"}},{"authors":[{"name":"N. J. Principles of Artiﬁcial Intelligence"}],"title":{"text":"Nilsson,  Palo Alto, California: Tioga Publishing Company"}},{"authors":[{"name":"T. H. Corme"},{"name":"C. E. Leiserso"},{"name":"R. L. Rives"},{"name":"C. Stein: Introduction to Algorithms "}],"title":{"text":"Edition, The MIT Press"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569564353.pdf"},"links":[],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S13.T7.4","endtime":"16:00","authors":"Li Bing, Tor M. Aulin, Bao-Ming Bai","date":"1341502800000","papertitle":"Efficient Algorithms for Calculating Euclidean Distance Spectra of Muliti-User Continuous Phase Modulation Systems","starttime":"15:40","session":"S13.T7: Communication Systems","room":"Stratton (407)","paperid":"1569564353"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
