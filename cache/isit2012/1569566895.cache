{"id":"1569566895","paper":{"title":{"text":"Regenerating Codes for Errors and Erasures in Distributed Storage"},"authors":[{"name":"K. V. Rashmi"},{"name":"Nihar B. Shah"},{"name":"Kannan Ramchandran"},{"name":"Fellow"},{"name":"IEEE"},{"name":"P. Vijay Kumar"},{"name":"Fellow"},{"name":"IEEE"}],"abstr":{"text":"Abstract\u2014Regenerating codes are a class of codes proposed for providing reliability of data and efﬁcient repair of failed nodes in distributed storage systems. In this paper, we address the fundamental problem of handling errors and erasures during the data-reconstruction and node-repair operations. We provide explicit regenerating codes that are resilient to errors and erasures, and show that these codes are optimal with respect to storage and bandwidth requirements. As a special case, we also establish the capacity of a class of distributed storage systems in the presence of malicious adversaries. While our code constructions are based on previously constructed Product- Matrix codes, we also provide necessary and sufﬁcient conditions for introducing resilience in any regenerating code."},"body":{"text":"Distributed storage systems play a vital role in today\u2019s age of big data. For cost considerations, these storage systems often employ commodity hardware, which makes failures a norm rather than an exception. In order to safeguard the precious data against such failures, the data is typically stored in a redundant manner. In this paper, we consider a distributed storage system consisting of n storage nodes in a network, each having a capacity to store α symbols over a ﬁnite ﬁeld F q . Data comprising B symbols (the message) is to be stored across these n nodes. An end-user (called a data collector) must be able to reconstruct the entire message by downloading the data stored in any k of these n nodes. It follows that such a system can tolerate failure of any (n − k) nodes, and under solely this requirement, can be realised using any [n, k] maximum distance separable (MDS) code.\nFrequent node failures also call for efﬁcient handling of the failure events. When a storage node fails, it is replaced by a new, empty node. This replacement node is required to obtain the data that was stored previously in the failed node, by downloading data from the remaining nodes in the network. We will term this process as repair or regeneration of a node. A typical means of accomplishing this is to download the entire message from the network, and extract the desired data from it. However, downloading the entire message, when it eventually stores only a fraction 1 k of it, is clearly wasteful of the network resources.\n\u2018Regenerating codes\u2019 [1] are a class of codes that aim to reduce the amount of download during repair, while retaining the storage efﬁciency of traditional MDS codes. Under the\nα α α α α\nα α α α α  \nβ   β  \nα   α  \nα α α α α\nα α α α α  \nβ   β  \nα   α  \nFig. 1: An example of the system parameters under a regen- erating code (in the absence of errors/erasures). The system comprises of n = 5 storage nodes: (a) reconstruction is accomplished from any k = 2 nodes, (b) repair from any d = 3 nodes.\noperation of a regenerating code, a replacement node connects to any d (≥ k) existing nodes (termed helper nodes), and downloads β symbols from each. This setting is illustrated in Fig. 1. With regenerating codes, the total amount of data dβ downloaded for repair is much smaller than the total size of the message B. It is shown in [1] that the parameters associated with a regenerating code must necessarily satisfy\nA regenerating code is said to be optimal if it satisﬁes this bound with equality. Since both storage and bandwidth come at a cost, it is naturally desirable to minimize both α as well as β. However, it can be deduced (see [1]) that achieving equality in (1), for ﬁxed values of B and [n, k, d], leads to a tradeoff between the storage space α and the amount of download for repair dβ. The two extreme points in this tradeoff are termed the minimum storage regenerating (MSR) and minimum bandwidth regenerating (MBR) points. These points have been well studied in the literature, and several explicit constructions of codes operating at these points are available [2]\u2013[8]. It has also been shown in [8] that essentially all other points on the tradeoff curve are not achievable.\nIn this paper, we address the problem of handling errors and erasures in distributed storage networks using regenerating codes. In particular, we are interested in codes that can perform reconstruction and efﬁcient repair in the presence of errors and erasures at the nodes or in the links. Such codes are clearly useful in handling errors and packet losses occurring in the network. In addition, such codes can also be used to provide security in distributed storage systems, where malicious adversaries may corrupt the data stored in some nodes in the system.\nThe aspect of security in distributed storage systems em- ploying regenerating codes is studied in [9], where an outer bound is provided for the total amount of data that can be stored securely in the presence of malicious adversaries. The model presented in [9] considers correction of a ﬁxed num- ber of errors, by designing encoding and storage algorithms speciﬁcally for this purpose. It is also shown that the code in [8] achieves this bound with an appropriate choice of the underlying MDS code, for the case d = n − 1 at the MBR point. However, apart from this case, no other constructions of secure regenerating codes are known in the literature.\nIn the present paper, we provide a new approach for handling errors and erasures in regenerating codes. Under our system model, the data is encoded and stored assuming no error/erasure-resiliency requirements. The task of correcting the errors or erasures is performed in the decoding stage by downloading a larger amount of data. In contrast to [9], our approach allows for choosing a different level of resiliency during each event of repair or reconstruction, depending on the prevalent network state. A second advantage of our approach is that it allows for introducing resilience in regenerating codes that were not designed for handling errors and erasures.\nWe present explicit code constructions for the parameters (i) MSR, all [n, k, d ≥ 2k − 2] and (ii) MBR, all [n, k, d]. In addition, we show the optimality of these codes through tight outer bounds on the storage and bandwidth requirements. This establishes the capacity of such systems for these parameters. Moreover, this also establishes the capacity of regenerating codes in the presence of malicious adversaries for these param- eters, which had remained open. The decoding algorithms have a (polynomial) complexity, identical to that of Reed-Solomon codes. The codes presented here are based on a \u2018Product- Matrix\u2019 construction introduced in [2], that also possess other appealing properties such as linearity, scalability, and ease of implementation. An example of an MSR error/erasure-resilient code is depicted in Fig. 2.\nA natural question that follows is whether any regenerating code can be made resilient to errors and erasures in this fash- ion. In this paper, we also answer this question by providing necessary and sufﬁcient conditions for a regenerating code to be resilient to errors and erasures. It turns out that, to date, the product-matrix codes are the only codes that satisfy these properties.\nWhile we were writing this paper, we came across a contemporaneous independent work [10] that is related to the present paper, and deals with byzantine fault tolerance using product-matrix codes of [2]. The authors use a CRC to check the integrity of data during repair and reconstruction, and a feedback scheme to iteratively correct them. However, CRC based schemes are not applicable in settings such as protection against malicious adversaries, since the CRC can also be corrupted by the adversary. The present paper takes a more fundamental look at the problem of handling errors and erasures in regenerating codes.\nThe rest of the paper is organized as follows. The system model is described in Section II, and outer bounds for this model are also provided in this section. Explicit constructions of error-resilient regenerating codes are provided in Section III. Necessary and sufﬁcient conditions for providing error and erasure resiliency in any regenerating code are presented in Section IV.\nWe consider a block-based model where the message is divided into blocks, and there is no coding across the blocks. All operations of encoding, decoding and repair are performed independently across the blocks. Thus the regenerating code parameters (for the error-free case) described in Section I can be considered as pertaining to a single block of data. More concretely, we consider a block to consist of B message symbols, and the storage capacity in each of the n nodes to be α symbols per block. One can reconstruct the B-message symbols by downloading the data pertaining to this block from any subset of k nodes, and regenerate the data stored in any node by downloading β symbols each (pertaining to this block) from any d nodes.\nWe assume that the granularity of any error or erasure is one block. In other words, we assume that during repair, all the β symbols passed by a helper node suffer the same fate: either all these β symbols are erased, or all are in error, or all are perfectly received. Similarly, during reconstruction, all the α symbols passed by a node are assumed to suffer the same fate.\nThe assumption of block errors/erasures can accurately model several scenarios of interest, two of which are described here. Consider handling of packet drops during transmission across a network. The size of a packet during reconstruction\nβ   β   β   β  \nα   α   α  \nα α α α α\nα α α α α  \nβ   β   β   β  \nα   α   α  \nα α α α α\nα α α α α  \nFig. 3: The system setting for an (s = 1, t = 0)-resilient regenerating code with k = 2 and d = 3. Here, connectivity during (a) reconstruction is κ = k + 1 = 3, and (b) repair is ∆ = d + 1 = 3.\nand repair can be assumed to be a multiple of α and β (since the packet size will usually be much larger than these parameters). Thus, when a packet is delayed or dropped, all the α or β symbols corresponding to a block are erased. In the security scenario, to account for compromise of any node or link to a malicious adversary, one needs to protect against corruption of the entire data on that node or link. Thus, we can model the security scenario in our framework by simply considering the entire data as a single block.\nWe note that the absence of this assumption will allow arbitrarily scattered errors and erasures in the model. It can be shown that codes attempting to guard against such scat- tered errors/erasures require signiﬁcantly larger overheads. As discussed above, many applications can be modelled as having block errors, thus avoiding these overheads.\nWe now deﬁne formally, the error/erasure handling capabil- ity of a regenerating code.\nDeﬁnition 1 (( s, t)-resilient code): A regenerating code is (s, t)-resilient if it can correct upto s erasures and t errors during repair as well as reconstruction.\nAs discussed previously, under our system model, errors and erasures are corrected by downloading additional data during reconstruction or repair. One way to obtain additional data is to connect to a larger number of nodes, and we choose this approach. More precisely, we allow a connectivity of ∆ (≥ d) nodes during repair and κ (≥ k) nodes during reconstruction. The parameters ∆ and κ depend on the error/erasure correcting capability expected out of the system. Fig. 3 depicts the (1, 0)- resilient version of the system in Fig. 1.\nWe now provide an outer bound on the capacity of resilient regenerating codes. The bound is obtained by adapting the outer bound of [9] (for the omniscient adversary case) to our system model, and extending it to handle erasures as well.\nTheorem 1: A (s, t)-resilient regenerating code, connecting to ∆ and κ nodes for repair and reconstruction respectively, must satisfy\nProof (sketch): The bound can be derived either using cut-set arguments in an information ﬂow graph as in [1], [9] or using information theoretic arguments as in [8]. The complete\nWe will call an (s, t)-resilient regenerating code as optimal if it meets the bound in Theorem 1. Clearly, for (s, t)- resilience, we need\nwhere (3a) represents the connectivity required during repair, and (3b) during reconstruction.\nIn many applications of interest, it may be desired to provide different levels of reliability during different instances of reconstruction and repair. For instance, under changing network states in the packet erasure setting, or varying threat levels under the security setting. We deﬁne codes that possess such a property as universally resilient codes.\nDeﬁnition 2 (Universally resilient code): A regenerating code is universally resilient if it is simultaneously (s, t)- resilient for all s and t satisfying (3).\nThus a universally resilient code can correct upto s erasures and t errors by downloading β (or α) symbols each from s+2t additional nodes during repair (or reconstruction), as long as d + s + 2t ≤ n − 1 (or k + s + 2t ≤ n).\nIn the next section, we present constructions of product- matrix codes that are universally resilient and optimal. Before moving on to the constructions, we brieﬂy digress to explore some connections with network coding.\nRelation to Network Coding: The regenerating codes prob- lem described above, if relaxed to the requirement of repair of only the systematic nodes, turns out to be a non-multicast network coding problem (see [12, Section I-C]). While the occurrence of errors and erasures in multicast network coding are well studied in the literature [13]\u2013[15], the results of the present paper lead to a class of non-multicast networks for which the error/erasure capacity of the network can be achieved by codes that are linear, deterministic and explicit.\nWe provide explicit constructions of universally resilient MSR and MBR codes for\nwhich meet the outer bound provided in Theorem 1. Thus, this also establishes the capacity of such a system for these parameter values. These codes are based on product-matrix (PM) codes that were introduced in [2].\nAs discussed in Section II, in our approach, the encoding algorithm is identical to the error/erasure free case. Hence, we ﬁrst brieﬂy describe the product-matrix code construction for the error/erasure free case [2], which meets the bound in (1). We then present the decoding algorithms (for both repair and reconstruction) that can handle s erasures and t errors for all values of s and t satisfying (3), with ∆ = (d + s + 2t) and κ = (k + s + 2t). These parameters satisfy the bound in Theorem 1 with equality, thereby establishing the optimality of these codes.\nWe begin with the minimum storage case, and subsequently present the minimum bandwidth case. The example depicted in Fig. 2 is an optimal, universally resilient MSR code.\nMSR codes use the minimum possible storage at each node. Since the data from any k nodes should sufﬁce to reconstruct all the B message symbols, each node must necessarily store at-least a fraction 1 k of the entire data. Hence for an MSR code we have α = B k . To meet the bound (1) with equality (in absence of errors/erasures), an MSR code must satisfy\nIn this section we present explicit constructions of optimal, universally resilient MSR codes for all parameter values [n, k, d ≥ 2k − 2]. The code is designed for the case d = 2k − 2, which can be extended to any d > 2k − 2 via the shortening technique for MSR codes provided in [2], [4]. When d = 2k − 2, from (4), we get\nSince both α and B are multiples of β, we obtain the optimal code for the desired parameters (B, α, β) by ﬁrst constructing an optimal code for\nThe PM-MSR code in [2] can be described in terms of an (n × α ) code matrix C = ΨM , with the i th row of C containing the α symbols stored in node i. The (n × d) encoding matrix Ψ is of the form Ψ = [Φ ΛΦ], where Φ is an (n × α ) matrix and Λ is an (n × n) diagonal matrix satisfying: (a) any α rows of Φ are linearly independent, (b) any d rows of Ψ are linearly independent, and (c) the diagonal elements of Λ are all distinct. The choice of the matrix Ψ governs the choice of the ﬁnite ﬁeld F q , e.g., choosing Ψ as Vandermonde (carefully chosen to satisfy condition (c)) permits any q ≥ 4n. The ((d = 2α ) × α ) message matrix M is of the form M = [S 1 S 2 ] t , where S 1 and S 2 are (α × α ) symmetric matrices. The superscript t is used to denote the transpose of a vector or matrix. The two symmetric matrices S 1 and S 2 together contain α (α +1) distinct elements, which are populated by the B = α (α + 1) message symbols. This completes the description of the encoding algorithm. 1\nThe following theorems show that this code is optimally universally resilient during repair and reconstruction.\nTheorem 1 (MSR Repair): In the MSR code presented, the α symbols stored in any node can be recovered by download- ing β symbols each from any ∆ = d + s + 2t nodes, in the presence of upto s (block) erasures and t (block) errors.\nProof: Since we consider only block errors and erasures, it sufﬁces to describe the repair algorithm for the code with β = 1, and the same algorithm is applied in parallel to obtain the repair algorithm for the desired code. Consider failure of node f in the system, and let φ t f λ f φ t f be the row of Ψ corresponding to the failed node. Thus the α symbols stored in node f are\nThe replacement for the failed node f connects to an arbitrary set {h j | j = 1, . . . , ∆} of ∆ nodes. To facilitate repair of node f , node h j computes the inner product ψ t h\nM φ f and passes on this value to the replacement node. Letting m f = M φ f , we can write the symbol passed by node h j as ψ t h\nm f . Thus the ∆ symbols obtained at the destination are Ψ rep m f , where\nSince any d rows of Ψ are linearly independent by construc- tion, and since Ψ rep comprises a subset of the rows of Ψ, Ψ rep m f is simply an MDS encoding of the d symbols in the vector m f . It follows that this code has a minimum distance of (∆ − d + 1) = (s + 2t + 1) which allows us to recover m f using standard decoding algorithms [16] in the presence of upto s erasures and t errors. Thus the replacement node now has access to\nSince S 1 and S 2 are symmetric matrices, the replacement node has access to φ t f S 1 and φ t f S 2 . Using this it can obtain φ t f S 1 + λ f φ t f S 2 , which is precisely the data previously stored in node f .\nTheorem 2 (MSR Reconstruction): In the MSR code pre- sented, a data-collector can reconstruct all the B message symbols by downloading data stored in any κ = k + s + 2t nodes in the presence of upto s (block) erasures and t (block) errors.\nProof (sketch): The data reconstruction property of the code in the error-free case, as shown in [2], implies that the data passed by the κ nodes are MDS over the ﬁnite ﬁeld F α q . Over this ﬁnite ﬁeld, the message is of size k, and the mini- mum distance of this MDS code is (κ − k + 1) = (s + 2t + 1). This guarantees reconstruction of the k source symbols over F α q , and equivalently the kα = B source symbols over F q , in the presence of upto s erasures and t errors.\nMBR codes achieve minimum possible download during repair: a replacement node downloads only what it stores, resulting in dβ = α. To meet the bound (1) with equality (in absence of errors/erasures) an MBR code must satisfy\nIn this section we present explicit constructions of optimal, universally resilient MBR codes for all parameter values [n, k, d]. As in the MSR case, B and α are multiples of β, and we ﬁrst construct codes for\nThe desired code can be obtained by concatenating β copies of this code.\nThe PM-MBR code in [2] has a similar form, C = Ψ M , as the PM-MSR code. The MBR code has the (n × d) encoding matrix Ψ of the form Ψ = [Φ Σ], where Φ is an (n × k) matrix satisfying: (a) any k rows of Φ are linearly independent, (b) any d rows of Ψ are linearly independent. For instance, one can choose Ψ to be a Vandermonde matrix. The (d × d) message matrix M is symmetric and consists of the B\nHere, the ((d − k) × k) matrix T and the (k × k) symmetric matrix S contain the B = kd − k 2 = k(d − k) + k(k+1) 2 message symbols as their elements.\nThe following theorems show that this code is optimally universally resilient during repair and reconstruction.\nTheorem 3 (MBR Repair): In the MBR code presented, the α symbols stored in any node can be recovered by download- ing β symbols each from any ∆ = (d + s + 2t) nodes, in the presence of upto s (block) erasures and t (block) errors.\nProof: As in the case of MSR, it is sufﬁcient to describe the repair algorithm for the code with β = 1. Consider failure of node f in the system, and let ψ t f be the row of Ψ corresponding to the failed node. Thus the α symbols stored in node f are ψ t f M . We will follow the notation as in Theorem 1. The helper node h j passes the symbol ψ t h\nM ψ f . Denoting m f = M ψ f , the ∆ symbols obtained at the destination can be written as Ψ rep m f where\nBy construction, Ψ rep m f corresponds to an MDS encoding of the vector m f . As in the case of MSR, this code has minimum distance of (∆−d+1) = (s+2t+1) which allows us to recover m f in the presence of upto s erasures and t errors. Since the message matrix M is symmetric, m t f = ψ t f M t = ψ t f M is precisely the set of α symbols required.\nTheorem 4 (MBR Reconstruction): In the MBR code pre- sented, a data-collector can reconstruct all the B message symbols by downloading data stored in any κ = (k + s + 2t) nodes in the presence of upto s (block) erasures and t (block) errors.\nProof (sketch): As in the MSR case, the proof exploits the reconstruction property of PM-MBR codes in the error-free case [2]. The reconstruction property implies that, over F α q , the minimum distance of the code is (κ − k + 1) = (s + 2t + 1). This guarantees reconstruction of the k symbols over F α q , and equivalently the B source symbols over F q , in the presence of upto s erasures and t errors.\nThe conversion of the product-matrix codes into universally resilient codes, as described in Section III, raises a natural question as to whether any regenerating code can be made universally resilient in a similar manner. We answer this question by providing a necessary and sufﬁcient condition for\nthe same. To the best of our knowledge, the only codes today that satisfy this condition are the product-matrix codes.\nTheorem 5: An [n, k, d] regenerating code can be made universally resilient if and only if the following condition holds: during any instance of repair, the data passed by a node h helping in the repair, to the failed node f , depends only on h and f , and not on the identities of the other nodes helping in this repair.\nRemark 1: Clearly, since the number of nodes contacted during repair must satisfy (d + s + 2t) ≤ (n − 1), the requirement of having either s > 0 or t > 0 requires that n > (d + 1). Thus the code should not restrict the number of nodes n to be (d − 1).\nThe only explicit regenerating codes that support n > (d+1) are the high-rate \u2018approximately-exact\u2019 MSR codes of [3] and the product-matrix codes [2]. However, the MSR codes of [3] do not satisfy the condition provided in Theorem 5. As shown in Section III, the product-matrix codes satisfy this condition.\nThe authors would like to thank Salim El Rouayheb and Sameer Pawar for fruitful discussions."},"refs":[{"authors":[{"name":"A. G. Dimakis"},{"name":"P. B. Godfrey"},{"name":"Y. Wu"},{"name":"M. Wainwright"},{"name":"K. Ramchan- dran"}],"title":{"text":"Network coding for distributed storage systems"}},{"authors":[{"name":"K. V. Rashmi"},{"name":"N. B. Shah"},{"name":"P. V. Kumar"}],"title":{"text":"Optimal exact-regenerating codes for the MSR and MBR points via a product-matrix construction"}},{"authors":[{"name":"K. V. Rashmi"},{"name":"N. B. Shah"},{"name":"P. V. Kumar"},{"name":"K. Ramchandran"}],"title":{"text":"Explicit construction of optimal exact regenerating codes for distributed storage"}},{"authors":[{"name":"N. B. Shah"},{"name":"K. V. Rashmi"},{"name":"P. V. Kumar"},{"name":"K. Ramchandran"}],"title":{"text":"Explicit codes minimizing repair bandwidth for distributed storage"}},{"authors":[{"name":"C. Suh"},{"name":"K. Ramchandran"}],"title":{"text":"Exact regeneration codes for distributed storage repair using interference alignment"}},{"authors":[{"name":"I. Tamo"},{"name":"Z. Wang"},{"name":"J. Bruck"}],"title":{"text":"MDS array codes with optimal rebuilding"}},{"authors":[{"name":"D. Papailiopoulos"},{"name":"A. Dimakis"},{"name":"V. Cadambe"}],"title":{"text":"Repair optimal erasure codes through hadamard designs"}},{"authors":[{"name":"N. B. Shah"},{"name":"K. V. Rashmi"},{"name":"P. V. Kumar"},{"name":"K. Ramchandran"}],"title":{"text":"Dis- tributed storage codes with repair-by-transfer and non-achievability of interior points on the storage-bandwidth tradeoff"}},{"authors":[{"name":"S. Pawar"},{"name":"S. El Rouayheb"},{"name":"K. Ramchandran"}],"title":{"text":"Securing dynamic dis- tributed storage systems against eavesdropping and adversarial attacks"}},{"authors":[{"name":"Y. Han"},{"name":"R. Zheng"},{"name":"W. Mow"}],"title":{"text":"Exact regenerating codes for byzantine fault tolerance in distributed storage"}},{"authors":[{"name":"K. V. Rashmi"},{"name":"N. B. Shah"},{"name":"K. Ramchandran"},{"name":"P. V. Kumar"}],"title":{"text":"Uncon- ditionally secure storage-bandwidth optimal distributed storage codes"}},{"authors":[{"name":"N. B. Shah"},{"name":"K. V. Rashmi"},{"name":"P. V. Kumar"},{"name":"K. Ramchandran"}],"title":{"text":"Interfer- ence alignment in regenerating codes for distributed storage: Necessity and code constructions"}},{"authors":[{"name":"N. Cai"},{"name":"R. Yeung"}],"title":{"text":"Network error correction, ii: Lower bounds"}},{"authors":[{"name":"S. Jaggi"},{"name":"M. Langberg"},{"name":"S. Katti"},{"name":"T. Ho"},{"name":"D. Katabi"},{"name":"M. M´edard"}],"title":{"text":"Resilient network coding in the presence of byzantine adversaries"}},{"authors":[{"name":"R. Koetter"},{"name":"F. Kschischang"}],"title":{"text":"Coding for errors and erasures in random network coding"}},{"authors":[{"name":"F. MacWilliam"},{"name":"N. Sloan"}],"title":{"text":"The Theory of Error-Correcting Codes, Part I "}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569566895.pdf"},"links":[],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S7.T5.5","endtime":"16:20","authors":"K. v. Rashmi, Nihar B Shah, Kannan Ramchandran, P Vijay Kumar","date":"1341331200000","papertitle":"Regenerating Codes for Errors and Erasures in Distributed Storage","starttime":"16:00","session":"S7.T5: Regenerating Codes","room":"Kresge Little Theatre (035)","paperid":"1569566895"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
