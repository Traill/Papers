{"id":"1569565493","paper":{"title":{"text":"Graph Cover Ensembles of Non-binary Protograph LDPC Codes"},"authors":[{"name":"Dariush Divsalar"},{"name":"Lara Dolecek"}],"abstr":{"text":"Abstract\u2014This paper introduces a novel class of non-binary graph-based codes, built upon graph covers of non-binary proto- graph LDPC codes. This new ensemble is more restrictive than previously considered constructions, but in turn is much simpler to design and implement. The simpliﬁcations in design allow for the enumeration of codeword weight, trapping set size, stopping set size, and pseudo codeword weights, both as exact quantities in the ﬁnite-length regime and as corresponding growth rates in the asymptotic setting. The presented construction and the accompanying enumerations enhance the analytical toolbox of non-binary LDPC codes."},"body":{"text":"Graph-based codes can be divided into two categories: codes where each coded symbol is represented by a single bit (binary codes), and codes where each coded symbol is represented by , > 1 bits (non-binary codes). While Davey and MacKay [2] recognized early on that non-binary low density parity check (LDPC) codes can outperform binary LDPC codes, a considerable amount of subsequent research effort was devoted to studying binary LPDC codes. With these early promising results, the interest in non-binary LDPC codes is being renewed.\nWeight enumerator (WE) of a given linear code succinctly captures the number of codewords of a given weight. Since it is usually impractical to compute the WE of a given code, ensemble-wide properties are commonly established. In addition to characterizing codeword WE of a given ensemble, it is also of interest to evaluate the WE of non-codeword objects known to dominate the performance of iteratively decoded LDPC codes. Recent work [6], for example, has already considered weight distributions of certain unstructured non-binary LDPC codes. In our recent work [4], [5], we studied a class of structured non-binary LDPC codes built out of protographs with random edge scaling and derived various enumerators of this code family.\nIn contrast to the binary setting, there is a considerable freedom in generalizing a code construction to the non-binary domain. For example, each edge in the Tanner graph of a given non-binary LDPC code can, in principle, be weighted by any\nnon-zero element of the underlying ﬁeld. In designing irregular non-binary LDPC codes, Davey and MacKay [2], Declercq et al. [3], and Poulliat et al. [8], Liva et al. [9] suggested that instead of randomly assigning the non-zero elements of the ﬁeld to the edges in the Tanner graph, it is in fact better to carefully select the scaling to ensure good minimum distance properties. These observations motivate us to introduce, for the ﬁrst time, a novel class of protograph-based non-binary LDPC codes constructed from a graph cover, and having ﬁxed edge scalings. This new class of codes called the graph cover non- binary protograph based (GC-NBP) codes . These codes are a natural extension of the binary protograph-based codes [10] to the non-binary case. Due to ﬁxed edge scalings, this code family is more practical and easier to implement than a code where the scalings are randomly selected.\nThe goal of this paper is to ﬁrst present a novel class of structured non-binary LDPC codes, where in contrast to existing works (see e.g., [4], [5]), the edges are selectively rather than randomly scaled. We then establish various weight enumerators of this code family. In Section II we describe the construction of non-binary LDPC codes based on graph covers of protographs, and quickly summarize background concepts. In Section III we provide the exact codeword weight enumeration and the codeword pairwise enumeration of GC- NBP codes using combinatorial arguments. The latter result is novel and is important for high-order modulations where the assumption on the all-zero transmitted codeword does not hold, e.g., in pulse amplitude modulation (PAM). In Section IV the growth rate of the enumerator in the asymptotic regime is derived. Equipped with novel combinatorial deﬁnitions, Section V then discusses the enumerators of trapping, stop- ping sets and pseudocodewords. In Section VI an example is provided. Section VII concludes the paper. Some of the enumeration machinery used in deriving the presented results is built upon the previous works [1], [4]; yet it is important to note that the end results of the simpliﬁed constructions are considerably different than in the random edge scaling case, since no weight averaging takes place.\nThe goal of this section is to describe graph cover non- binary protograph (GC-NBP) LDPC codes (simply referred by\nA. GC-NBP Codes, Their Ensembles, and Relevant Combina- torial Objects\nGC-NBP codes are built from a constituent small bipartite graph, known as the protograph. We extend the original deﬁ- nition of a protograph [10] and associated code ensembles to include the edge weightings. Let us assume that a protograph G = (V,C,E,S) consists of the set V = {v 1 ,v 2 ,. . . ,v n v } of variable nodes (VNs), the set C = {c 1 ,c 2 ,. . . ,c n c } of constraint nodes (CNs), the set E = e 1 ,e 2 ,. . . ,e |E| of edges connecting VNs and CNs, and the set S = s 1 ,s 2 ,. . . ,s |S|\nof scales (weights) with one-to-one association with the edges namely s i ∈ S is associated with e i ∈ E, |S| = |E|, and s i = 0 ∈ GF (q). Parallel edges between a VN and a CN are allowed.\nWhen a graph G = (V, C, E, S) is copied N times, each variable node v i ∈ V (each constraint node c i ∈ C) expands into the set V i of variable nodes {v i,1 , . . . , v i,N } (the set C i of constraint nodes {c i,1 , . . . , c i,N }) in the resultant graph G N . Likewise, each edge e i ∈ E with its associated scale s i expands into the set E i of edges in G N . Note that the elements of E i , E i = {e i,1 , . . . , e i,N }, each have the same scale s i ∈ S as e i ∈ E, and the edge e i,j for 1 ≤ j ≤ N connects the variable node v k,j and the constraint node c l,j if the edge e i connects the variable node v k and the constraint node c l with the same scale s i ∈ S in the original protograph G. We let G N = (V N , C N , E N , S N ) denote the resultant daughter graph.\nDeﬁnition 1 (GC-NBP code): Given the mother proto- graph G = (V, C, E, S), a (G, N, {s k } k , {π i } i ) GC-NBP\ncode is constructed from the daughter graph G N = (V N , C N , E N , S N ) by N times copying G = (V, C, E, S) and then permuting the edges in the set E i according to π i for each 1 ≤ i ≤ |E|.\nThis process is illustrated in Figure 1 for the construction of a GC-NBP code based on the mother protograph with n v = 3, n c = 2, and N = 3.\nWe call this code a graph cover (GC)-NBP code since the construction is reminiscent of the graph cover analysis of graph-based codes [7].\nThe deﬁnition of the GC-NBP ensemble then follows in the usual sense.\nDeﬁnition 2 (GC-NBP code ensemble): The (G, N, q) GC- NBP ensemble is the collection of all (G, N, {π i } i ) GC-NBP codes with the given choices of s i ∈ S as non-zero elements of GF (q) (for 1 ≤ i ≤ |E|) and {π i }\u2019s as all possible N - permutations (for 1 ≤ i ≤ |E|).\nB. Frequency weight matrix of a non-binary protograph code In this section we describe the frequency weight matrix\narising from N replications of the underlying protograph G. Recall that a degree-N graph cover of G is a Tanner graph G (N ) that results from replicating N times each node of G, followed by introducing edges in a way that the local adjacency is preserved among the replicated nodes [7]. This operation is in fact reminiscent of our GC-NBP construction. Note that in the GC-NBP case, the edge weights of the underlying graph are preserved in its graph cover, whereas the edge weights range over all possible non-zero values when constructing the PB NB ensemble in [4].\nWith \t the \t graph-cover \t viewpoint, \t it \t is convenient to consider a codeword ˆ x N \t = (x 1,1 · · · x 1,N , x 2,1 · · · x 2,N , · · · , x n v ,1 · · · x n v ,N ) as an N -cover codeword of C (N ) , the code generated by G (N ) .\nWe tabulate the number of occurrences of non-zero symbols from GF (q) in ˆ x N via the (q − 1) × n v matrix d = d(ˆ x N ), called the degree-N frequency weight matrix. In this matrix, the entry d( , i) is the number of occurrences of symbol\nin positions x i,k , 1 ≤ k ≤ N , in ˆ x N , computed for each between 1 and q − 1, and each i between 1 and n v . Note\nthat the number of occurrences of zero-symbol in GF (q) need not be listed explicitly as it follows by subtracting the total count of non-zero elements of GF (q) from N for each i. The frequency weight matrix d can be viewed as a concatenation of column vectors ∂ i = [d i,1 d i,2 . . . d i,(q−1) ] T , each of length (q − 1) that indicate the number of times each non-zero symbol occurs in a particular code coordinate corresponding to the variable node v i in the non-binary protograph. We call these (q − 1) dimensional vectors the protograph variable node frequency weight vectors . As a shorthand, we write d = [∂ 1 , ∂ 2 , · · · , ∂ n v ].\nAnalogous to the deﬁnition of ∂ i for the variable node v i , it is also useful to introduce the protograph constraint node frequency weight matrix d j = [∂ j 1 ∂ j 2 . . . ∂ j mj ] for the constraint node c j in G with degree m j . This frequency weight matrix is a (q − 1) × m j submatrix of d = [∂ 1 , ∂ 2 , · · · , ∂ n v ]\npreviously deﬁned for n v variable nodes in G, whose columns are now precisely the m j columns of d corresponding to j 1 , · · · , j m j variable nodes that are the neighbors of the constraint node c j .\nThe relative effect that each codeword has on the overall performance is a function of its frequency weight matrix, that itself depends on the channel/modulation choice. The Hamming weight of a non-binary code is\nrepresents the square Euclidean distance of non-binary code- word with respect to the all zero codeword where l 0 is a PAM level assigned to the zero symbol.\nWe round up the section with the following deﬁnition of the frequency uniform interleaver. The frequency uniform interleaver decouples the frequency weight enumeration of component codes. Note that the symbol interleaver based on Hamming weight [4] does not represent a frequency uniform interleaver since the edge weights are a priori ﬁxed. Let C (N ; n 1 , n 2 , . . . , n K ) = \t N ! n\ndenote the multinomial coefﬁcient.\nDeﬁnition 3 (Frequency uniform interleaver): A length-N frequency uniform interleaver is a probabilistic device that maps each input of length N with entries as non-zero symbols of GF (q) and with the frequency weight vec- tor [d 1 , d 2 , · · · , d q−1 ] (each d t denotes the number of occurrences of the t-th symbol in the input) into the C(N ; d 0 , d 1 , . . . , d (q−1) ) distinct output sequences of length N . Here d 0 = N − i>0 d i . These outputs have the same frequency weight vector as the input, and they are chosen equiprobably.\nWhen q = 2, the frequency uniform interleaver is the same as the binary uniform interleaver.\nIn this section we derive the codeword weight enumerator of the GC-NBP ensemble. In Subsection III-A we ﬁrst derive the weight enumerator of a code induced by N replications of a given constraint node. In Subsection III-B we leverage the result from Subsection III-A to derive the GC-NBP ensemble codeword WE. We also provide pairwise weight enumerators in Section III-C.\nA. Weight enumerator of a constraint node and of its replicas Consider a degree-m j constraint node c j in protograph\nG deﬁned over GF (q), and suppose that the scalings on the edges incident to c j are given by the vector s j =\n(s j,1 , s j,2 , . . . s j,m j ), where s j,i \u2019s are non-zero elements of GF (q) for i = 1, 2, . . . , m j . Since the edge weights are a priori chosen by construction, we view the node c j with speciﬁed s j as a (m j , m j − 1) single parity check, linear code C j over GF (q).\nFor convenience, we partially borrow the following notation from [4]: We let K j = q (m j −1) be the total number of codewords in C j . Further, we let M C j be the K j × m j matrix with the codewords of C j as its rows.\nConsider a 1 × m j codeword x ∈ C j . Let the map- ping ϕ(x) be deﬁned as the symbol indicator, ϕ(x) = [x 1,1 . . . x 1,(q−1) , x 2,1 . . . x 2,(q−1) , . . . , x m j ,1 . . . x m j ,(q−1) ], where x i = 1, if the i-th component of x is equal to a non- binary symbol with index , otherwise x i = 0, for ranging over all (q − 1) non-zero symbols in GF (q). We collect the indicators ϕ(x) for all x as matrix rows of a K j × m j (q − 1) binary matrix. This matrix is referred to as M C j b .\nWe now consider the N copies of the constraint node c j in G N . Let the resultant (N m j , N (m j − 1)) linear block code be denoted as C N j .\nwhere the constraint frequency weight matrix d j is deﬁned with respect to the constraint node c j . This enumerator is computed according to the following Theorem.\nTheorem 1: The frequency weight matrix enumerator A C N j (d j ) of C N j is given by,\nwhere C N ; n 1 , n 2 , . . . , n K j is the multinomial coefﬁ- cient and {n} is the set of integer-vector solutions to d j = n · M C j b , with n 1 , n 2 , . . . , n K j ≥ 0, and K j k=1 n k = N , and n k the number of occurrences of the k th codeword among these N copies of c j .\nProof: The proof is based on constructing a multi- dimensional generating function {A C N (d j )} and extracting appropriate coefﬁcients from this generating function using a multinomial theorem. The function itself is derived from the generating function of the underlying code C j (induced by the constraint node c j , and associated scale vector s j ), multiplied N times. Since the proof uses known techniques previously discussed in [1], details are omitted.\nNote that the result in Theorem 1 for a GC-NBP code is different from the previously derived result for the PB NB codes [4], since the proposed construction treats the edge scalings as ﬁxed rather than random.\nSuppose that the original protograph G has n v variable nodes and n c constraint nodes. Let m j denotes the degree of the constraint node c j . Let t i denote the degree of the variable node v i . By construction, the GC-NBP ensemble consists of all codes obtained by performing all possible edge permutations in the derived graph G N . It is convenient to collect the frequency column vectors {∂ j 1 , ∂ j 2 , ..., ∂ j mj } of the N non-binary elements on the edges connected to\nCN c j , arising from the incident VNs {v j 1 , v j 2 , ..., v j mj }, into the protograph constraint node frequency weight matrix d j = ∂ j 1 , ∂ j 2 , ..., ∂ j mj .\nTheorem 2: Let A C N j (d j ) be the frequency weight matrix enumerator of the code C N j induced by the N copies of the constraint node c j with the associated scaling s j . Then, the frequency weight matrix enumerator of the GC-NBP ensemble is\nProof: Consider a concatenation of two codes, one in- duced by a variable node and another induced by a constraint node, connected via a frequency uniform interleaver. By collecting all the nodes, the result follows.\nNote that the result in (4) is not merely a consequence of the weight enumerator computed in [4] for the PB NB ensemble: the former assumes ﬁxed edge scalings while the latter considers all possible non-zero weightings in the edge permutations, thus incurring different combinatorial terms (in the denominator) in the expression for the weight enumerator.\nFor the given Hamming weight d H , the average number of codewords of weight d H in the GC-NBP ensemble, A d H , is then simply the sum of A(d) over all d for which\nA similar calculation can be done under the squared Eu- clidean distance with respect to the all zero codeword as deﬁned previously for PAM in (2).\nA method for determining pairwise weight enumerators for a GC-NBP LDPC code ensemble is to create a modiﬁed protograph G P from the original protograph. Each variable (constraint) node in G P can be viewed as a duplicated version of a variable (constraint) node in the original protograph G. The local adjacency is preserved among the replicated nodes. Each variable node in G P takes a pair of elements of the ﬁeld. This pair is interpreted as a new symbol in the current set up.\nList all possible pairs of codewords of the original check node matrix M C j as the matrix M C j List . The (i, k) component of the constraint matrix M C P j of the new check node in G P is the (i, k) and the (i, k+m j ) component of M C j List representing a new symbol ( , ) for k = 1, . . . , m j . The binary marix M C P j b is constructed by applying the indicator mapping ϕ to the matrix M C P j . The frequency weight vectors are deﬁned as ∂ = [d 0,0 , . . . , d (q−1),(q−1) ] T where d , counts the number of occurrences (frequency) of the symbol ( , ) within N symbols. The deﬁnition of the frequency weight matrix for protograph G P is the same as previously discussed except that now the number of symbols is q 2 rather than q.\nTheorem 3: The pairwise frequency weight matrix enumer- ator of the GC-NBP code averaged over the entire ensemble is\nwhere A C N P,j (d j ) is the frequency weight matrix enumerator of the code C N P,j induced by the N copies of the constraint node c P,j with the associated scaling s j . Here, the elements of d j comprise a subset of the elements of d = [∂ 1 , ∂ 2 , ..., ∂ n v ], and this subset (corresponds to neighbors of c P,j ) is obtained from the edge connections in the mother protograph G P . The variable node index i is added to the subscript of the entry d j,k to yield d i,j,k .\nProof: The proof follows from applying frequency uni- form interleaver to concatenations of codes induced by single variable and single constraint node in G P . Details are omitted for the lack of space.\nFor any two dimensional modulation with constellation points a( ), we can deﬁne the pairwise Euclidean distance between two codewords as\n= d ˜ A(d) is the pairwise weight enumerator where the sum ranges over all frequency weight matrix d that produce channel dependent parameter d 2 E . The computation of the enumerator can be simpliﬁed since d 2 E is invariant to the order of ( , ) and further reduced when = . Note that this result is particularly useful when the assumption on all-zeros transmission does not hold, as is the case with PAM.\nEquipped with the new weight enumerator, the asymptotic growth rate can now be derived in the usual sense (cf. [1]), either in terms of the number of protograph copies, N ,\nn \t (7) where ˜ r H (˜ δ) = 1 n\n(9) Here, (with the standard substitution, see e.g., [1]) δ =\nd/N , δ j = d j /N , δ i = d i /N , and H(·, · · · , ·) is the multi-dimensional entropy function. The term a C ∞ j (δ j ) stands for the asymptotic frequency weight matrix enumerator of the constraint node c j , and it is computed as a C ∞ j (δ j ) =\n} H(P δ j ) . The collection {P δ j } represents the set of solutions to δ j = P δ j · M C j b , with P δ j = [p 1 , p 2 , . . . , p K ], p 1 , p 2 , . . . , p K ≥ 0 and K k=1 p k = 1.\nThe WEs of GC-NBP codes in terms of the relevant codeword objects now readily follow.\nLet G q = (V q , C q , E q , S q ) be the Tanner graph of an LDPC code deﬁned over GF (q), with V q and C q denoting the variable node set, and the constraint node set, respectively, and E q and S q denoting the edge set and the associated scalings, respectively. Let us consider a T a,b trapping set (see [4] for deﬁnition). As observed in [1], [4], the trapping set enumerator can be computed by enlarging the original graph G q with an additional set W q of b variable nodes, each attached to one of the b constraint nodes in T a,b . The values of the a variable nodes constituting this T a,b trapping set are assigned non-zero values from GF (q), and all other variable nodes in G q are assigned a zero value. The values in the set W q are determined so that the overall graph R q = G q ∪ W q has all constraint nodes satisﬁed. The trapping set enumerator for G q then reduces to the codeword weight enumerator for R q .\nBased on the results from the previous section, it follows that the trapping set enumerator A a,b can be computed as\nNote that here C N j refers to the weight-vector CN enumera- tors with respect to R q . These weight-vector enumerators are readily evaluated using (3). Let the growth rate ˜ r( ˜ α, ˜ β) (in terms of n) be expressed as\nwhere ˜ α = a/n and ˜ β = b/n. The growth rate in terms of N , r(α, β), is\n{δ i :v i ∈W q } δ i \t = \t β. The asymptotic weight-vector enumerator, a c j (δ j ), can be evaluated as in [4]. Therefore, ˜ r( ˜ α, ˜ β) follows from ˜ r( ˜ α, ˜ β) = 1 n\nWe quickly remark that the analysis of the stopping set enu- meration follows the methodology in [4] for protograph-based non-binary (PB NB) LDPC codes (with random scalings). Also, the technique in [5] can be used for the pseudocodeword analysis.\nWe constructed a GC PBN code with the ﬁxed non-zero set of scalings over GF(256), as shown in Fig. 2. This protograph is lifted (via copy-permute operations) using circulant permu- tation matrices σ i (the unit left circular shift of the identity matrix represents σ) of size N × N , for N = 4, 8, 16 to generate rate-1/2 GC PBN codes with equivalent block-lengths\nin bits n = 128, 256, 512, respectively. The circulants for the shortest block of n = 128 are also shown on the edges of the base protograph. The binary image of these codes were simulated over the BI-AWGN channel. The simulation perfor- mance using 100 iterations are shown in Fig. 2 in solid lines. Performance of unconstrained PB NB codes (with random scaling) is shown with squares. These codes outperform the binary counterparts for short blocks by 1 dB. The example clearly demonstrates that performance comparable to that of unconstrained PB NB codes can be achieved by GC PBN codes. \t VII. C ONCLUSION\nIn this paper we introduced a novel class of structured non-binary LDPC codes, based on graph covers. We derived various enumerators of the proposed ensembles.\nIt is worth to mention that it may be possible to reformulate our setup in terms of normal factor graphs. If so, then the ensembles could be seen as special cases in [11] and some partial results therein seem to be relevant."},"refs":[{"authors":[{"name":"S. Abu-Surra et al."}],"title":{"text":"Enumerators for protograph-based ensembles of LDPC and generalized LDPC codes"}},{"authors":[{"name":"M. C. Davey"},{"name":"D. MacKay"}],"title":{"text":"Low-density parity-check codes over GF(q)"}},{"authors":[{"name":"D. Declercq et al."}],"title":{"text":"Performance comparison of NB-LDPC, NB-root- LDPC, and NB-DGLDPC"}},{"authors":[{"name":"D. Divsalar"},{"name":"L. Dolecek"}],"title":{"text":"Enumerators for protograph-based ensem- bles of non-binary LDPC codes"}},{"authors":[{"name":"D. Divsalar"},{"name":"L. Dolecek"}],"title":{"text":"Ensemble analysis of pseudocodewords of non-binary protograph-based LDPC codes"}},{"authors":[{"name":"K. Kasai et al."}],"title":{"text":"Weight distribution of non-binary LDPC codes"}},{"authors":[{"name":"R. Koetter"},{"name":"P. Vontobel"}],"title":{"text":"Graph-covers and iterative decoding of ﬁnite- length codes"}},{"authors":[{"name":"C. Poulliat"},{"name":"M. Fossorier"},{"name":"D. Declercq"}],"title":{"text":"Design of regular (2,d c )- LDPC codes over GF(q) using their binary images"}},{"authors":[{"name":"G. Liva"},{"name":"E. Paolini"},{"name":"S. Scalise"},{"name":"M. Chiani"}],"title":{"text":"Turbo codes based on time-variant memory-1 convolutional codes over F q "}},{"authors":[{"name":"J. Thorpe"}],"title":{"text":"Low-density parity-check (LDPC) codes constructed from protographs"}},{"authors":[{"name":"O. Vontobe"}],"title":{"text":"P"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569565493.pdf"},"links":[],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S14.T5.1","endtime":"17:00","authors":"Dariush Divsalar, Lara Dolecek","date":"1341506400000","papertitle":"Graph Cover Ensembles of Non-binary Protograph LDPC Codes","starttime":"16:40","session":"S14.T5: New Constructions of LDPC Codes","room":"Kresge Little Theatre (035)","paperid":"1569565493"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
