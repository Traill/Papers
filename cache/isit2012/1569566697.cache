{"id":"1569566697","paper":{"title":{"text":"Blind Compute-and-Forward"},"authors":[{"name":"Chen Feng"},{"name":"Danilo Silva"},{"name":"Frank R. Kschischang"}],"abstr":{"text":"Abstract\u2014Compute-and-forward (C&F) relaying usually re- quires channel state information (CSI) at the receivers so that an \u201coptimal\u201d scale factor can be computed for the purposes of decoding. In this paper, a blind C&F scheme\u2014i.e., one not requiring CSI\u2014is developed. Rather than attempting to compute the optimal scale factor, this new scheme seeks one (or more) \u201cgood\u201d scalars, i.e., scalars which allow correct decoding despite possibly being sub-optimal. The region of all such good scalars is characterized. To ﬁnd a good scalar, a computationally efﬁcient scheme, involving error-detection and a hierarchically organized list, is proposed. Simulation results show that this blind C&F scheme achieves\u2014for a class of lattices admitting an efﬁcient trellis decoder\u2014the same throughput as its CSI-enabled counterpart, at the expense of, approximately, a ten-fold increase in computational complexity in the high-throughput region."},"body":{"text":"Compute-and-forward (C&F) is a new relaying strategy pro- posed by Nazer and Gastpar [1]. It enables intermediate nodes to recover linear combinations of concurrently transmitted messages. As shown in [1], for some AWGN wireless relay networks, C&F outperforms other relaying strategies (such as compress-and-forward and decode-and-forward) in certain SNR region when channel state information (CSI) is known at the receivers. If CSI is also known at the transmitters, the performance of C&F can be greatly improved, achieving the full degrees of freedom for certain network scenarios [2].\nIn C&F, an intermediate node receives y =   h  x  + z , where h  are channel gains, and x  are points in a multidimen- sional lattice. Based on the fact that any integer combination of lattice points is again a lattice point, the intermediate node selects integer coefﬁcients a  and a scalar α, and then attempts to decode the lattice point   a  x  from the scaled signal\n(αh  − a  )x  + αz  \t  \t \nThe scalar α and integer coefﬁcients a  are carefully chosen based on channel gains h  so that the effective noise n is made (in some sense) small. Hence, the \u201coptimal\u201d scalar α and integer coefﬁcients a  depend critically on CSI.\nIn this paper, we aim to eliminate the need of CSI in C&F. We consider the case when no CSI is available, hereafter called blind C&F. This is motivated by the fact that the requirement\nof CSI (even if only at the receivers) may dominate com- munication when the number of concurrent transmissions is large, since channel training is known to effectively reduce the degrees of freedom of a wireless link [3].\nThe basic idea of our approach to blind C&F is simple. Although the optimal scalar is nearly impossible to acquire without CSI, some \u201cgood\u201d scalars (that allow correct decoding of linear combinations) can be obtained with a reasonable effort. In particular, when the lattices are asymptotically-good (in the sense of [4]), we are able to characterize the region of all such good scalars, showing that it is bounded, symmetric, and consisting of a union of disks. Based on these properties, we propose a generic blind C&F scheme that makes use of error-detection codes to ﬁnd a good scalar.\nTo control the computational complexity of our blind C&F scheme, we propose two strategies that are complementary to each other. In particular, we show that, if a blind C&F scheme admits Viterbi decoding, then its complexity can be signiﬁcantly reduced. For instance, the complexity can be made around 10 times the complexity of coherent C&F in high-throughput region, as observed from our simulation results.\nIn this section, we brieﬂy review coherent C&F, which serves as a natural benchmark for blind C&F. For ease of presentation, we focus on a single building block of coherent C&F, namely, a system of L concurrent transmitters and a single receiver.\nIn such a system, each transmitter  sends a length-n complex vector x  ∈ C n , which satisﬁes an average power constraint E  x   2  ≤ nP . The receiver observes y = \nh  x  + z , where h  ∈ C are complex-valued channel gains and z is i.i.d. circularly-symmetric complex Gaussian noise, i.e., z ∼ CN (0, N 0 I n ×n ) . The goal of the receiver is to reliably recover a linear combination of the transmitted messages based on the received signal y and the channel gains h  , which are assumed to be perfectly known at the receiver.\nNazer and Gastpar [1] proposed an effective coding scheme for the above coherent C&F system. Their scheme makes use of asymptotically-good lattice partitions constructed by Erez and Zamir [4]. Since asymptotically-good lattice partitions require very long block lengths and almost unbounded com- plexity, several practical C&F schemes have been developed (e.g., [5]\u2013[8]) to overcome this difﬁculty. Here, we present a generic coherent C&F scheme following the work of [5].\nWe ﬁrst introduce a class of complex lattices called R- lattices. Let R be a discrete subring of C forming a principle ideal domain. Typical examples include Gaussian integers Z[i] = {a + bi : a, b ∈ Z} and Eisenstein integers Z[ω] = {a + bω : a, b ∈ Z, ω = e 2πi/3 }. For any N given linearly independent basis vectors g 1 , . . . , g N in C n , the R-lattice Λ (generated by them) is deﬁned as the set of all R-linear combinations of these vectors, i.e., Λ = {  i r i g i : r i ∈ R}. We call N the rank of Λ, and n the dimension of Λ. In general, we have N ≤ n. When N = n, the lattice Λ is called a full-rank lattice. Throughout this paper, we focus on full-rank lattices.\nAn R-sublattice Λ  of Λ is a subset of Λ which is itself an R-lattice. The set of all the cosets of Λ  in Λ, denoted by Λ/Λ   {λ + Λ  : λ ∈ Λ}, forms a partition of Λ, hereafter called an R-lattice partition. Without loss of generality, we may assume that there is a one-to-one linear map between a lattice partition Λ/Λ  and a message space W (see [5] for such a construction).\nA nearest-lattice-point (NLP) decoder is a map D Λ : C n → Λ that sends a point x ∈ C n to a nearest lattice point in Euclidean distance, i.e.,\nD Λ (x)  arg min λ ∈Λ x − λ. \t (2) An element x in a coset λ + Λ  is called a coset leader if\nx ≤ y for all y ∈ λ + Λ  . With the above setup, a generic coherent C&F scheme can be described as follows.\n\u2022 Transmitter  maps its message w  in W to a coset λ  +Λ  in Λ/Λ  , and then transmits a coset leader x  for λ  +Λ  .\n\u2022 The receiver scales the received signal y by α ∈ C, decodes the scaled signal αy to a nearest lattice point D Λ (αy) in Λ, and then maps the coset D Λ (αy) + Λ  to a message ˆu in order to recover a linear combination. The recovery ˆu is said to be correct if ˆu =   a  w  for some a = (a 1 , . . . , a L ) ∈ R L \\ {0}.\nThe scaling operation at the receiver plays an important role here. To understand this role, recall that (see Eq. (1))\nwhere a  ∈ R are coefﬁcients and n =   (αh  − a  )x  + αz is the effective noise. In other words, the scaling operation induces a \u201cvirtual\u201d point-to-point channel with channel input \nNote that if the channel input is decoded correctly, i.e., D Λ (αy) =   a  x  , then a message   a  w  can be obtained from the coset D Λ (αy) + Λ  =   a  x  + Λ  by using the one-to-one linear map constructed in [5]. In fact, the recovery of   a  w  is correct if and only if D Λ (αy) ∈   a  x  + Λ  [5], which is a weaker condition than D Λ (αy) =   a  x  . Note also that the effective noise n can be \u201cminimized\u201d by choosing the scalar α and the coefﬁcient vector a cleverly. In fact, for given (α, a), the computation rate\nis achievable [1], where SNR = P/N 0 , h = (h 1 , . . . , h L ) , and log + 2 (x) = max {log 2 (x), 0 }. Moreover, the optimal (α, a) that maximizes R(α, a) can be obtained by applying Lemma 1 and Theorem 4 in [1].\nTo summarize, in order to recover a best linear combination, the receiver ﬁrst computes the optimal scalar α, then maps the coset D Λ (αy) + Λ  to a message ˆu.\nIn this section, we develop a general framework for blind C&F, leading to a generic blind C&F scheme. The basic idea of our framework is simple: although the optimal scalar is nearly impossible to acquire without CSI, some \u201cgood\u201d scalars can still be obtained by applying an error detection code. Formally, we introduce the following deﬁnitions.\na  x  + Λ  for some (a 1 , . . . , a L ) ∈ R L \\{0} and is said to be bad otherwise.\nRecall that the recovery of   a  w  is correct if and only if D Λ (αy) ∈   a  x  +Λ  . This justiﬁes the above deﬁnition.\nNote that the good region depends on the channel gains. Thus, it is unknown to the receiver. Nevertheless, it is still beneﬁcial to understand some basic properties of the good region, which will facilitate our design of blind C&F schemes. A. Properties of the good region G s\nIt turns out that the good region G s has a number of interesting properties, when the underlying lattice partitions Λ/Λ  are asymptotically good (in the sense of [4]). Moreover, these properties still hold (or approximately hold) even for practical lattice partitions.\nWhen the underlying lattice partitions are asymptotically good, Theorem 3 in [1] can be restated as: a scalar α is good if and only if the message rate R m is less than the computation rate R(α, a) (given in (3)) for some a ∈ R L \\ {0}. Based on this fact, we are able to show that the good region G s is bounded, symmetric, and consisting of a union of disks.\nProposition 1: The good region G s is bounded. Proof: If α is good, then by deﬁnition\n> R m for some a ∈ R L \\{0}. Note that\n. It follows that\nProposition 2: The good region G s is symmetric with re- spect to rotations by some angle θ. The angle θ is determined by R.\nProof: It sufﬁces to show that if α is good, so is e iθ α for some angle θ. We need the following fact in abstract algebra.\nLet R be a discrete subring of C forming a principle ideal domain. Let U be the set of all the units in R. Then U = {e 2πki/n : k = 0, 1, . . . , n − 1} for some positive integer n. That is, the units of R are also the roots of unity.\n> R m for some a ∈ R L \\{0}. Hence,\nProposition 3: The good region G s consists of a union of disks. These disks are pairwise disjoint if the message rate R m ≥ 2.\nProof: Recall that α is good if and only if R m < R(α, a) for some a ∈ R L \\ {0}, or equivalently,\nSNR αh − a 2 + |α| 2 < SNR/2 R m for some a ∈ R L \\ {0}. Note that SNRαh − a 2 + |α| 2 can be viewed as the squared distance between the vector (αh 1 √ SNR, . . . , αh L √ SNR, α) and the vector (a 1 √ SNR, . . . , a L √ SNR, 0) . Hence, we have\nRecall that SNRα ∗ h − a 2 + |α ∗ | 2 = SNR/2 R(α ∗ ,a) . There- fore, α is good if and only if\nfor some a ∈ R L \\ {0}, or equivalently, α is in some disk of centre α ∗ . This proves the ﬁrst part. The proof of the second part is omitted due to space constraints.\nFig. 1(a) and 1(b) show some typical good regions for asymptotically-good Gaussian lattice partitions (R = Z[i]) and Eisenstein lattice partitions (R = Z[ω]). Since Z[i] has four units {1, i, −1, −i} and Z[ω] has six units {ω k : k = 0, . . . , 5 }, the rotation angles in Fig. 1(a) and 1(b) are 90 ◦ and 60 ◦ , respectively.\nFig. 2 depicts a typical good region for a naive lat- tice partition Z[i] 400 /3 Z[i] 400 . This lattice partition can be viewed as uncoded 9-QAM. Since this lattice partition is not asymptotically-good (in the sense of [4]), the disjoint areas are not quite disk-like. Nevertheless, the good region is still bounded and symmetric (with respect to rotations by 90 ◦ ).\nIn Sec. III-A, we derived several properties of the good region. Here, we present a generic blind C&F scheme that aims to ﬁnd a point in the good region, which is inspired by these properties\nFirst, we discuss how these properties can be used to facilitate the search of good points. Proposition 1 suggests that, to ﬁnd a good point, it sufﬁces to consider a bounded region. Proposition 2 shows that, to ﬁnd a good point, it sufﬁces to \u201cignore\u201d some unnecessary areas. For instance, only the region in the ﬁrst quadrant is worth investigating for Gaussian lattice partitions. Proposition 3 implies that, to ﬁnd a good point, it sufﬁces to \u201cprobe\u201d a discrete set of points. The denser the points, the better the performance.\nNext, let us assume that the discrete set of points is given. We now discuss how to \u201cprobe\u201d a point by applying a linear detection code C. First, the transmitters embed a linear detection code C into the message space W so that each valid message w  (as well as any linear combinations) is a codeword in C. Second, the receiver performs a basic probing operation as described in Algorithm 1.\nIf a point α is good, then Algorithm 1 always declares α to be good, since ˆu is a codeword in this case. On the other hand, if a point α is bad, then Algorithm 1 might make a mistake by declaring α to be good, due to an undetected error. The probability of this event can be made very small, when the code C has sufﬁciently many parity-checks.\nNow we are ready to describe a generic blind C&F scheme. The input to the scheme is an ordered list containing a discrete set of points. The scheme probes the points in the list one by one until it ﬁnds a good point or until it reaches the end of\nAlgorithm 1 Basic probing operation Input: a point α.\nthe list. Thus, the output is either a (claimed) good point or nothing.\nNote that the performance of the scheme is determined by the points in the list regardless of their order, whereas the computational cost of the scheme depends on the order of these points. In other words, two ordered lists containing exactly the same points achieve the same performance with possibly quite different computational complexity (as we will see in Sec. V).\nIn this section, we propose two (complementary) strategies to control the computational complexity of the generic blind C&F scheme presented in Sec. III. The ﬁrst strategy attempts to create some \u201csmart\u201d probing lists; the second strategy aims to reduce the complexity of the basic probing operation.\nThe choice of the probing list is crucial to attaining good performance with low complexity. For instance, the probing points can be made relatively sparse when the good region consists of many large disjoint areas. Based on this observa- tion, we propose a heuristic method for creating the list.\nFirst, we choose a well-shaped region R to avoid unnec- essary probing (see discussions in Sec. III-B). For Gaussian lattice partitions, we note that R can be chosen heuristically as [0, log 10 (SNR)] × [0, log 10 (SNR)] . For example, if SNR = 10 dB, then R = [0, 1] × [0, 1].\nThen, we construct an m-level lattice-partition chain [9] L 0 / L 1 / . . . / L m in C (i.e., each L j is a one-dimensional com- plex lattice and L 0 ⊃ L 1 ⊃ · · · ⊃ L m ). Note that the lattice- partition chain, together with the region R, induces m + 1 probing grids {L j ∩R} satisfying {L m ∩R} ⊂ · · · ⊂ {L 0 ∩R} (see Fig. 3 for a concrete example). For Gaussian lattice par- titions, we heuristically set L j = 1 16 log 10 (SNR)(1 + i) j Z[i], where j = 0, . . . , 8.\nWith these grids, a list-building algorithm is described in Algorithm 2. The order in the list is designed such that the points in the sparse grids will appear before the points in the dense grids.\nIn the basic probing operation, the receiver ﬁrst decodes a lattice point D Λ (αy) and then performs error detection for ˆu.\nAlgorithm 2 Hierarchically-organized list-building algorithm Input: a lattice-partition chain L 0 / . . . / L m with a region R. Output: an ordered list of probing points.\n9. Set j = j − 1. 10. end while\nHere we propose to conduct an early detection well before complete decoding of αy. This can be achieved for certain lattice-decoder structures, e.g., a lattice decoder based on the Viterbi algorithm.\nRecall that the Viterbi algorithm is an instance of maximum- likelihood decoding for convolutional codes, and it generates a list of candidates for each initial message segments along the trellis search, where the size of the list is equal to the number of states of the Viterbi algorithm. Note that, for certain initial message segment, if all current candidates fail to pass the parity-checks involved so far, then there is no need to continue the trellis search and the algorithm aborts. This suggests an early rejection strategy as summarized in Algorithm 3.\nWe note that there is an efﬁcient implementation of Al- gorithm 3 in which each parity-check equation is veriﬁed at most M times, where M is the number of states of the Viterbi algorithm. Thus, the cost of verifying parity-check equations is much less than the cost of the trellis search. In other words, the computational cost of Algorithm 3 is dominated by the trellis search. If Algorithm 3 stops at some initial message segment (ˆ u 1 , . . . , ˆ u j ) , then the cost is roughly j/k of the cost of a complete trellis search, where k is the length of the messages.\nIn this section, we illustrate the feasibility of blind C&F through simulations. The setup of our simulation is as follows. The lattice partition Λ/Λ  is constructed from a terminated convolutional code over Z[i]/(3) following Example 7 in [5] with the parameters µ = 400, ν = 1. For illustrative purposes, the linear detection code C is set to a simple 20 × 20 product\nAlgorithm 3 Early rejection algorithm Input: a point α.\nOutput: α is good or α is bad. 1. for j = 1, . . . , k do\n3. Let S be the set of parity-check equations involved so far.\n9. Declare α is bad. 10. else\ncode consisting of a [20, 19] single parity-check code with itself over Z[i]/(3). Clearly, the rate of C is 361/400 ≈ 0.9. The region R is set to [0, log 10 (SNR)] × [0, log 10 (SNR)] , and the lattice-partition chain is L j = 1 16 log 10 (SNR)(1 + i) j Z[i] (j = 0, . . . , 8) as suggested in Sec. IV-A.\nWe consider a two-transmitter, single receiver conﬁguration, which can be viewed as a building block of a more compli- cated and realistic network scenario. Communication occurs in rounds. In each round, the channel gains are assumed to follow independent Rayleigh fading. A round is said to be successful if the receiver correctly recovers a linear combination. The throughput is deﬁned as the fraction of successful rounds in the simulation.\nWe have evaluated four blind C&F schemes through sim- ulation by carrying out 1000 rounds. The ﬁrst scheme is a baseline scheme where the probing list contains all the points in L 0 ∩ R ordered so that their L 1 -norms are non-decreasing. The second and third schemes use the strategies outlined in Sec. IV-A and IV-B, respectively, while the fourth scheme uses both strategies simultaneously.\nNote that the throughputs of each scheme is the same, as each scheme contains the same set of points. Table I compares the throughput of these blind schemes with the throughput of coherent C&F under various SNRs. It is observed that these blind C&F schemes are always able to approach the throughput of coherent C&F.\nNext we examine the complexity of these blind C&F schemes under various SNRs. Recall that the complexity of our blind C&F schemes is dominated by the trellis search. As such, the complexity is normalized relative to one complete trellis search. Table II compares the complexity of these blind\nschemes under various SNRs. It is observed that our proposed strategies signiﬁcantly reduce the complexity, especially when the throughput is high.\nTo summarize, our simulation results suggest that a blind C&F scheme that admits Viterbi decoding is able to approach the throughput of coherent C&F with around 10 times com- plexity in the high-throughput region.\nIn this paper, the problem of designing blind C&F schemes has been considered. A framework based on error-detection has been proposed, which eliminates the need for CSI in C&F. In particular, a generic blind C&F scheme has been developed, and several strategies have been suggested to make it computationally efﬁcient. The effectiveness of our approach has been illustrated through simulations. We believe that there is still much work to be done in this direction, particularly in investigating the performance-complexity tradeoff of the blind C&F schemes, as well as devising efﬁcient probing strategies for alternative coding structures.\nThe authors would like to thank Bobak Nazer and Michael Gastpar for suggesting the blind compute-and-forward prob- lem."},"refs":[{"authors":[{"name":"B. Nazer"},{"name":"M. Gastpar"}],"title":{"text":"Compute-and-forward: Harnessing interfer- ence through structured codes"}},{"authors":[{"name":"U. Niesen"},{"name":"P. Whiting"}],"title":{"text":"The degrees of freedom of compute-and- forward"}},{"authors":[{"name":"B. Hassibi"},{"name":"B. M. Hochwald"}],"title":{"text":"How much training is needed in multiple-antenna wireless links"}},{"authors":[{"name":"U. Erez"},{"name":"R. Zamir"}],"title":{"text":"Achieving 1 2 log(1 + SNR) on the awgn channel with lattice encoding and decoding"}},{"authors":[{"name":"C. Feng"},{"name":"D. Silva"},{"name":"F. R. Kschischang"}],"title":{"text":"An algebraic approach to physical-layer network coding"}},{"authors":[{"name":"B. Hern"},{"name":"K. Narayanan"}],"title":{"text":"Multilevel coding schemes for compute-and- forward"}},{"authors":[{"name":"O. Ordentlich"},{"name":"J. Zhan"},{"name":"U. Erez"},{"name":"M. Gastpar"},{"name":"B. Nazer"}],"title":{"text":"Practical code design for compute-and-forward"}},{"authors":[{"name":"J.-C. Belﬁore"}],"title":{"text":"Lattice codes for the compute-and-forward protocol: The ﬂatness factor"}},{"authors":[{"name":"G. D. Forney"}],"title":{"text":"Coset codes\u2014part II: Binary lattices and related codes"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569566697.pdf"},"links":[],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S3.T3.1","endtime":"15:00","authors":"Chen Feng, Danilo Silva, Frank R. Kschischang","date":"1341240000000","papertitle":"Blind Compute-and-Forward","starttime":"14:40","session":"S3.T3: *-and-Forward Relaying","room":"Stratton S. de P. Rico (202)","paperid":"1569566697"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
