{"id":"1569565711","paper":{"title":{"text":"Codes for Locating Objects in Sensor Networks"},"authors":[{"name":"Ville Junnila"},{"name":"Tero Laihonen"},{"name":"Aline Parreau"}],"abstr":{"text":"Abstract\u2014Karpovsky, Chakrabarty and Levitin introduced identifying codes, which can be applied, for example, to locating objects in sensor networks. In this paper, the underlying structure is Z 2 where one sensor can check its neighbours within Euclidean distance r. We construct identifying codes in this network that are robust against some changes in the neighbourhood monitored by each sensor. We give bounds for the smallest density of such an identifying code for general values of r. We also provide inﬁnite families of values r with optimal such codes and study the case of small values of r."},"body":{"text":"Let a network be modelled by a simple, connected and undirected graph G = (V, E) with vertex set V and edge set E. We can place a sensor in any vertex u. A sensor is able to check its closed neighbourhood N [u] (i.e., the adjacent vertices and itself) and report to a central controller if it detects a sought object there (like a smoke detector). The idea is to place as few sensors as possible in such a way that we can uniquely determine where (that is, in which vertex) the object is (if any) knowing only the set of sensors which gave us the alarm (see [10]).\nLet us denote the subset of vertices, where we placed the sensors, by C. In order to ﬁnd the sought object (like a ﬁre) in our network, we need to choose C in the following way. Denote the set of sensors monitoring a vertex u ∈ V by I(u) = N [u] ∩C. Let C satisfy the following two conditions: I(u) = ∅ for every u ∈ V and I(u) = I(v) for all u, v ∈ V , u = v. Hence, I(u) is the set of sensors giving the alarm if there is an object in u, and since it is unique and nonempty for each u ∈ V , we can determine the vertex with a object (if there is any). Such a subset C ⊆ V satisfying the two requirements is called an identifying code. The concept of identifying codes was introduced in [8], where a fault diagnosis was performed in multiprocessor networks.\nIn this paper, we consider a graph with vertex set Z 2 endowed with the Euclidean distance d. Let further r be a positive real number. The set of edges is deﬁned as follows: there is an edge between two vertices of Z 2 if their Euclidean distance is at most r. In other words, the closed neighbourhood of a vertex u = (x u , y u ) ∈ Z 2 is the ball\nHence, in this graph each sensor can check (or cover) vertices within Euclidean distance r. In Figure 1, we have illustrated\nFigure 1: An optimal identifying code for Z 2 (denoted by black dots) with Euclidean radius r =\ncode in it. For special values of r, this graph has been considered in many papers, for example, for r = 1 in Ben- Haim and Litsyn [1] and for r =\nSince our underlying graph Z 2 is inﬁnite, we need a device to measure how \u2018small\u2019 our code is compared to others. To this end, we use the usual concept of density. Denote a square Q n = {(x, y) ∈ Z 2 | |x| ≤ n, |y| ≤ n} for a positive integer n. Obviously, |Q n | = (2n + 1) 2 . The density D(C) of a code C ⊆ Z 2 is\nWe say that an identifying code is optimal if there is no code with lower density.\nThe previously deﬁned concept of identiﬁcation is a some- what idealized view to approach the described locating prob- lem. In particular, it is unrealistic to assume that each sensor c ∈ C monitors exactly the Euclidean ball B r (c) of radius r (if in Figure 1 the radius is a bit smaller, we do not have an identifying code anymore). In this paper, we concentrate on a more realistic scenario, where the area that each sensor monitors may individually vary. Supposing ∆ ≥ 0 is a real number, we assume that the area covered by a sensor c ∈ C is a subset of B r+∆ (c) such that all the vertices of B r (c) belong to it. Consider then which sensors monitor a given vertex u ∈ Z 2 . Clearly, the sensor covering u are the ones that belong to an area, which is a subset of B r+∆ (u) and contains all the vertices of B r (u). A code C, using which we can uniquely determine the sought vertex solely based\non the information provided by the sensors, is called (r, ∆)- tolerant identifying (or in short (r, ∆)-identifying). The formal deﬁnition of tolerant identifying codes is presented in the following.\nA subset C ⊆ Z 2 is an (r, ∆)-tolerant identifying code (or in short (r, ∆)-identifying code), if for every u ∈ Z 2 we have B r (u) ∩ C = ∅ and for all distinct vertices u and v:\nClearly, this formal deﬁnition coincides with the informal one described above. We denote the smallest possible density D(C) of an (r, ∆)-identifying code C by D(r, ∆).\nThis paper is based on a full paper [7] (available also in Arxiv), where the reader can ﬁnd all the detailed proofs.\nThe ﬁrst nontrivial ball of Z 2 has radius 1 and the next different one has radius\n√ 2. For any object in u or in v there must be a codeword (sensor) to separate them. The pairs of vertices that are the \u2018most\u2019 difﬁcult to separate (in the sense that there are few vertices one can place a codeword to distinguish them) are pairs of vertices at distance 1. So it is good to start by studying S 1, √ 2 −1 (u, v) when v − u = (1, 0). We will call this set the horizontal pattern, and for the precise case (r, ∆) = (1,\ncan notice that it has only two elements, that means that the density of an (1,\n, since there must be a codeword in the set to separate u from v. By symmetry, we also know the vertical pattern depicted in Figure 2b.\nIt is easy to ﬁnd a code with density 1 2 that intersects all the sets S 1, √ 2 −1 (u, v) for v − u = (1, 0) or v − u = (0, 1). One can for example take as a code all the vertices (x, y) such that x + y ≡ 0 mod 2. But this code will not always intersect the diagonal pattern S 1, √ 2 −1 (u, v) with v − u = (1, 1), shown in Figure 2c, which is needed to separate u and v when v −u = (1, 1). If we take the code C that is depicted in Figure 3, we can show that it always intersects the diagonal pattern and the anti-diagonal pattern ( v − u = (−1, 1)). To show that C is a (1,\nshow that B 1 (u) ∩ C = ∅ for all u (this is clearly true) and to check that it intersects all the other sets S 1, √ 2 −1 (u, v). For this last point, we can notice that S 1, √ 2 −1 (u, v), when d(u, v) > √\n2, has always three vertices forming an L-pattern: (up to orientation) and that C intersects all the L-patterns. We can now conclude that C has optimal density and so:\nv u\nFigure 2: The set S 1, √ 2 −1 (u, v) when (a) v − u = (1, 0) (horizontal pattern), (b) v − u = (0, 1) (vertical pattern), (c) v − u = (1, 1) (diagonal pattern) and (d) v − u = (1, −1) (anti-diagonal pattern).\nBefore we can start to ﬁnd as small as possible (r, ∆)- identifying codes, we need to know for which r and ∆ these codes exist. The next proposition gives a necessary and sufﬁcient condition to have an (r, ∆)-identifying code:\nProposition 1. There exists an (r, ∆)-identifying code if and only if S r,∆ ((0, 0), ( −1, 0)) is nonempty.\nIn the following, we will consider only values (r, ∆) such that there is an (r, ∆)-identifying code.\nNext we brieﬂy discuss general lower bounds on the density of (r, ∆)-identifying codes.\nThis bound is good for ﬁxed value of ∆. But when ∆ approaches 1 as r grows, we will have better bound. For this we will use the following proposition. This lower bound is sharp in some cases as we will see in the next section.\nIn the particular case where ∆ is close to ∆ m , we obtain that D(r, ∆) has order at least 1 √ r which is better than the order 1/r of (1).\nTo obtain upper bounds, we construct codes with the follow- ing vertical and horizontal lines, deﬁned for a positive integer k:\n\u2022 L v k = {(x, y) ∈ Z 2 | x ≡ 0 mod k}, \u2022 L h k = {(x, y) ∈ Z 2 | y ≡ 0 mod k}.\nThe idea behind the proof of the following proposition is that if we take frequently enough vertical and horizontal lines into our code, the codewords in them will always intersect the sets S r,∆ (u, v). In the following x 1 (r, ∆) denotes the point after which the set S r,∆ (u, v), u − v = (1, 0), always contains a point of Z 2 on every vertical line with abscissa x ∈ (x 1 (r, ∆), r). The exact value of x 1 (r, ∆) is easy to calculate (see the full paper [7]).\nProposition 4. Let k = ⌊r⌋−x 1 (r, ∆). Then C r,∆ = L v k ∪L h k is an (r, ∆)-identifying code, and we have:\nwhere K is a constant. Combining (1) and (2), we know that an optimal (r, ∆)-identifying code, for ∆ ﬁxed, has order 1 r as r → ∞.\nThe previous construction does not use the full symmetry of the set S r,∆ ((0, 0), ( −1, 0)). We can often construct better codes using diagonal lines that utilize the symmetry. The following construction of Proposition 5 gives a method to construct better (r, ∆)-identifying codes.\nWe say that a set U of Z 2 intersects all the diagonal (resp. anti-diagonal, horizontal and vertical) lines modulo k if for all i ∈ {0, 1, . . . , k − 1}, there is an element (x, y)\nof U such that y − x ≡ i mod k (resp. x + y ≡ i mod k, y ≡ i mod k and x ≡ i mod k). As an example, the set S 3, √ 10 −3 ((0, 0), ( −1, 0)) (see Figure 4) intersects all the diagonal and anti-diagonal lines modulo 6 whereas the set S 3, √ 10 −3 ((0, 0), ( −1, −1)) intersects all the horizontal and vertical lines modulo 8.\n0 1\nFigure 4: In (a), the set S 3, √ 10 −3 ((0, 0), ( −1, 0)) intersects all the diagonal and anti-diagonal lines modulo 6. In (b), the set S 3, √ 10 −3 ((0, 0), ( −1, −1)) intersects all the horizontal and vertical lines modulo 8.\nLet diag(U ) be the maximum k such that the set U intersects all the diagonal lines modulo k.\nThe following proposition gives (with some restrictions), for given r and ∆, a method to construct (r, ∆)-identifying codes.\nProposition 5. Let s ≤ diag(B r ((0, 0))) and t be integers. Let L d s = {(x, y)|y−x ≡ 0 mod s}. Assume that the following conditions hold:\n(a) S r,∆ ((0, 0), ( −1, 0)) intersects all the diagonal lines mod- ulo s,\n(b) S r,∆ ((0, 0), ( −1, −1)) intersects all the horizontal lines modulo t,\nIf in the diagonal pattern there are all the diagonal and anti- diagonal lines modulo s, we do not need to put horizontal lines in the code of Proposition 5, and then we obtain a code of density 1 s . This is in particular the case when s is ﬁxed and r is big enough:\n(i) There exists r 0 ∈ N such that for all r ≥ r 0 and all ∆ ∈ [0, ∆ m (r)] the set S r,∆ ((0, 0), ( −1, −1)) contains all the diagonal and anti-diagonal lines modulo s in the ﬁrst quadrant.\n(ii) If, furthermore, the set S r,∆ ((0, 0), ( −1, 0)) contains all the diagonal lines modulo s, then there is an (r, ∆)-identifying code of density 1 s .\nIn this section, we give inﬁnite families of values (r, ∆) for which s = 2, 4, 6 or 8 and |S r,∆ ((0, 0), ( −1, 0))| = s, leading by Proposition 6 to inﬁnite families with optimal codes.\nWe ﬁrst start with s = 2. In this particular case, there is always a code with density 1 2 :\nProof: The ﬁrst part of the proposition is not difﬁcult: if r is an integer, then for any ∆ < 1, ( −r − 1, 0) and (r, 0) are in S r,∆ ((0, 0), ( −1, 0)) and they are the only vertices with ordinate 0. If r + ∆ ≥\nof B r ((0, 0)) with y = 0, x ≤ r − 1 and (x + 1) 2 + y 2 ≤ r 2 + 2r − 1 ≤ (r + ∆) 2 and so (x, y) ∈ B r+∆ (( −1, 0)). Clearly, S r,∆ ((0, 0), ( −1, 0)) intersects all the diagonal lines modulo 2.\nFor the second part of the proposition, we know by Propo- sition 6 that it will be true for r big enough, but it is harder to ﬁnd the codes for all the values of r (this is done in [7], one code for r = 4 is given below).\n√ 23 − 4 ≤ ∆ < 1. The code is constructed by repeating the given tile.\nWe now consider the case when S r,∆ ((0, 0), ( −1, 0)) has four elements:\nTheorem 8. Let k and i be two integers such that i is odd and i 2 < 2k + 1. Let r =\n√ k 2 + i 2 and r + ∆ = √ r 2 + 2k. Then |S r,∆ ((0, 0), ( −1, 0))| = 4 and S r,∆ ((0, 0), ( −1, 0)) intersects all the diagonal lines modulo 4. If r is big enough, there is an optimal (r, ∆)-identifying code of density 1 4 .\nProof: To prove that |S r,∆ ((0, 0), ( −1, 0))| = 4, we show X 1 = S r,∆ ((0, 0), ( −1, 0)) ∩ {(x, y)|x > 0, y ≥ 0} has only one vertex, and that vertex has strictly positive ordinate. Let (x, y) ∈ X 1 , we have x ≤ ⌊r⌋ = k. If x = k then y ≤ i. If y < i then (x + 1) 2 + y 2 ≤ (k + 1) 2 + i 2 − 1 ≤ r 2 + 2k = (r + ∆) 2 , so (x, y) / ∈ X 1 . If y = i then (x + 1) 2 + y 2 =\nr 2 + 2k + 1 > (r + ∆) 2 so (k, i) ∈ X 1 . If x < k, then (x+1) 2 +y 2 ≤ r 2 +2k −1 ≤ (r+∆) 2 and again (x, y) / ∈ X 1 . Therefore, the only vertex in X 1 is (k, i), and i > 0. This implies that |S r,∆ ((0, 0), ( −1, 0))| = 4 and the four vertices of S r,∆ ((0, 0), ( −1, 0)) are (k, i), (k, −i), (−k − 1, i) and ( −k − 1, −i). It remains to show that the four values i − k, −i − k, i + k + 1, −i + k + 1 are different modulo 4. By adding i + k, it is eauivalent to show that the four values 0, 2i, 2k + 1, 2k + 1 + 2i are different modulo 4, which is clear. The last claim is a direct consequence of Proposition 6.\nTheorem 9. Let k be an odd integer not divisible by 3 and let r = 2k 2 + 1, r + ∆ =\n√ r 2 + 2r − 3. Then |S r,∆ ((0, 0), ( −1, 0))| = 6 and S r,∆ ((0, 0), ( −1, 0)) intersects all the diagonal lines modulo 6. If r is big enough, there is an optimal (r, ∆)-identifying code of density 1 6 .\nTheorem 10. Let k ≥ 18 be an integer such that k ≡ 2 mod 16 and let L = k 2 2 − 1. Let r =\nr + ∆ = √ L 2 + 2L + 4. Then |S r,∆ ((0, 0), ( −1, 0))| = 8 and S r,∆ ((0, 0), ( −1, 0)) intersects all the diagonal lines modulo 8. If r is big enough, there is an optimal (r, ∆)-identifying code of density 1 8 .\nProof: We ﬁrst show that the vertices of X 1 = S r,∆ ((0, 0), ( −1, 0)) ∩ {(x, y)|x > 0, y ≥ 0} are (L, 2) and (L − 2, k). Those two vertices clearly are in X 1 . It is also clear that there are no other vertices with abscissa L or at most L − 2. It remains to show that there are no vertices with abscissa L − 1. If there is a vertex (L − 1, y) in X 1 then necessarily, y 2 ≤ 2L + 7. But 2L ≡ 0 mod 16, so 2L + 5, 2L + 6 and 2L + 7 are not square of integers, and so y 2 ≤ 2L + 4. Then (x + 1) 2 + y 2 ≤ (r + ∆) 2 , a contradiction. A simple computation shows that the eight vertices of S r,∆ ((0, 0), ( −1, 0)) are on different diagonal lines modulo 8, and again we conclude with Proposition 6.\nIn Figures 6a and 6b, the horizontal and diagonal patterns for (r, ∆) = (\nProof: To prove this lower bound, we use the frame of Figure 6c. Let F be a ﬁxed set of vertices of Z 2 forming the frame of Figure 6c. Let C be a (\ncode. Then for any u ∈ Z 2 , C ∩(u+F ) contains at least three vertices. Indeed, F contains two disjoint horizontal patterns, so C ∩ (u + F ) contains at least two vertices. Assume there are only two vertices. Then there must be one of the vertex in a corner, otherwise one horizontal or vertical pattern is empty. Thus the other one must be in the opposite corner, but that implies that a diagonal pattern is empty.\nFigure 6: The set S √ 2,2 − √ 2 (u, v) when (a) v − u = (1, 0) and (b) v − u = (1, 1). The frame is shown in (c).\nFigure 7: The ﬁve possibilities for the frame of Figure 6c to have exactly three vertices.\nIn fact, if C ∩ (u + F ) contains exactly three vertices, there are, up to obvious symmetry, only ﬁve different possibilities for the positions of the three vertices, depicted in Figure 7. We can observe that for any of those possibilities, one of the neighbouring frame, i.e., one set v + F with d(u, v) = 1, contains at least four vertices of C: the frame on the top for case (c) and the frame on the left for the other cases.\nWe now give, for any u ∈ Z 2 , charge |C ∩ (u + F )| to each set u + F . We apply the following rule: each set u + F with charge at least 4 gives charge 1 5 to the neighbouring sets v + F , with d(u, v) = 1 which have charge 3. By the previous remark, after this process, each set u + F will have charge at least 3 + 1 5 = 16 5 .\nThat means that on average, the number of vertices of C in a frame u + F is at least 16 5 . We can conclude that the density of C is at least 16 5 × 1 |F | = 4 15 .\nWe can improve this lower bound by more advanced anal- ysis. This leads to the following result. For the upper bound, we use the code C of Figure 8 that has density 1 3 .\nTheorem 12. We have 16\nProposition 13. We have 0.17 ≤ D(\nThe ﬁrst author is supported by the V¨ais¨al¨a Foundation of the Finnish Academy of Science and Letters."},"refs":[{"authors":[{"name":"Y. Ben-Hai"},{"name":"S. Litsyn"}],"title":{"text":"Exact minimum density of codes identifying vertices in the square grid"}},{"authors":[{"name":"K. Chakrabart"},{"name":"S. S. Iyenga"},{"name":"H. Q"},{"name":"E. Cho"}],"title":{"text":"Grid Coverage for Surveillance and Target Location in Distributed Sensor Networks"}},{"authors":[{"name":"I. Charo"},{"name":"I. Honkal"},{"name":"O. Hudr"},{"name":"A. Lobstein"}],"title":{"text":"The minimum density of an identifying code in the king lattice"}},{"authors":[{"name":"I. Honkal"},{"name":"M. G. Karpovsk"},{"name":"L. B. Levitin"}],"title":{"text":"On robust and dynamic identifying codes"}},{"authors":[{"name":"I. Honkal"},{"name":"A. Lobstein"}],"title":{"text":"On the density of identifying codes in the square lattice"}},{"authors":[{"name":"V. Junnil"},{"name":"T. Laihonen"}],"title":{"text":"Identiﬁcation in Z 2 using Euclidean balls"}},{"authors":[{"name":"V. Junnil"},{"name":"T. Laihone"},{"name":"A. Parreau"}],"title":{"text":"Tolerant identiﬁcation with Euclidean balls"}},{"authors":[{"name":"M. G. Karpovsk"},{"name":"K. Chakrabart"},{"name":"L. B. Levitin"}],"title":{"text":"On a new class of codes for identifying vertices in graphs"}},{"authors":[{"name":"A. Lobstein"}],"title":{"text":"Identifying and locating-dominating codes in graphs, a bibliography"}},{"authors":[{"name":"S. Ra"},{"name":"R. Ungrangs"},{"name":"F. De Pellegrin"},{"name":"A. Trachtenber"},{"name":"D. Starobin- ski"}],"title":{"text":"Robust location detection in emergency sensor networks"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569565711.pdf"},"links":[{"id":"1569566683","weight":4},{"id":"1569566871","weight":4},{"id":"1569566739","weight":4},{"id":"1569565609","weight":62},{"id":"1569566369","weight":4},{"id":"1569561123","weight":4},{"id":"1569565571","weight":8},{"id":"1569565925","weight":4},{"id":"1569565319","weight":4},{"id":"1569564291","weight":4}],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S4.T6.3","endtime":"17:40","authors":"Ville Junnila, Tero K Laihonen, Aline Parreau","date":"1341249600000","papertitle":"Codes for Locating Objects in Sensor Networks","starttime":"17:20","session":"S4.T6: Identifying Codes and Power Line Communications","room":"Kresge Rehearsal A (033)","paperid":"1569565711"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
