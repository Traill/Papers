{"id":"1569566445","paper":{"title":{"text":"On the Feasibility of Precoding-Based Network Alignment for Three Unicast Sessions"},"authors":[{"name":"Chun Meng"},{"name":"Abinesh Ramakrishnan"},{"name":"Athina Markopoulou"},{"name":"Syed Ali Jafar"}],"abstr":{"text":"Abstract\u2014We consider the problem of network coding across three unicast sessions over a directed acyclic graph, when each session has min-cut one. Previous work by Das et al. adapted a precoding-based interference alignment technique, originally developed for the wireless interference channel, speciﬁcally to this problem. We refer to this approach as precoding-based network alignment (PBNA). Similar to the wireless setting, PBNA asymptotically achieves half the minimum cut; different from the wireless setting, its feasibility depends on the graph structure. Das et al. provided a set of feasibility conditions for PBNA with respect to a particular precoding matrix. However, the set consisted of an inﬁnite number of conditions, which is impossible to check in practice. Furthermore, the conditions were purely algebraic, without interpretation with regards to the graph structure. In this paper, we ﬁrst prove that the set of conditions provided by Das. et al are also necessary for the feasibility of PBNA with respect to any precoding matrix. Then, using two graph-related properties and a degree-counting technique, we reduce the set to just four conditions. This reduction enables an efﬁcient algorithm for checking the feasibility of PBNA on a given graph."},"body":{"text":"Network coding was originally introduced to maximize the rate of a single multicast session over a network [1] [2] [3]. However, network coding across different sessions, which includes multiple unicasts as a special case, is a well-known open problem. For example, ﬁnding linear network codes for multiple unicasts is NP-hard [4]. Thus, suboptimal, heuristic approaches, such as linear programming [5] and evolutionary approaches [6], are typically used. Moreover, while it has been shown that scalar or vector linear network codes might be insufﬁcient to achieve the optimal rate [7], only approximation methods [8] exist to characterize the rate region for this setting.\nIn this paper, we consider the simplest inter-session lin- ear network coding scenario: three unicast sessions over a directed acyclic graph, each session with min-cut one. Das et al. [9] applied a precoding-based interference alignment technique, originally developed by Cadambe and Jafar [10] for wireless interference channel, to this problem; we refer to this technique as precoding-based network alignment (PBNA). In a nutshell, PBNA (i) simulates a wireless channel through random network coding [3] in the middle of the network and (ii) applies interference alignment at the edge, i.e., via precoding at the sources and decoding at the receivers. This way, it greatly simpliﬁes the network code design, while it guarantees that each unicast session asymptotically achieves a rate equal to half of its minimum cut [9].\nHowever, an important difference from the wireless inter- ference channel is that, in our problem, network topology might introduce dependencies between elements of the transfer matrix, which make PBNA infeasible in some networks [11]. As a ﬁrst step, [9] provided a set of feasibility conditions for PBNA, and proved they are sufﬁcient for the feasibility of PBNA with respect to a particular precoding matrix. One important limitation is that the set consists of an inﬁnite number of conditions, which makes it impossible to check in practice. Another limitation is the lack of consideration of graph structures, which is the reason for the signiﬁcant redundancy in the set. Ramakrishnan et al. [11] conjectured that the inﬁnite set of conditions can be reduced to just two conditions. Han et al. [12] proved that the conjecture actually holds for three symbol extensions; unfortunately, this result cannot be generalized beyond three symbol extensions.\nIn this paper, we make the following contributions. First, we prove that the set of conditions provided in [9] are also necessary for the feasibility of PBNA with respect to any valid precoding matrix. Then, using a simple degree-counting technique and two graph-related properties, we greatly reduce the set to just three conditions; two of them turn out to have an intuitive interpretation in terms of graph structure. Finally, we present an efﬁcient algorithm for checking the three conditions.\nThe rest of this paper is organized as follows. In Section II, we present the problem formulation. In Section III, we summarize our main results. In Section IV, we discuss the graph-related properties that are key to the simpliﬁcation of the conditions. In Section V, we prove and discuss our main results regarding the feasibility condition of PBNA. In Section VI, we present an algorithm for checking the condition. In Section VII, we conclude the paper.\nThe network is a delay-free directed acyclic graph, denoted by G = (V, E), where V is the set of nodes and E the set of edges. Without loss of generality, each edge has capacity one, i.e., can transmit one symbol of ﬁnite ﬁeld F 2 m in a unit time. For the ith unicast session (i ∈ {1, 2, 3}), let s i and d i be its sender and receiver respectively, and R i its transmission rate. Every edge e ∈ E represents an error free channel. We assume that the minimum cut between s i and d i is one. Let X i be the source symbol transmitted at s i and Z i be the symbol received at d i . We further extend G as follows: For the ith unicast session (i ∈ {1, 2, 3}), we add a virtual sender s i and a virtual receiver d i and two edges σ i = (s i , s i ) and τ i = (d i , d i ). The\nextended graph is denoted by G = (V , E ). For e ∈ E , let head(e) and tail(e) denote its head and tail respectively.\nIn the middle of the network, we employ random network coding [3] to mimic wireless channel. The symbol transmitted along e ∈ E is a linear combination of incoming symbols at tail(e). For e , e ∈ E such that head(e ) = tail(e), let x e e be a random variable, which takes values from F 2 m and represents the coding coefﬁcient used to combine the incoming symbol along e into the symbol along e. We group all coding coefﬁcients x e e \u2019s into a vector x, called the coding vector of G . The network acts as a linear system: the output at d i is a mixture of source symbols, Z i = 3 j=1 m ij (x)X j , where m ij (x) ∈ F 2 m [x] is the transfer function from s j to d i and can be written as follows [2]:\nwhere P ij is the set of paths from s j to d i , and t(P ) is the product of coding coefﬁcients along path P . We assume that all m ij (x)\u2019s are non-zeros, which is the most challenging case. Indeed, as shown in [13], when some m ij (x) (i = j) is zero, the feasibility condition of PBNA is signiﬁcantly simpliﬁed due to reduced number of interferences.\nAt the edge of the network, we apply interference alignment [9] [10] via precoding at senders and decoding at receivers. Let X i = (X 1 i , · · · , X k i i ) T denote the input vector at sender s i , where k i = n + 1 for i = 1 and k i = n otherwise. We use precoding matrix V i to encode X i into 2n+1 symbols, which are then transmitted in 2n + 1 time slots. The output vector at d i is Z i = (Z 1 i , · · · , Z 2n+1 i \t ) T = 3 j=1 M ij V j X j , where M ij is a (2n + 1) × (2n + 1) diagonal matrix with the (k, k) element being m ij (x k ), where x k represents the coding vector for the kth use of the network. V 1 is a (2n + 1) × (n + 1) matrix, and V 2 , V 3 are both (2n+1)×n matrices. V i can still contain indeterminate variables. Let ξ denote the vector of all variables in x 1 , · · · , x 2n+1 and V 1 , V 2 , V 3 . We require the following conditions are satisﬁed for some values of ξ [10]:\nCondition A i guarantees that all the interferences at d i are aligned, i.e., mapped into the same linear space, while condition B i ensures that all source symbols for the ith unicast session can be decoded. These conditions ensure that we can achieve a rate tuple (R 1 , R 2 , R 3 ) = R ∗ n\n( n+1 2n+1 , n 2n+1 , n 2n+1 ), which approaches ( 1 2 , 1 2 , 1 2 ) as n → ∞. In this case, we say that R ∗ n is feasible through PBNA.\nPrevious work [9] [11] [12] only considered the feasibility of PBNA under a particular precoding matrix, i.e., V ∗ 1 in Eq. (4), which was ﬁrst introduced in [10]. To address this limitation and characterize the feasibility of PBNA for any precoding matrix, we reformulate A 1 , A 2 , A 3 and B 1 , B 2 , B 3 without any assumption about the structure of precoding\nmatrix. First, we reformulate A 1 , A 2 , A 3 as: A 1 : M 12 V 2 = M 13 V 3 A A 2 : M 23 V 3 = M 21 V 1 B A 3 : M 32 V 2 = M 31 V 1 C\nwhere A is an n × n invertible matrix, and B and C are both (n + 1) × n matrices with rank n. A 1 , A 2 , A 3 can be further condensed into a single condition:\nwhere T = M 12 M −1 21 M 23 M −1 32 M 31 M −1 13 . Finally, conditions B 1 , B 2 , B 3 are reformulated as:\nB 1 : ψ 1 (ξ) = det(V 1 P 1 V 1 C) = 0 B 2 : ψ 2 (ξ) = det(V 1 P 2 V 1 C) = 0\nand P 3 = M 12 M −1 32 M 33 M −1 13 , and ψ 1 (ξ), ψ 2 (ξ), ψ 3 (ξ) are rational functions in the ﬁeld F 2 m (ξ). Deﬁne ψ(ξ) =\nψ i (ξ). We assume that F 2 m is sufﬁciently large such that if ψ(ξ) is a non-zero rational function, there are assignment of values to ξ, denoted by ξ 0 , such that ψ(ξ 0 ) = 0.\nClearly, p i (x) and η(x) form the elements along the diag- onals of P i and T respectively. Hence, the following lemma holds:\nLemma 1: R ∗ n is feasible through PBNA if and only if 1) Eq. (2) is satisﬁed, and 2) B 1 , B 2 , B 3 are satisﬁed.\nThe fundamental design problem in PBNA is to ﬁnd V 1 such that all the conditions in Lemma 1 are satisﬁed. Indeed, the major restriction on V 1 comes from Eq. (2). As shown in [9], the construction of V 1 depends on whether η(x) is constant. When η(x) is constant, and thus T = I 2n+1 , we set C = BA. Therefore, any arbitrary V 1 can satisfy Eq. (2). In contrast, when η(x) is not constant, we can no longer choose V 1 freely. [10] proposed the following precoding matrix, which has also been used by most of recent work [9] [11] [12]:\nwhere w is a column vector of 2n + 1 ones. Meanwhile, we set A = I n , C consists of the left n columns of I n+1 , and B the right n columns of I n+1 ; this construction satisﬁes Eq. (2). Note that the form of V 1 is determined by A, B and C. With different A, B and C, we can derive different V 1 ; therefore the choice of V 1 is not limited to just V ∗ 1 .\nAs observed in [11], graphs can introduce dependence between transfer functions 1 so that PBNA may be infeasi- ble. This is a fundamental difference compared to wireless\ninterference channel, where channel gains can change inde- pendently and interference alignment is always feasible. Fig. 1 depicts some examples of graphs where PBNA is infeasible. In Fig. 1(a), p i (x) = η(x) = 1 for i ∈ {1, 2, 3}, thus P i = I 2n+1 , implying B 1 , B 2 , B 3 are all violated. In Fig. 1(b), p 1 (x) = η(x) η(x)+1 , which also violates B 1 . This example shows that the conjecture proposed by Ramakrishnan et al. [11] doesn\u2019t hold beyond three symbol extensions. Moreover, by exchanging s 1 ↔ s 2 and d 1 ↔ d 2 , we obtain another counter example, where p 2 (x) = 1 + η(x), violating B 2 .\nAs a ﬁrst step, [9] proposed the following set of conditions for PBNA. 2 For i ∈ {1, 2, 3},\nIn [9], it was proved that if Eq. (5) is satisﬁed, we can use V ∗ 1 to asymptotically achieve half rate in an inﬁnite number of time slots. Unfortunately, since Eq. (5) contains an inﬁnite number of conditions, it is impractical to verify. Moreover, since only one particular matrix was considered in [9], Eq. (5) was only shown to be sufﬁcient for PBNA.\nWe now state our main results; proofs are deferred to Section V and [13]. Since the construction of V 1 depends on whether η(x) is constant, we distinguish two cases.\nIn this case, we can choose V 1 freely, and thus the fea- sibility condition of PBNA can be signiﬁcantly simpliﬁed. Moreover, we can achieve one half rate in exactly two time slots, as stated in the following theorem (See Section V-A).\nTheorem 1: Assume η(x) is constant. The rate tuple ( 1 2 , 1 2 , 1 2 ) is feasible through PBNA if and only if p i (x) is not constant for each i ∈ {1, 2, 3}.\nIn this case, we cannot choose V 1 freely. Using similar technique as in [9], we can rewrite Eq. (5) as follows: 3\nNote that, in contrast to Eq. (5), the above set of conditions guarantee that R ∗ n is NA-feasible for a ﬁxed value of n. Next, we show that Eq. (6) is also necessary for the feasibility of PBNA with respect to any V 1 satisfying the conditions of Lemma 1.\nTheorem 2: Assume η(x) is not constant. R ∗ n is feasible through PBNA if and only if for each i ∈ {1, 2, 3}, p i (x) / ∈ S n .\nTheorem 3 (The Main Theorem): Assume η(x) is not con- stant. For n > 1, R ∗ n is feasible through PBNA if and only if the following conditions are satisﬁed:\nm 21 (x) \t (9) where for i ∈ {1, 2, 3}, a i , b i are constants in {0, 1} and cannot be zeros at the same time.\nNote that Eq. (7)-(9) correspond to the following conditions respectively:\n1 + η(x) \t (10) p 2 (x) / ∈ {1, η(x), 1 + η(x)} \t (11) p 3 (x) / ∈ {1, η(x), 1 + η(x)} \t (12)\nThe basic idea behind the Main Theorem is that we can compare the degree of a variable in p i (x) with that of a rational function in S n . This technique enables us to reduce S n to the\n}. Thus, we only need to consider a ﬁnite number of rational functions, namely Eq. (7)-(9). This enables an efﬁcient algorithm for checking the feasibility of PBNA. The key for enabling this reduction lies in two graph-related properties, which we refer to as Linearization Property and Square-Term Property, as described in the next section.\nOur key intuition is that p i (x) is not an arbitrary function but depends on transfer functions, as speciﬁed in Eq. (3). Therefore, p i (x) have special algebraic properties, which can be exploited to simplify Eq. (6).\nh(x) = m ab (x)m pq (x) m aq (x)m pb (x)\nFurthermore, each path pair in P ab × P pq contributes a term in m ab (x)m pq (x), and each path pair in P aq ×P pb contributes a term in m aq (x)m pb (x):\nFirst, consider the following lemma, which provides an easy way to check whether p i (x) / ∈ {1, η(x)} (as in Section VI). The intuition is that we can multicast two symbols from s b , s q to d a , d p by network coding if and only if the minimum cut separating s b , s q from d a , d p is greater than one [2].\nLemma 2: m ab (x)m pq (x) = m aq (x)m pb (x) if and only if there is disjoint path pair (P 1 , P 2 ) ∈ P ab × P pq or (P 3 , P 4 ) ∈ P aq × P pb .\nThe ﬁrst graph-related property states that p i (x) can be transformed into its simplest non-trivial form (i.e., a linear function or the inverse of a linear function). More formally:\n= u(x) v(x) such that gcd(u(x), v(x)) = 1. Assume h(x) is not constant. Then, for sufﬁciently large m, we can assign values to x other than a variable x ee such that u(x) and v(x) are transformed into either u(x ee ) = c 1 x ee + c 0 , v(x ee ) = c 2 or u(x ee ) = c 2 , v(x ee ) = c 1 x ee + c 0 , where c 0 , c 1 , c 2 are constants in F 2 m , and c 1 c 2 = 0.\nProof: Due to lack of space, we provide the proof outline and refer the reader to [13] for the complete proof. The key is to ﬁnd a subgraph H and consider h(x) restricted to H, i.e.,\n, where x H represents the coding vector of H. In addition, we require that some variable x ee\nappears exclusively in the numerator or the denominator of h(x H ). Thus, by assigning values to x H other than x ee , we can transform h(x H ) into a linear function or the inverse of a linear function in terms of x ee . Since h(x H ) can be acquired through a partial assignment to x, this transformation also holds for the original graph G . Fig. 2 illustrates how to construct H. As shown in this ﬁgure, the structure of H can be one of three cases. A key observation is that for each case, there must be e, e ∈ P 1 ∪P 2 such that x ee appears exclusively in the numerator of h(x H ). Similarly, if there exists disjoint path pair (P 3 , P 4 ) ∈ P aq ×P pb , there exists x ee which appears exclusively in the denominator of h(x H ).\nThe second graph-related property is stated in Lemma 4: the coefﬁcient of x 2 ee in the numerator of h(x) equals its counter- part in the denominator of h(x). Thus, if x 2 ee appears in the\nnumerator of h(x) under some assignment to x, it must also appear in the denominator of h(x), and vice versa.\nLemma 4 (Square-Term Property): For a coding variable x ee , let f 1 (x) and f 2 (x) be the coefﬁcients of x 2 ee\nin m ab (x)m pq (x) and m aq (x)m pb (x) respectively. Then f 1 (x) = f 2 (x).\nProof: For any x ee , deﬁne Q 1 = {(P 1 , P 2 ) ∈ P ab ×P pq : x 2 ee | t(P 1 )t(P 2 )} and Q 2 = {(P 3 , P 4 ) ∈ P aq × P pb : x 2 ee | t(P 3 )t(P 4 )}. Consider a path pair (P 1 , P 2 ) ∈ Q 1 . Since the degree of x ee in t(P 1 ) and t(P 2 ) is at most one, we must have x ee | t(P 1 ) and x ee | t(P 2 ). Thus e, e ∈ P 1 ∩ P 2 . Let P 1 1 , P 2 1 be the parts of P 1 before e and after e respectively. Similarly, deﬁne P 1 2 and P 2 2 . Then construct two new paths: P 3 = P 1 2 ∪ {e, e } ∪ P 2 1 and P 4 = P 1 1 ∪ {e, e } ∪ P 2 2 (see Fig. 3). Clearly, t(P 1 )t(P 2 ) = t(P 3 )t(P 4 ), and thus (P 3 , P 4 ) ∈ Q 2 . The above method establishes a one-to-one mapping φ : Q 1 → Q 2 , such that for φ((P 1 , P 2 )) = (P 3 , P 4 ), t(P 1 )t(P 2 ) = t(P 3 )t(P 4 ). Hence, f 1 (x) = 1 x 2\nIn this section, we provide the proofs of Theorems 1, 2 and the proof outline of the Main Theorem. Due to lack of space, details are deferred to [13].\nProof of Theorem 1: In this case, T is identity matrix. We set V 1 = (θ 1 θ 2 ) T , where θ 1 , θ 2 are arbitrary variables, and A, B, C are all scalar value 1. It is easy to see that Eq. (2) is satisﬁed. Moreover, if p i (x) is not constant, we have\nand B i is satisﬁed. Thus ( 1 2 , 1 2 , 1 2 ) is feasible through PBNA. Conversely, if p i (x) is constant, B i is violated, and thus ( 1 2 , 1 2 , 1 2 ) is not feasible through PBNA.\nThe general form of V 1 that satisﬁes Eq. (2) is as follows: Lemma 5: Any V 1 satisfying Eq. (2) has the form V 1 =\nGV ∗ 1 F, where V ∗ 1 is deﬁned in Eq. (4), F is an (n+1)×(n+1) matrix, and G is a (2n + 1) × (2n + 1) diagonal matrix, with the (i, i) element being f i (η(x i )), where f i (z) is a non-zero rational function in F 2 m (z). Moreover, the (n + 1)th row of FC and the 1st row of FBA are both zero vectors.\nLemma 5 indicates that there is a direct relation between V ∗ 1 and the general form of V 1 , which we use to prove that Eq. (6) is also necessary for the feasibility of PBNA.\nProof of Theorem 2: The sufﬁciency of Eq. (6) was proved in [9]. Now assume p i (x) = f (η(x)) g(η(x)) ∈ S n , where f (z) = n k=0 a k z k and g(z) = n−1 k=0 b k z k . We will prove that for any V 1 satisfying Eq. (2), B i cannot be satisﬁed, thus R ∗ n is not NA-feasible. Apparently, if rank(V 1 ) < n + 1, B i is violated. Thus, in the rest of this proof, we assume rank(V 1 ) = n + 1.\nBy Lemma 5, V 1 = GV ∗ 1 F, where F is an (n + 1) × (n + 1) invertible matrix. The jth row of V 1\nis r j = f j (η(x j ))(1, η(x j ), · · · , η n (x j ))F. Since the (n + 1)th row of FC is zero, we have r j C = f j (η(x j ))(1, η(x j ), · · · , η n−1 (x j ))H, where H consists of the top n rows of FC and rank(H) = n. Let a = (a 0 , a 1 , · · · , a n ) T and b = (b 0 , b 1 , · · · , b n−1 ) T . For i = 1, 2, 3, we deﬁne a = F −1 a and b = H −1 b. It follows\nr j a = f j (η(x j ))(1, η(x j ), · · · , η n (x j ))a = f j (η(x j ))f (η(x j ))\n= p i (x j )f j (η(x j ))(1, η(x j ), · · · , η n−1 (x j ))Hb = p i (x j )r j Cb\nHence, the columns of (V 1 P i V 1 C) are linearly dependent, violating B i . Likewise, we can prove the case i = 3.\nFor the proof of the Main Theorem, we need to rearrange the ratio of rational functions f (η(x)) g(η(x)) in Eq. (6) to a ratio of coprime polynomials with variables x. To this end, we use a property of polynomials stated in the following lemma.\nLemma 6: Let F be a ﬁeld. z is a variable and y = (y 1 , y 2 , · · · , y k ) is a vector of variables. Consider four non- zero polynomials f (z), g(z) ∈ F[z] and s(y), t(y) ∈ F[y], such that gcd(f (z), g(z)) = 1 and gcd(s(y), t(y)) = 1. Denote d = max{d f , d g }. Deﬁne two polynomials in F[y]: α(y) = f ( s(y) t(y) )t d (y) and β(y) = g( s(y) t(y) )t d (y). Then gcd(α(y), β(y)) = 1.\nWe now have all the ingredients to outline the proof of the Main Theorem. The complete proof is described in [13].\nProof Outline of the Main Theorem: The necessity of Eq. (7)-(9) follows directly from Theorem 2. We only need to prove their sufﬁciency.\nFirst, we prove that if p i / ∈ S = {1, η(x), 1+η(x), η(x) 1+η(x) }, then p i (x) / ∈ S n , and thus R ∗ n is feasible through PBNA. By contradiction, assume p i (x) = f (η(x)) g(η(x)) , where f (z), g(z) ∈ F 2 m [z] and gcd(f (z), g(z)) = 1. Denote d = max{d f , d g }. We apply a simple degree-counting technique along with Lemma 3 and 6 to prove that d = 1, and thus f (η(x)) g(η(x)) can only be of the form a 0 +a 1 η(x) b\n. Then, we use Lemma 3 and 4 to rule out other cases.\nWe note that in [12] the authors proved that p 1 (x) = 1 + η(x), p 2 (x) = η(x) 1+η(x) and p 3 (x) = η(x) 1+η(x) . Combined with the above results, we have proved that if Eq. (7)-(9) are satisﬁed, R ∗ n is feasible through PBNA.\nFor a given graph, checking the feasibility of PBNA is now reduced to checking whether Eq. (10)-(12). This is a multi- variate polynomial identity testing problem. To check whether p i (x) = 1, we use Ford-Fulkerson Algorithm, as per Lemma 2. To check whether p i (x) = η(x), we deﬁne q i (x) = η(x) p\nand consider q i (x) = 1. Therefore, Ford-Fulkerson Algorithm can be used to check this condition as well. For the other conditions (p 1 (x) = η(x) 1+η(x) and p 2 (x), p 3 (x) = 1 + η(x)), it is still not clear what is their interpretation in terms of\ngraph structure. A counter example is shown in Fig. 1(b). Nevertheless, we can still check the conditions by evaluating the rational functions through T random tests:\nUsing Lemma 4 of [3], we can upper-bound the probability of error by [1 − (1 − 3 2 m ) L ] T , where L is the maximum distance from any sender to any receiver in the network. Thus, the error can be made arbitrarily small for sufﬁciently large m and T . The running time of the algorithm is O(T |E|D in ), where D in is the maximum in-degree of any node in the network.\nIn this paper, we study the feasibility of PBNA for three unicast sessions. We ﬁrst prove that the set of conditions proposed by [9] are also necessary for the feasibility of PBNA with respect to any valid precoding matrix. Then, we reduce this set of conditions to just four conditions, using two graph-related properties along with a simple degree-counting technique. This reduction enables an efﬁcient algorithm for checking the feasibility of PBNA."},"refs":[{"authors":[{"name":"R. Ahlswede"},{"name":"N. Cai"},{"name":"S.-Y. R. Li"},{"name":"R. Yeung"}],"title":{"text":"Network information ﬂow"}},{"authors":[{"name":"R. Koetter"},{"name":"M. M´edard"}],"title":{"text":"An algebraic approach to network coding"}},{"authors":[{"name":"T. Ho"},{"name":"M. M´edard"},{"name":"R. Koetter"},{"name":"D. R. Karger"},{"name":"M. Effros"},{"name":"J. Shi"},{"name":"B. Leong"}],"title":{"text":"A random linear network coding approach to multicast"}},{"authors":[{"name":"A. R. Lehman"},{"name":"E. Lehman"}],"title":{"text":"Complexity classiﬁcation of network information ﬂow problems"}},{"authors":[{"name":"D. Traskov"},{"name":"N. Ratnakar"},{"name":"D. S. Lun"},{"name":"R. Koetter"},{"name":"M. M´edard"}],"title":{"text":"Network coding for multiple unicasts: An approach based on linear optimization"}},{"authors":[{"name":"M. Kim"},{"name":"M. M´edard"},{"name":"U.-M. O\u2019Reilly"},{"name":"D. Traskov"}],"title":{"text":"An evolutionary approach to inter-session network coding"}},{"authors":[{"name":"M. M´edard"},{"name":"M. Effros"},{"name":"D. Karger"},{"name":"T. Ho"}],"title":{"text":"On coding for non- multicast networks"}},{"authors":[{"name":"N. J. A. Harvey"},{"name":"R. Kleinberg"},{"name":"A. R. Lehman"}],"title":{"text":"On the capacity of information networks"}},{"authors":[{"name":"A. Das"},{"name":"S. Vishwanath"},{"name":"S. Jafar"},{"name":"A. Markopoulou"}],"title":{"text":"Network coding for multiple unicasts: An interference alignment approach"}},{"authors":[{"name":"V. R. Cadambe"},{"name":"S. A. Jafar"}],"title":{"text":"Interference alignment and degrees of freedom of the k-user interference channel"}},{"authors":[{"name":"A. Ramakrishnan"},{"name":"A. Das"},{"name":"H. Maleki"},{"name":"A. Markopoulou"},{"name":"S. Jafar"},{"name":"S. Vishwanath"}],"title":{"text":"Network coding for three unicast sessions: Interference alignment approaches"}},{"authors":[{"name":"J. Han"},{"name":"C. C. Wang"},{"name":"N. B. Shroff"}],"title":{"text":"Analysis of precoding-based intersession network coding and the corresponding 3-unicast interference alignment scheme"}},{"authors":[{"name":"C. Meng"},{"name":"A. Ramakrishnan"},{"name":"A. Markopoulou"},{"name":"S. A. Jafar"}],"title":{"text":"On the feasibility of precoding-based network alignment for three unicast sessions"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569566445.pdf"},"links":[],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S11.T1.3","endtime":"10:50","authors":"Chun Meng, Abinesh Ramakrishnan, Athina Markopoulou, Syed Ali Jafar","date":"1341484200000","papertitle":"On the Feasibility of Precoding-Based Network Alignment for Three Unicast Sessions","starttime":"10:30","session":"S11.T1: Network Coding for Multiple Unicast Sessions","room":"Kresge Rehearsal B (030)","paperid":"1569566445"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
