{"id":"1569565035","paper":{"title":{"text":"Fourier domain representation of non-binary LDPC codes"},"authors":[{"name":"Valentin Savin"}],"abstr":{"text":"Abstract\u2014In this paper we propose a binary representation of non-binary codes, which consists in a q-fold covering of the non- binary graph, where q is the size of the non-binary alphabet. It is shown that this covering graph is actually the underlying graph of the Fourier-domain Belief-Propagation decoding, meaning that the exchanged messages carry information about the bit-nodes of the covering graph. Finally, a new coding scheme is proposed, in which the bits transmitted over the channel correspond to a set of bit-nodes of the Fourier domain representation. The proposed coding scheme allows using the same decoder, regardless of how many and which of the Fourier-domain bit-nodes have been transmitted. This considerably increases the ﬂexibility of the system, without increasing its complexity."},"body":{"text":"LDPC codes [1] are linear block codes deﬁned by sparse parity-check matrices. They can be advantageously represented by bipartite (Tanner) graphs [2] and decoded by means of Bayesian inference. The decoding algorithm, referred to as Belief-Propagation (BP), passes messages along the edges of the graph, in both directions, which are iteratively updated by Bayesian rules. In the non-binary case, each message is a probability distribution vector on the code alphabet, which gives the probabilities of the incident symbol-node being equal to each of its possible values. The complexity, per coded symbol, of the BP decoding scales as O(q 2 ) , where q is the size of the non-binary alphabet [3]. Yet, it can be implemented by using Binary Fourier Transforms (BFT) [4], which allows decreasing the decoding complexity to O(q log(q)). At the cost of a small performance degradation, several low-complexity decoding algorithms have been proposed in the literature, such as the Extended-Min-Sum decoding [5] or the Min- Max decoding [6], which operate in the Log Likelihood Ratio (rather than the probability) domain. The complexity of these algorithms scales as O(αq 2 ) , where α is a constant that can be tuned such as to achieve a desired compromise between complexity and performance.\nThere is however a notable exception with regard to the decoding complexity of non-binary LDPC codes. Over the Binary Erasure Channel, a decoding algorithm with linear complexity, and which was proved to provide the same per- formance as the non-binary BP decoding, has been proposed in [7]. This was achieved by exploiting the extended binary representation of the non-binary code, which consists in a q- fold covering of the non-binary graph.\nThe goal of this paper is to translate the non-binary BP decoding into a decoding algorithm operating on the extended binary representation, regardless of the channel model. It turns\nout that this translation corresponds to the BFT-BP decoding, thus the extended binary representation gives a Fourier domain representation of the non-binary LDPC code. Although it does not allow for any further complexity reduction, this graphical representation should be useful for further analysis of the BFT-BP decoding. Furthermore, based on the Fourier domain representation, we introduce the concept of augmented non-binary LDPC codes , which gives a uniﬁed framework for rate-ﬂexible coding techniques, such as punctured codes [8], [9], extended codes [10], or the the recently introduced multiplicatively repeated non-binary LDPC codes [11]. The proposed coding scheme allows ﬂexible code-rate encoding at the transmitter, without increasing the decoder complexity at the receiver end.\nThe paper is organized as follows. A brief presentation of non-binary LDPC codes is given in Section II. Section III introduces the extended binary representation of non-binary LDPC codes. BP decoding over the non-binary graph and the equivalent decoding over the extended binary representation are discussed in Section IV. In Section V we introduce aug- mented non-binary LDPC codes and demonstrate their beneﬁts in terms of rate-ﬂexibility and error-correction capabilities. Finally, Section VI concludes the paper.\nWe consider non-binary codes deﬁned over the General Linear group GL(p, F 2 ) , of p × p invertible matrices with coefﬁcients in the binary ﬁeld F 2 . The code alphabet is denoted by A = F p 2 , and q = 2 p = |A| denotes the cardinality of A. Elements X ∈ A will be referred to as (non-binary) symbols. Writing X = (x 0 , . . . , x p−1 ) , we shall refer to the row vector (x 0 , . . . , x p−1 ) as the binary image of X. We use the standard transpose notation X T to denote the corresponding column vector. A non-binary code C ⊂ A n , of length n, is deﬁned as the kernel of a linear system with m equations:\nwhere h i,j ∈ GL(p, F 2 ) ∪ {0} are binary p×p matrices, which are either invertible or all-zero. The parity check matrix of the code is given by:\nA particular case is represented by non-binary codes over the ﬁnite ﬁeld with q elements, denoted by F q . In this case, the code alphabet is given by A = F q . However, by ﬁxing\nan isomorphism of vector spaces A F p 2 , each symbol of X ∈ A has a binary image (x 0 , . . . , x p−1 ) ∈ F p 2 . Furthermore, the internal ﬁeld multiplication by an element h ∈ F q deﬁnes a linear application h : A → A, X → h · X, which can be identiﬁed with a binary p×p matrix, which is either invertible (if h = 0) or all-zero (if h = 0).\nThe bipartite graph associated with the non-binary code C, denoted by H, consists of n symbol-nodes and m constraint- nodes 1 representing respectively the n columns and the m rows of the parity check matrix H. A symbol-node j and a constraint-node i are connected by an edge iff h i,j = 0 . Each edge of the graph is further labeled by the corresponding non- zero entry of H. We also denote by H(j) the set of constraint- nodes connected to a given symbol-node j, and by H(i) the set of symbol-nodes connected to a given constraint-node i.\nFor any U, V ∈ A, let U ·V = p−1 i=0 u i v i ( mod 2) be the dot product of their binary images. For any integer k =0, . . . , q −1 , we deﬁne [k] = (k 0 , k 1 , . . . , k p−1 ) ∈ A to be the vector of the binary digits of k, hence k = k 0 + 2k 1 + · · · + 2 p−1 k p−1 . We also denote by:\nDeﬁnition 1: Let X be a symbol of A. The extended binary image of X, denoted by X is deﬁned by\nSetting X = (x 0 , . . . , x p−1 ) and X = (x 1 , x 2 , . . . , x q−1 ) , we ﬁnd that x k = [k] · X = [k] · (x 0 , . . . , x p−1 ) is the linear combination of the binary image of X with coefﬁcients given by the binary digits of k. Hence, the extended binary image of X consists of all the possible linear combinations (except the all-zero one) of its binary image. In particular, it contains the binary image, as x 2 i = x i , for all i = 0, . . . , p − 1.\nExample 2: If p = 3, the extended binary image of X = (1, 0, 1) is given by X = (1, 0, 1) · H 3 = (1, 0, 1, 1, 0, 1, 0) .\nLet S be the dual Hamming code of length q − 1, which is also referred to as the simplex code. Then, S is the vector space spanned by the rows of H p and, according to Deﬁnition 1, it can be seen as the vector space constituted of the extended binary images of all the elements X ∈ A:\nDeﬁnition 3: The extended binary image of a non-binary code C ⊂ A n is deﬁned as the vector space constituted of the binary images of all the codewords (X 1 , . . . , X n ) ∈ C :\nConsequently, C bin is a binary code of length (q − 1)n, and we have:\nIn the sequel, we aim to construct a parity check matrix of the extended binary code C bin , starting from the parity check matrix H of the non-binary code C.\nDeﬁnition 4: The extended binary image of a binary matrix h ∈ M p (F 2 ) is the binary matrix h ∈ M q−1 (F 2 ) deﬁned by:\n(here, [i] · h denotes the usual multiplication between row vector [i] and matrix h)\nProposition 5: The binary matrix h is invertible if and only if its extended binary image h is a permutation matrix.\nProof. For i ∈ {1, . . . , q − 1}, [i] · h is the linear combination of rows of h with coefﬁcients given by the binary digits of i. Therefore, h is invertible iff [i] · h = [i ] · h, for any 1 ≤ i = i ≤ q − 1 , in which case there is a unique 1 entry on each row and column of h.\nProof. We prove the direct implication. Fix k ∈ {1, . . . , q −1} and let l ∈ {1, . . . , q − 1} be the unique integer such that [k] · h = [l] . We have hX T\n= q−1 l =1 h k,l x l = x l . On the other hand,\nwhich proves the direct implication. The reverse implication can be proven in the same manner.\nNow, consider a non-binary code C deﬁned by a parity- check matrix H. The extended binary image of H is the binary matrix H bin ∈ M (q−1)m,(q−1)n (F 2 ) obtained by replacing each entry h i,j of H by its extended binary image h i,j . If (X 1 , . . . , X n ) is a non-binary codeword of C, from the above proposition it follows that H bin X 1 , . . . , X n T = 0 . Therefore:\nC bin ⊂ ker H bin \t (4) We note that this is a strict inclusion. However, the following property holds.\nTheorem 8: Let C be a non-binary code with parity-check matrix H. Then\nProof. The inclusion C bin ⊂ ker H bin ∩ S n follows from equations (3) and (4). Conversely, consider a binary vector in ker H bin ∩ S n . Since it belongs to S n , it is of the form\nX 1 , . . . , X n , for some (X 1 , . . . , X n ) ∈ A n (cf. 2), and we also have H bin X 1 , . . . , X n T = 0 , as it belongs to the kernel of\nH bin . Proposition 7 implies that H(X 1 , . . . , X n ) T = 0 , hence (X 1 , . . . , X n ) ∈ C and therefore X 1 , . . . , X n ∈ C bin .\nLet H be the bipartite graph associated with the non-binary parity-check matrix H (Section II). The extended bipartite graph , denoted by H, is deﬁned as the bipartite graph as- sociated with the parity check matrix H bin . Since the non-zero entries of H are invertible, it follows from Proposition 7 that H is a (q − 1)-fold covering graph of H. There are q − 1 extended bit-nodes in H for each symbol-node of H and q − 1 extended parity check-nodes in H for each constraint- node of H. Moreover, there is a one-to-one correspondance between the neighborhood of an extended bit-node (resp. extended parity-check node) in H and the neighborhood of the corresponding symbol-node (resp. constraint-node) in H. According to the terminology in [12], H may be seen as a protograph and H as a derived graph. Hence, the binary code associated with H is a protograph code. From Theorem 8, it follows that there is a one-to-one correspondance between the non-binary codewords of H and the binary codewords of H that are further constrained by a simplex code (that is, bits lying over the same symbol-node of H must form a simplex codeword).\nNon-binary LDPC codes can be decoded by iterative al- gorithms that pass messages along the edges of the bipartite graph H (in both directions). For the BP decoding, each message is a probability distribution vector over the non-binary alphabet A, which gives the probability of the symbol-node incident to the edge being equal to any of its possible values. These probability distributions are updated at each iteration, until a codeword has been found (all constraint-nodes are veriﬁed) or a maximum number of iterations has been reached.\nOur goal is to propose an equivalent decoding algorithm that exchanges messages along the edges of the extended graph H. To this end, given some probability distribution f on A, we have to determine the probability of an extended bit being equal to 0 or 1. We will prove that the probability distribution on A and the probabilities of extended bits are related by a binary Fourier transform. We recall that the binary Fourier transform of a real-valued function f : A → R is the function BFT(f) : A → R deﬁned by:\nNow, assume that f is a probability distribution function on A, meaning that f(X) ≥ 0, for any X ∈ A, and\nf (X) = 1 . For any k = 1, . . . , q − 1, let e k denote the random variable equal to the k th extended bit of a non-binary symbol drawn randomly from A according to the probability distribution f. We deﬁne:\nProposition 9: The extended likelihood difference vector is equal to the binary Fourier transform of the corresponding probability distribution function, that is:\nProof. Let i ∈ {0, . . . , q − 1} and X = [i] ∈ A. Hence, f i = f (X) . For any k = 0, . . . , q−1, let x k = X ·[k] = [i]·[k] . We have x 0 = 0 and, according to (1), X = (x 1 , . . . , x q−1 ) . Consequently, we have:\nWe consider a non-binary codeword [X] = (X 1 , . . . , X n ) that is sent through a noisy channel, and we denote by [Y ] the channel output. For any j = 1, . . . , n, let α j = (α j (X)) X∈A denote the probability distribution of the j th transmitted sym- bol, conditioned on the observed channel output:\nX∈A the messages exchanged, at iteration , between symbol-node j = 1, . . . , n and constraint-node i = 1, . . . , m.\nThe belief propagation decoding is initialized by setting α (0) i,j = α j , for all i ∈ H(j). Then, for ≥ 1 , exchanged messages are computed as follows:\n\u2022 β ( ) i,j = the probability distribution of X j , conditioned on the event that the i th constraint-node is veriﬁed and on the messages α ( −1) i,j , with j ∈ H(i) \\ {j}. The exact computation of β ( ) i,j messages is omitted, as we shall make no use of it in this paper.\n\u2022 α ( ) i,j = the probability distribution of X j , conditioned on the channel output and on the messages β ( ) i ,j , with i ∈ H(j) \\ {i} . Setting H(j) \\ {i} = {i 1 , . . . , i d } , this probability can be computed by:\nFinally, at each iteration , the a posteriori probability dis- tribution of X j , conditioned on the channel output and on all the messages β ( ) i,j , with i ∈ H(j), is computed by α ( ) j (X) = α j (X) i∈H(j) β ( ) i,j (X) , and a hard decision is taken according to the most likely symbol, deﬁned by X j = argmax X∈A α ( ) j (X) . Decoding algorithm stops if either (X 1 , . . . , X n ) is a codeword or a maximum number of iterations has been reached.\nExtended bit-nodes of the extended graph H will be denoted by (j, l), where j = 1, . . . , n is the index of a symbol-node of H and l = 1, . . . , q − 1 is the index of an extended bit of it. Similarly, extended parity check-nodes of H will be denoted by (i, k), where i = 1, . . . , m is the index of a constraint- node of H and k = 1, . . . , q − 1 is the index of an extended parity check of it. According to Proposition 5, extended nodes (i, k) and (j, l) are connected iff h i,j = 0 and [k]h i,j = [l] . Furthermore, we add some \u201cvirtual\u201d extended nodes to H, with indexes (i, 0) and (j, 0) (otherwise formulated, we allow indexes k and l to take on the zero value). Extended bit-node (j, 0) should be thought as the all-zero linear combination the binary image of the symbol-node j, thus its value will be always equal to zero. If h i,j = 0 , extended nodes (i, 0) and (j, 0) are connected in H, since [0]h i,j = [0] . Now, for k = 0, . . . , q − 1 there is exactly one l = 0, . . . , q − 1 such that [k]h i,j = [l] , therefore any extended parity check-node (i, k) is connected to exactly one extended bit-node (j, l). The unique l with the above property will be denoted in the sequel by l i,j,k , or simply l k if no confusion is possible.\nAs in the previous section, we consider a non-binary codeword [X] = (X 1 , . . . , X n ) that is sent through a noisy channel, and we denote by [Y ] the channel output. Let p j,l denote the likelihood difference of the extended bit-node (j, l), conditioned on the observed channel output:\nthe messages exchanged between the extended bit-node (j, l k ) and the extended parity check-node (i, k) at iteration .\nThe belief propagation decoding is initialized by setting p (0) i,j,l = p j,l , for all i ∈ H(j) and l = 0, . . . , q − 1. Then, for ≥ 1, exchanged messages are computed according to the following rules:\n\u2022 q ( ) i,j,k = the likelihood difference of the extended bit-node (j, l k ) , conditioned on the event that the extended parity\n, with j ∈ H(i) \\ {j} , where l k = l i,j ,k .\n\u2022 p ( ) i,j,l = the likelihood difference of the extended bit-node (j, l) , conditioned on channel output and on the messages q ( ) i ,j,k , with i ∈ H(j) \\ {i} and k such that l i ,j,k = l .\nProof. We have q ( ) i,j,k = Pr (x j,l k = 0) − Pr (x j,l k = 1) = 2 Pr (x j,l k = 0) − 1 , where the above probabilities are con- ditioned on the event that the extended parity check (i, k) is veriﬁed and on the messages p ( −1) i,j ,l\n= 1) . Now, assuming that the extended parity check (i, k) is\nveriﬁed, the extended bit x j,l k is equal to 0 if and only if an even number of extended bits x j ,l k are equal to 1. Using [1, Lemma 4.1] we obtain:\n. Theorem 11: The following equalities hold:\nIt also follows that messages β ( ) i,j , deﬁned in Section IV-A, can actually be computed by using Proposition 10 and The- orem 11. To conclude this section, by decoding non-binary LDPC codes over the extended graph H, we rediscovered the Fourier domain implementation of the non-binary Belief Propagation decoding [4]. For that reason, the extended graph H will be also referred to as the Fourier domain representation of the non-binary LDPC code.\nDeﬁnition 12: An augmented non-binary LDPC code is a pair (C, E), where C is a non-binary LDPC code and E is a set of extended bit-nodes of the corresponding Fourier domain representation. The rate of the augmented non-binary code, denoted by r (C,E) or simply r E if no confusion is possible, is deﬁned by r E = k bin |E| , where k bin is the binary dimension of C and |E| denotes the cardinality of E.\nA communication system using an augmented non-binary LDPC code works as follows. At the transmitter, k bin infor- mation bits (or, equivalently, k bin /p information symbols) are encoded using the non-binary code C. The extended binary image of the encoded codeword is then computed, and the extended bits corresponding to the extended bit-nodes of E are transmitted over the channel. At the receiver end, the received signal can be decoded by using the Fourier-domain\nBP decoding, or any other decoding algorithm for non-binary LDPC codes proposed in the literature [6],[13]. Clearly, the rate of such a coding scheme is given by r E . Depending on the number of transmitted extended-bits, r E can be either greater or less than the rate of the mother non-binary code C. A signiﬁcant advantage of augmented codes is that they allow using the same decoder, regardless of how many and which extended bits have been transmitted.\nAugmenting patterns for non-binary LDPC codes can be optimized by density evolution, in a similar manner to the technique proposed in [9] for optimizing puncturing patterns for non-binary LDPC codes. Due to space limitation, this optimization will be presented in an extended version of this paper. However, we include below the asymptotic thresholds over the Binary Input AWGN channel, of augmented regular (d v = 2, d c = 4) LDPC codes over the ﬁnite ﬁeld F 64 . Density evolution of augmented non-binary LDPC codes has been approximated by Monte-Carlo simulation, following the method introduced in [9], which has been proven to provide accurate (very close) and precise (small variance) estimates of the asymptotic thresholds.\nWe denote by E j (resp. k j = |E j | ) the set (resp. the number) of extended bits transmitted for symbol-node j ∈ {1, . . . , n}. Given a target augmented rate r E , we randomly choose an augmenting set E, with cardinality |E| = k bin /r E , such that:\n\u2022 k j = |E| n (∀j) , if the above ratio is an integer, otherwise k j is equal either to |E| n or |E| n , with average value |E| n .\n\u2022 The set E j = {(j, l 1 ), . . . , (j, l k j )} is chosen so that to maximize the minimum distance of H E j = column [l 1 ] T , . . . , [l k j ] T , which is the submatrix of the Hamming matrix H p , determined by the columns corre- sponding to the k j extended bits in E j .\nUnder these assumptions, the asymptotic thresholds of aug- mented regular (d v = 2, d c = 4) LDPC codes over F 64 are presented in Figure 1. For comparison purposes, we have also plotted the asymptotic thresholds of semi-regular non- binary LDPC codes with constant symbol-node degree d v = 2 : according to the coding rate r speciﬁed on the abscissa, the average check-node degree is given by ¯ d c = d v 1−r = 2 1−r , and any check-node is of degree either ¯ d c or ¯ d c . It can be seen that augmented non-binary LDPC codes outperform semi-regular codes for small coding rates (r < 0.3).\nTo explain this, we note that for smaller and smaller coding rates, the best codes are deﬁned by graphs with increasingly lower average node-degree. Figure 1 suggests that for small coding rates, the average symbol-node degree should be further decreased below d v = 2 . However, by doing so, the graph would necessarily contain constraint-nodes of degree 2. Such a constraint node, say i, corresponds to an equation h i,j 1 X j 1 + h i,j 2 X j 2 = 0 ⇔ X j 2 = h −1 i,j\nh i,j 1 X j 1 , in which case the binary image of X j 2 is constituted of p bits from the extended binary of X j 1 . Put differently, for small rates, good codes are necessarily obtained by augmenting a mother code of higher rate. We also note that the results presented in this section can be further improved by appropriate optimization techniques.\nIn this paper, we proposed a graphical representation of the Fourier-domain BP decoding for non-binary LDPC codes. We showed that the messages exchanged within the BFT- BP decoding carry information about the bit-nodes of a q- fold covering of the non-binary graph. This representation can be advantageously used to deﬁne rate-ﬂexible coding schemes, namely augmented non-binary LDPC codes, which were proven to outperform semi-regular non-binary LDPC codes for small coding rates."},"refs":[{"authors":[{"name":"R. G. Gallage"},{"name":"T. Pres"}],"title":{"text":"Low Density Parity Check Codes, M"}},{"authors":[{"name":"R. M. Tanner"}],"title":{"text":"A recursive approach to low complexity codes"}},{"authors":[{"name":"N. Wiber"},{"name":"D. thesi"}],"title":{"text":"Codes and decoding on general graphs, Ph"}},{"authors":[{"name":"C. Dave"},{"name":"D. thesi"}],"title":{"text":"M"}},{"authors":[{"name":"D. Declercq"},{"name":"M. Fossorier"}],"title":{"text":"Extended min-sum algorithm for decoding LDPC codes over GF(q)"}},{"authors":[{"name":"V. Savin"}],"title":{"text":"Min-Max decoding for non binary LDPC codes"}},{"authors":[{"name":"V. Savin"}],"title":{"text":"Binary linear-time erasure decoding for non binary LDPC codes"}},{"authors":[{"name":"D. Klinc"},{"name":"J. Ha"}],"title":{"text":"On rate-adaptability of non- binary LDPC codes"}},{"authors":[{"name":"M. Gorgoglione"},{"name":"V. Savin"},{"name":"D. Declercq"}],"title":{"text":"Optimized puncturing distributions for irregular non-binary ldpc codes"}},{"authors":[{"name":"L. Pham Sy"},{"name":"V. Savin"},{"name":"D. Declercq"}],"title":{"text":"Extended non-binary low- density parity-check codes over erasure channels"}},{"authors":[{"name":"K. Kasai"},{"name":"D. Declercq"},{"name":"C. Poulliat"},{"name":"K. Sakaniwa"}],"title":{"text":"Multiplicatively repeated non-binary LDPC codes"}},{"authors":[{"name":"J. Thorpe"}],"title":{"text":"Low-density parity-check (LDPC) codes constructed from protographs"}},{"authors":[{"name":"D. Declercq"},{"name":"M. Fossorier"}],"title":{"text":"Decoding algorithms for nonbinary LDPC codes over GF(q)"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569565035.pdf"},"links":[],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S14.T5.4","endtime":"18:00","authors":"Valentin Savin","date":"1341510000000","papertitle":"Fourier domain representation of non-binary LDPC codes","starttime":"17:40","session":"S14.T5: New Constructions of LDPC Codes","room":"Kresge Little Theatre (035)","paperid":"1569565035"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
