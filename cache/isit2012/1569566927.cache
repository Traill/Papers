{"id":"1569566927","paper":{"title":{"text":"Distributed Rateless Coding with Cooperative Sources"},"authors":[{"name":"Mahyar Shirvanimoghaddam"},{"name":"Yonghui Li"},{"name":"Branka Vucetic"}],"abstr":{"text":"Abstract\u2014In this paper, we propose a distributed rateless coding (DRC) scheme for a two-user cooperative system. In DRC, the overall transmission is divided into two phases, a broadcast phase and a cooperation phase. In the broadcast phase, each user keeps transmitting its rateless coded symbols to the other user and the destination until its message has been successfully decoded by the destination or the other user. In the cooperation phase, each user encodes both users\u2019 messages by using a rateless code and transmits them to the destination. A linear programming optimization problem is then formulated to ﬁnd the optimal degree distribution for the proposed distributed rateless code. The performance of the proposed code is analyzed and validated by simulations.\nIndex Terms\u2014distributed coding, rateless code, LT coding, erasure channel."},"body":{"text":"Rateless code is a class of powerful error correction codes. They are rateless in the sense that they are able to generate an unlimited number of parity symbols. The design process of rateless codes is mainly comprised of determining an appropriate degree distribution [1]. Recently, rateless codes have been applied to coded cooperation [2] to further improve transmission efﬁciency and performance.\nIn [3], a rateless coded cooperation scheme has been proposed for a two-user multiple access channel (MAC). In this scheme, one user helps to forward other user\u2019s message only after its message has been successfully received by the destination and it has completely decoded other user\u2019s message. In [4], a coded cooperation scheme based on rateless codes was designed for multi-user MACs, where each user cannot start the cooperation process until it has fully recovered other users\u2019 messages. Its performance has been investigated by simulations, but no analysis and degree optimization has been carried out. Puducheri et. al. [5] proposed a distributed rateless coding scheme, where an intermediate relay node combines all incoming rateless coded symbols from sources. The degree distribution of rateless codes used at sources was designed in a way such that the combined symbols at the relay follow the standard Robust Soliton degree (RSD) distribution. The idea is further extended in [6], where incoming messages from sources are encoded using a degree distribution which is different from that used at sources, and suboptimal degree distributions have been obtained for both the source and relay node.\nIn [7], a distributed rateless code with an unequal error protection (UEP) property has been proposed for the same system model as in [5]. In fact, different data importance levels necessitate the design of distributed rateless codes with different error probabilities for different sources. Various block lengths and degree distributions have been considered at different source nodes. Degree distributions in [7] have been optimized using a multi-objective optimization approach. However, cooperation between the users has not been consid- ered.\nIn this paper a distributed rateless coding (DRC) scheme is proposed for a two-user MAC. In the proposed scheme, each user keeps transmitting their rateless coded symbols until its message can be completely decoded by the other user or an acknowledgment is received from the destination. After successful recovery of one user\u2019s message by the other user but not by the destination, cooperation process starts. Each user encodes both users\u2019 message by a rateless code and transmit them to the destination until both users\u2019 messages are recovered by the destination. The proposed scheme is analyzed using the AND-OR tree analysis [8] and degree distributions are optimized by using a linear programming optimization approach. Simulation results show that the proposed scheme outperforms the non-cooperative rateless coded scheme where each user\u2019s message is transmitted only by itself without cooperation with the other user. When the erasure probability of the inter-user channel is low, the proposed scheme performs very close to the perfect-cooperation scheme where each user\u2019s message is assumed to be known at the other user.\nThe rest of the paper is organized as follows. In Section II, the system model and the DRC scheme is described. AND-OR tree analysis of the DRC scheme is provided in Section III. In Section IV, a suboptimum optimization problem is deﬁned to ﬁnd an appropriate degree distribution. Simulation results are provided in Section V, followed by concluding remarks in Section VI.\nIn this paper, we consider a two-user cooperative multiple access channel, where two users, namely S 1 and S 2 , want to transmit their information symbols to the destination cooper- atively. The channel between each pair of nodes is considered\nto be an erasure channel with a speciﬁc erasure probability (Fig. 1).\nEach user uses an LT code [9] to encode its information messages. LT encoding process contains two important steps; ﬁrst, an integer d, called degree, is obtained from a predeﬁned degree distribution. Then, d distinct information symbols are randomly selected and XORed to generate a coded symbol. Let Ω(x) = D i=1 Ω i x i be the generator polynomial of the degree distribution, where Ω i denotes the probability that a coded symbol has degree i, D is the maximum degree, and\nΩ i = 1. The LT encoding process can be described by a bipartite graph, where the variable and check nodes represent message symbols and LT coded symbols, respectively [1].\nThe overall transmission of the DRC scheme is divided into two phases, a broadcast phase and a cooperative phase. In the broadcast phase, each user generates coded symbols from its own message symbols using degree distribution Ω(x) and keeps transmitting them to the other user and the destination until it receives an acknowledgement from either the other user or the destination. If both users\u2019 messages are successfully decoded at the destination before they are recovered by the other user, the destination will send an acknowledgment to both users. Then the sources start broadcasting new messages. Otherwise, the user that has successfully recovered the other user\u2019s message starts the cooperation phase and encodes both users\u2019 messages using an LT code with degree distribution Φ(x) and two users sequentially transmits coded symbols to the destination. When the destination successfully decodes both users\u2019 messages, it sends an acknowledgement to both users. Then each user starts a new message transmission.\nThroughout the paper the following notations are used. k is the message length of each user. N 1 and N 2 are total numbers of the received coded symbols from S 1 and S 2 , respectively, at the destination in the broadcast phase, and N 3 is the total number of the coded symbols received in the cooperation phase from both users. Also, Ω \u2032 (x) denotes the derivative of Ω(x).\nIn [1, 7], it was shown that iterative belief propagation decoding of rateless codes can be mapped to an AND-OR tree to analyze the recovery probability of an information symbol. The details of such mapping can be found in [7, 8]. More speciﬁcally, in the belief propagation decoding algorithm, at each iteration, a variable node sends a symbol \u201d1\u201d to its neighboring check nodes if and only if it has received at least one message with value \u201d1\u201d from its other neighboring check nodes. Thus variable nodes perform the logical OR operation. Similarly, a check node passes a symbol \u201d0\u201d to its neighboring\nvariable nodes if and only if it has received at least one message with value \u201d0\u201d from its neighboring variable nodes. Thus, check nodes perform the logical AND operation [7]. Since coded symbols received at the destination are generated from both user\u2019s information symbols, three types of LT coded symbols exist at the destination. In the bipartite graph, coded symbols that are only connected to S 1 ( S 2 )\u2019s information symbols are referred to as Type-1 (Type-2) coded symbols and those connected to both users\u2019 information symbols are called as Type-3 coded symbols.\nTherefore, in the AND-OR trees of the DRC scheme, three types of coded symbols are mapped to Type- C 1 , Type- C 2 , and Type- C 3 AND nodes, and information symbols of S 1 and S 2 are mapped to Type- X 1 and Type- X 2 OR nodes, respectively. We consider two AND-OR trees, T l,1 and T l,2 , with depth 2l (Fig. 2), such that the root of T l,1 is a Type- X 1 AND node and the root of T l,2 is a Type- X 2 AND node. Both trees have Type- X 1 and Type- X 2 OR nodes, and Type- C 1 , Type- C 2 , and Type- C 3 AND nodes, where OR nodes are located at depth 0, 2, ..., 2l and AND nodes are located at depth 1, 3, ..., 2l − 1. Furthermore, AND nodes at depth 2i − 1 has children among OR nodes at depth 2i, and children of OR nodes at depth 2j are from AND nodes at depth 2j + 1.\nIn the AND-OR tree, Type- C 1 (Type- C 2 ) AND nodes are only connected to Type- X 1 (Type- X 2 ) OR nodes. A Type- X i OR node at depth 2l is independently assigned a value of 0 or 1, with the probability of p 0,i = 1. The OR-nodes and AND- nodes, which do not have children, are assigned a value of \u201d0\u201d and \u201d1\u201d, respectively. By treating the tree as a Boolean circuit, we can derive the following lemma for the error probability of the DRC scheme using AND-OR tree analysis (see the appendix for the proof).\nLemma 1: Let p l,m , m = 1, 2, be the probability that an information symbol of S m is not recovered after l iterations, then we have:\nwhere p 0,m = 1, δ j (x) = A i=0 δ j,i x i , j ∈ {1, 2, 3}, δ m,i is the probability that a Type- X m OR node has i children among\nType- C m AND nodes, δ 3,i is the probability that a Type- X 1 or Type- X 2 OR node has i children among Type-C 3 AND nodes, β m,i is the probability that a Type- C m AND node is connected to i Type-X m OR nodes as its children, and β 3,i,j is the probability that a Type- C 3 AND node is connected to i Type-X 1 and j Type-X 2 OR nodes as its children. These probabilities can be calculated as follows:\nk i\nk j\nwhere µ 1 = D d=1 dΩ d and µ 2 = D d=1 dΦ d are average degrees of degree distribution functions, Ω(x) and Φ(x), which are the degree distributions used at the broadcast and cooperation phase of the DRC scheme..\nFrom Lemma 1, we can deﬁne an optimization problem to minimize the error probability of S 1 and S 2 at a speciﬁc decoding iteration l, denoted by p l,1 and p l,2 , respectively. However, to ﬁnd the optimum degree distribution, N 1 , N 2 , and N 3 need to be known beforehand. Since, these values depend on channel erasure probabilities, they cannot be found without the knowledge of the channel erasure probability. As a result, a sub-optimum degree distribution may be used.\nAccording to [1], in order to ensure the successful recovery of 2k information symbols with a minimum overhead, the derivative of Φ(x) should satisfy the following condition,\nwhere r 0 , δ and c are constant values. This inequality ensures that the iterative belief propagation algorithm can proceed by keeping the number of degree-one coded symbols larger than a speciﬁc value at each iteration [1].\nIf the receiver already knows one user\u2019s information sym- bols, it can remove all the edges connected to the known symbols in the tanner graph. The probability that a coded symbol has a degree d can be calculated as follows:\nk w\nk d\nwhich arises form the fact that a coded symbol of degree d is actually of degree d + w with probability Φ d+w be- fore removing all edges connected to the known symbols. Since d + w information symbols are selected uniformly and randomly from 2k information symbols to generate a coded symbol in the cooperation phase, then (6) is straightforward. Furthermore, Eq. (7) shows that Φ ∗ 0 = 0, which means after removing all the edges connected to the known information symbols, some coded symbols may not have connections to any information symbol. Thus these coded symbols should be removed from the tanner graph and the degree distribution of the remaining coded symbols will be:\nSimilar to the optimization problem in [1], for given r 1 and δ, the derivative of Φ (1) (x) = D d=1 Φ (1) d x d also needs to satisfy the following condition for x ∈ [0, 1 − δ]:\nUsing (7) and (8), (9) can be rewritten in terms of Φ(x) as in (13). It is also important to ﬁnd the degree distribution with minimum average degree in order to minimize the encoding complexity. So, the optimization problem can be formulated as follows:\nk w\nk d\nk w 2k w\nIn fact, (12)-(11), and the objective function are linear in Φ(x), so the optimization problem can be solved using a linear programming algorithm. For k = 10000 and δ = 0.01, the optimized degree distribution obtained by this method is\ngiven by Φ(x) = 0.01x + 0.4328x 2 + 0.2217x 3 + 0.0051x 5 + 0.1524x 6 + 0.0604x 18 + 0.066x 19 + 0.0514x 48 , r 0 = 0.9091 and r 1 = 0.7844.\nFurthermore, in the broadcast phase, each user only encodes its own information symbols, and so we ﬁnd the degree distribution which guarantees a successful decoding with a minimum overhead. So, in the broadcast phase, we use the same optimization problem as in [1]. The obtained degree distribution for δ = 0.01 and k = 10000 is Ω(x) = 0.01x+0.487x 2 +0.1654x 3 +0.1055x 4 +0.12x 7 +0.0192x 8 + 0.0785x 24 + 0.0144x 25 .\nFig. 3 shows the bit error rate (BER) versus the number of coded symbols divided by the number of information symbols for LT codes with different degree distributions Ω(x), Φ(x), and Φ (1) (x), that are obtained by the optimization technique provided in this section. It can be noted from Fig. 3 that 2k information symbols can be recovered by receiving at least 1.12 × 2k coded symbols generated by a LT code with Φ(x). Also k information symbols can be completely decoded with a high probability by using a LT code with Φ (1) (x) and receiving at least 1.23k coded symbols.\nWe consider that the channel between the users is reciprocal, i.e., e 12 = e 21 . The proposed scheme is compared with No-cooperation and Perfect-cooperation schemes. In the No- cooperation scheme, each user only transmits rateless coded symbols from its own message. In the Perfect-cooperation scheme, each user\u2019s message is assumed to be perfectly known to the other user, so each user generates coded symbols from both users\u2019 messages.\nIn the No-cooperation scheme, S 1 \u2019s information symbols will be decoded as soon as the destination receives at least k(1 + δ k ) coded symbols, where δ k is the average overhead required to ensure a successful decoding at the destination. Since the symbols transmitted from S 1 may be erased, S 1 should transmit at least k(1 + δ k )/(1 − e 1 ) coded symbols to ensure that the destination receives an adequate number of\ncoded symbols to perform a successful decoding. Similarly, S 2 should send k(1 + δ k )/(1 − e 2 ) coded symbols. If e 1 = e 2 = e, then, the users should send overall 2k(1 + δ k )/(1 − e) coded symbols to the destination to guarantee that both users\u2019 messages can be decoded successfully.\nIn the Perfect-cooperation scheme, the destination needs to receive at least 2k(1 + δ 2k ) coded symbols in order to fully decode both users\u2019 messages. Thus, users should send overall 2k(1 + δ 2k )/(1 − e) coded symbols (e 1 = e 2 = e). Since, δ k and δ 2k go to zero when k goes to inﬁnity, the total number of symbols required for a successful transmission in both No- cooperation and Perfect-cooperation schemes will be the same when k is relatively large. Therefore, in the symmetric case, for a relatively large k, the cooperation between the users cannot improve error performance at the destination.\nFig. 4 shows the ratio of the total number of transmitted symbols ( N ) and that of information symbols (K = 2k) versus different erasure probabilities of the inter-user channel. Two Scenarios, namely Scenario 1 and Scenario 2, are considered in simulations. In Scenario 1, e 1 = 0.2, e 2 = 0.8, and in Scenario 2, e 1 = 0.3, e 2 = 0.6. As can be seen in Fig 4, the\nDRC scheme outperforms the No-cooperation scheme when the erasure probability of the inter-user channel is lower than that of the channel between the users and the destination. Also, for the very small erasure probability of the inter-user channel, the DRC scheme performs very close to the Perfect- cooperation scheme. Analytical results obtained from lemma 1 have been also provided in Fig. 4 and an excellent agreement with the simulation results has been demonstrated.\nFig. 5 shows the number of coded symbols ( M ) that should be received from each user to guarantee its successful receipt at the destination. It can be seen from the ﬁgure that when S 1 has better channel to the destination, it needs to send more coded symbols compared to S 2 . This is because the proposed scheme aims to jointly decode both users\u2019 messages with min- imum overhead at the destination, instead of decoding them separately. Hence, compared to the No-cooperation scheme, more coded symbols from S 1 are required at the destination to decode S 1 \u2019s message. Although a large overhead is required to decode S 1 \u2019s message, the overall overhead required for decoding both users\u2019 message is considerable lower compared to the No-cooperation scheme.\nA distributed rateless coding scheme for a two-user cooper- ative access network has been proposed in this paper. The proposed scheme has been analyzed by the AND-OR tree method and a suboptimum linear programming optimization approach was used to ﬁnd good degree distributions in the broadcast and cooperative phases. Simulation results have conﬁrmed that the proposed scheme outperforms the No- cooperation scheme in various simulation setups.\nThe proof of (1) is straightforward and is similar to the proof of [5, lemma1] and is not provided here due to space limitation. We just prove the rest of the lemma. The proof is provided only for T l,1 , and due to the symmetry, similar results can be proven for T l,2 . Since a degree- d coded symbol in the cooperation phase is generated from both users\u2019 information symbols based on degree distribution Φ(x), the probability that this symbol is not connected to any information symbol of S 2 in the tanner graph is 2 −d . Therefore, the probability that a coded symbol is not connected to any information symbol of S 2 is Φ(0.5) = B d=1 Φ d 2 −d . Hence, the number of Type- C 1 AND nodes is actually N 1 + N 3 Φ(0.5), where N 1 of them have been generated in the broadcast phase based on Ω(x) and N 3 Φ(0.5) of them have been generated in the cooperation phase.\nAdditionally, β 1,i is the probability that a randomly chosen edge in T l,1 is connected to a Type- C 1 AND node with i children among Type- X 1 OR nodes and it is also equal to the probability that this edge is connected to a Type- C 1 AND node of degree i + 1. So N 1 (i + 1)Ω i+1 out of N 1 µ 1 edges connected to Type- C 1 AND nodes are actually connected to degree-( i + 1) Type-C 1 AND nodes. Similarly, N 3 Φ(0.5)(i +\n1)Φ i+1 edges are connected to Type- C 1 AND nodes of degree i + 1. Therefore, we have β 1,i = \t N 1 N\nSimilarly, β 3,i,j is the probability that a randomly chosen edge in T l,1 is connected to a Type- C 3 AND node with i and j children among Type- X 1 and Type- X 2 OR nodes, respectively. This is the probability that the edge is connected to a degree- i + j + 1 Type-C 3 AND node which have i Type-X 1 and j Type- X 2 OR nodes of children. Since information symbols from both users are selected uniformly and randomly in the encoding process during the cooperation phase, the probability that a coded symbol of degree i + j + 1 in the cooperation phase is connected to i and j information symbols of S 1 and S 2 , respectively is k i k j / 2k i + j . Moreover, the total number of edges connected to Type- C 3 AND nodes is N 3 µ 2 , and the total number of edges connected to degree i + j + 1 Type- C 3 AND nodes is N 3 (i + j + 1)Φ i+j+1 . Hence, β 3,i,j =\nk i\nMoreover, δ 1,i is the probability that a Type- X 1 OR node connected to a randomly chosen edge is connected to i Type- C 1 AND nodes. The total number of edges connected to Type- X 1 OR nodes is N 1T = N 1 µ 1 + N 3 Φ(0.5)µ 2 and the probability that i of these edges are connected to a speciﬁc Type- X 1 OR node is\ni ( 1 k ) i (1 − 1 k ) N 1 T −i which can be approximated by poisson distribution as e −N 1 T /k (N 1 T /k) i i! . We deﬁne α 1 = N 1T /k and δ 1 (x) = i e −α 1 α i 1 i! x i = e α 1 (x−1) . Similar results can be found for δ 3 where the total number of edges connected to Type- C 3 AND nodes is N 3T = N 3 (1 − 2Φ(0.5)) and α 3 = N 3 /2k. Then, we have δ 3 (x) = e α 3 (x−1) . This completes the proof."},"refs":[{"authors":[{"name":"A. Shokrollahi"}],"title":{"text":"Raptor codes"}},{"authors":[{"name":"T. Hunter"},{"name":"A. Nosratinia"}],"title":{"text":"Diversity through coded cooperation"}},{"authors":[{"name":"W. Chen"},{"name":"W. Chen"}],"title":{"text":"A new rateless coded cooperation scheme for multiple access channels"}},{"authors":[{"name":"M. Uppal"},{"name":"Z. Yang"},{"name":"A. Host-Madsen"},{"name":"Z. Xiong"}],"title":{"text":"Cooperation in the low power regime for the MAC using multiplexed rateless codes"}},{"authors":[{"name":"S. Puducheri"},{"name":"J. Kliewer"},{"name":"T. Fuja"}],"title":{"text":"The design and performance of distributed LT codes"}},{"authors":[{"name":"D. Sejdinovic"},{"name":"R. Piechocki"},{"name":"A. Doufexi"}],"title":{"text":"AND-OR tree analysis of distributed LT codes"}},{"authors":[{"name":"A. Talari"},{"name":"N. Rahnavard"}],"title":{"text":"Distributed rateless codes with UEP property"}},{"authors":[{"name":"M. G. Luby"},{"name":"M. Mitzenmacher"},{"name":"M. A. Shokrollahi"}],"title":{"text":"Analysis of random processes via and-or tree evaluation"}},{"authors":[{"name":"M. Luby"}],"title":{"text":"LT codes"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569566927.pdf"},"links":[{"id":"1569566567","weight":8},{"id":"1569566485","weight":4},{"id":"1569565883","weight":4},{"id":"1569566875","weight":4},{"id":"1569566683","weight":8},{"id":"1569565091","weight":30},{"id":"1569566571","weight":4},{"id":"1569564469","weight":4},{"id":"1569565837","weight":4},{"id":"1569566319","weight":4},{"id":"1569566157","weight":4},{"id":"1569561679","weight":4},{"id":"1569564311","weight":4},{"id":"1569566679","weight":13},{"id":"1569566617","weight":8},{"id":"1569555999","weight":8},{"id":"1569566643","weight":4},{"id":"1569558901","weight":4},{"id":"1569564209","weight":4},{"id":"1569566425","weight":4},{"id":"1569564333","weight":4},{"id":"1569566357","weight":4},{"id":"1569565279","weight":13},{"id":"1569566003","weight":13},{"id":"1569565185","weight":4},{"id":"1569566223","weight":4},{"id":"1569565469","weight":8},{"id":"1569565357","weight":4},{"id":"1569565909","weight":4},{"id":"1569566481","weight":4},{"id":"1569565155","weight":4},{"id":"1569566805","weight":8},{"id":"1569566929","weight":4},{"id":"1569566779","weight":13},{"id":"1569566261","weight":4},{"id":"1569565093","weight":17},{"id":"1569565661","weight":4},{"id":"1569564919","weight":4},{"id":"1569566253","weight":4},{"id":"1569565353","weight":8},{"id":"1569564291","weight":4},{"id":"1569566547","weight":8},{"id":"1569565541","weight":4},{"id":"1569564437","weight":4},{"id":"1569565457","weight":4},{"id":"1569561185","weight":4},{"id":"1569566397","weight":13},{"id":"1569565039","weight":4},{"id":"1569566601","weight":4},{"id":"1569566147","weight":4},{"id":"1569560785","weight":4},{"id":"1569565561","weight":8},{"id":"1569566847","weight":4},{"id":"1569566583","weight":4},{"id":"1569564253","weight":4},{"id":"1569564257","weight":4},{"id":"1569564141","weight":4},{"id":"1569566973","weight":4},{"id":"1569559233","weight":8}],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S3.T6.3","endtime":"15:40","authors":"Mahyar Shirvanimoghaddam, Yonghui Li, Branka Vucetic","date":"1341242400000","papertitle":"Distributed Rateless Coding with Cooperative Sources","starttime":"15:20","session":"S3.T6: Codes and Their Applications","room":"Kresge Rehearsal A (033)","paperid":"1569566927"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
