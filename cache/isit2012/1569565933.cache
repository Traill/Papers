{"id":"1569565933","paper":{"title":{"text":"On a Class of Three-Weight Codes with Cryptographic Applications"},"authors":[{"name":"Zihui Liu"},{"name":"Xin-Wen Wu"}],"abstr":{"text":"Abstract\u2014Linear codes with good algebraic structures have been used in a number of cryptographic or information-security applications, such as wire-tap channels of type II and secret sharing schemes. For a code-based secret sharing scheme, the problem of determining the minimal access sets is reduced to ﬁnding the minimal codewords of the dual code. It is well known that the latter problem is a hard problem for an arbitrary linear code. Constant weight codes and two-weight codes have been studied in the literature, for their applications to secret sharing schemes. In this paper, we study a class of three-weight codes. Making use of the ﬁnite projective geometry, we will give a sufﬁcient and necessary condition for a linear code to be a three- weight code. The geometric approach that we will establish also provides a convenient method to construct three-weight codes. More importantly, we will determine the minimal codewords of a three-weight code, making use of the geometric approach."},"body":{"text":"Linear codes with good Hamming weight properties have been used in many cryptographic or information-security ar- eas, for examples, wire-tap channels of type II [7] and secret sharing schemes [4], [8], [10]. For a secret sharing scheme based on a linear code C, the problem of determining the minimal access sets is reduced to the problem of ﬁnding the minimal codewords of the dual code C ⊥ . However, determin- ing minimal codewords is a hard problem for an arbitrary linear code (see [1], for example). Constant weight codes and two-weight codes have been studied [10], for their applications to secret sharing schemes. On the other hand, only a few classes of linear codes for which minimal codewords can be completely determined have been known [4], [10].\nMotivated by the work [5], in this paper we investigate a class of three-weight codes, and study their applications to wire-tap channels of type II as well as secret sharing schemes. Making use of the ﬁnite projective geometry, we ﬁrst establish a set of tools to characterize the Hamming weights of codewords of a linear code. We then give a sufﬁcient and necessary condition for a linear code to be a three-weight code. Our geometric approach also provides a convenient method to construct three-weight codes. More importantly, making use of the geometric approach, we will determine the minimal codewords of a three-weight code.\nThe rest of the paper is organized as follows. In Section II a deﬁnition for relative three-weight codes and the geometric\napproach will be given. In Section III, we will give a sufﬁcient and necessary condition for a linear code to be a three-weight code, and present the geometric construction of three-weight codes. In Section IV, we will present the applications of three- weight codes, and will determine the minimal codewords of a three-weight code. Concluding remarks will be given in Section V.\nLet GF (q) be a ﬁnite ﬁeld with q elements. A k- dimensional linear code, C, of length n is a k-dimensional linear subspace of GF (q) n . Let D be any subcode of C. Deﬁne C\\D = {c | c ∈ C, c /∈ D}. Note that C\\D is a block code, but not necessarily a linear code.\nSuppose C is a k-dimensional linear code over GF (q). Let C 1 be a k 1 -dimensional linear subcode, and C 2 be a k 2 - dimensional linear subcode, satisfying C 1 ⊂ C 2 . We give the following deﬁnition.\nDeﬁnition 2.1: C is called a relative three-weight code with respect to C 1 and C 2 , provided that C 1 \\{0}, C 2 \\C 1 and C\\C 2 are all constant weight codes. If these three constant weight codes have weights d 1 , d 2 and d, respectively, we denote the relative three-weight code C by C(d 1 , d 2 , d).\nWe can similarly study relative two-weight codes. Let D be a subcode of C. We call C a relative two-weight code with respect to D, provided that D\\{0} and C\\D are both constant weight codes.\nRelative three-weight codes are a generalization for both constant weight codes and relative two-weight codes deﬁned above. In fact, if d 1 = d 2 = d, then C(d 1 , d 2 , d) is a constant weight code. If d 1 = d 2 , then C is a relative two-weight code with respect to C 2 . While if d 2 = d, then C is a relative two- weight code with respect to C 1 . In a later version of this paper [6], we will also present results on relative two-weight codes.\nFinite projective geometry has been extensively applied in coding theory [2], [3], [9]. In this paper, we will study relative three-weight codes using ﬁnite projective geometry. Consider C, a k-dimensional linear code over GF (q). Let C 1 be a k 1 - dimensional linear subcode, and C 2 be a k 2 -dimensional linear subcode, satisfying C 1 ⊂ C 2 . Let G be a generator matrix of C.\nWithout loss of generality, we assume that G does not contain any all-zero column. (Note that this assumption does not affect the weight of any codeword.) We introduce a set of tools for studying C as follows.\nLet P G(k − 1, q) be a (k − 1)-dimensional projective space over GF (q). Then the columns of G, which is a k ×n matrix over GF (q), can be viewed as points of P G(k − 1, q). We thus obtain a projective multiset (or a value assignment [3]), which is a map m from P G(k −1, q) to the set of nonnegative integers, i.e.,\nwhere for any point p ∈ P G(k − 1, q), m(p) is deﬁned as the number of occurence of p as a column in the matrix G [3]. We call m(p) the value (or multiplicity ) of p. This map can be extended to any subset W ⊂ P G(k − 1, q) by deﬁning\nLet p = (u 1 , · · · u k ) be a vector of GF (q) k or a projective point of P G(k − 1, q). For any L ⊂ {1, 2 , · · · k}, we denote P L (p) = (v 1 , · · · v k ), where v i = u i if i ∈ L, and v i = 0 if i / ∈ L. For a subset W ⊂ P G(k − 1, q), deﬁne P L (W ) = {P L (p) | p ∈ W }. It is easy to see that if W is a projective subspace of P G(k − 1, q), so is P L (W ).\nFor a projective subspace V of P G(k − 1, q), and integers l = 1, . . . , k − 1, we deﬁne\nthat is, V l is the set of points of V which are all 0 in the ﬁrst l coordinates. Note that V l may be an empty set. If V l ̸= ∅, then it is a projective subspace of V . For nonnegative integers ξ, η, and γ, we denote by P ξ ηγ a projective subspace V of P G(k − 1, q), satisfying dim(P L 1 (V )) = ξ −1, dim(P L 2 (V k 1 )) = η −1 and dim(V k 2 ) = γ − 1, where k 1 = dim( C 1 ), k 2 = dim( C 2 ), L 1 = {1, ..., k 1 } and L 2 = {k 1 + 1, ...k 2 }. Here, a space of dimension 0 is a set consisting of a single point; and the empty set is viewed as a projective space of dimension −1. It is easy to see that dim(P ξ ηγ ) = ξ +η+γ −1. We give several examples as follows.\nExample 2.1: P 1 00 stands for points p ∈ P G(k − 1, q) satisfying P L 1 (p) ̸= 0; P 0 10 stands for points p satisfying P L 1 (p) = 0 and P L 2 (p) ̸= 0; and P 0 01 stands for points p satisfying P L 1 (p) = 0 and P L 2 (p) = 0.\nWe assume that the effective length of C (i.e., the number of nonzero columns of any generator matrix of C) is n in the sequel. The support of a codeword c ∈ C, denoted by supp(c), is deﬁned as the set of the nonzero coordinate positions. We denote by w(c) the (Hamming) weight of the codeword c, that is, w(c) = |supp(c)|, the number of nonzero coordinates.\nWe are now ready to give a useful lemma, which determines the weight of a codeword of c ∈ C by the value of a projective subspace of P G(k − 1, q).\nLemma 2.1: There is a one to one correspondence between the nonzero codewords c 1 ∈ C 1 , c 2 ∈ (C 2 \\C 1 ) and c ∈ ( C\\C 2 ) and the subspaces P k 1 −1 (k\n−k 1 )(k −k 2 −1) , respectively, such that if c 1 , c 2 and c correspond to P k 1 −1 (k\n−k 1 )(k −k 2 −1) , respectively, then m(P G(k − 1, q)) = n, n − w(c 1 ) = m(P k 1 −1 (k\nProof: The ﬁrst equation is obvious, as every column of G must be a point of P G(k − 1, q), where m(·) is deﬁned with G as in the last section. The last three equations in the lemma can be proved similarly. Let us give a detailed proof for the third equation. Assume c 2 ∈ (C 2 \\C 1 ). Then we may write\nwhere G is a generator matrix of C, and the ﬁrst k 1 rows of G generate the subcode C 1 , and the next k 2 − k 1 rows of G and the ﬁrst k 1 rows of G together generate the subcode C 2 . Since c 2 ∈ (C 2 \\C 1 ), there exists some i sat- isfying k 1 + 1 ≤ i ≤ k 2 such that x i ̸= 0. Consider the space U of GF (q) k which is orthogonal to the vec- tor (x 1 , · · · , x k 1 , x k 1 +1 , · · · , x k 2 , 0, · · · , 0). Then U, being viewed as a projective subspace of P G(k − 1, q), satisﬁes dim P L 1 (U ) = k 1 − 1, dim P L 2 (U k 1 ) = k 2 − k 1 − 2 and dim(U k 2 ) = k − k 2 − 1. Therefore, U is exactly\n−k 1 −1)(k−k 2 ) corresponding to the codeword c 2 . Then, the equation n − w(c 2 ) = m(P k 1 (k\nIn the following, Lemma 2.1 will help us to establish a sufﬁcient and necessary condition for a linear code to be a relative three-weight code.\nThe sufﬁcient and necessary condition also provides us with a convenient approach to construct a generator matrix to generate a relative three-weight code. We call it a \u201cgeometric construction\u201d of a relative three-weight code. We will illustrate this approach by an example.\nTheorem 3.1: Let C be a linear code of effective length n, with a generator matrix G. Let C 1 and C 2 be subcodes of C, generated by the ﬁrst k 1 and k 2 rows of G, respectively. Then C is a relative three-weight code with respect to C 1 and C 2 if and only if the following is true: m(P 1 00 ) is a constant for all the points P 1 00 ; m(P 0 10 ) is a constant for all the points P 0 10 ; and m(P 0 01 ) is a constant for all the points P 0 01 .\nProof: We ﬁrst prove the sufﬁcient condition. Assume m( ·) has same values on the points P 1 00 , P 0 10 and P 0 01 , respectively. Then all the subspaces P k 1 −1 (k\n−k 1 )(k −k 2 ) will have the same value since any P k 1 −1 (k\n−k 1 )(k −k 2 ) contains the same number of points being from the set of points P 1 00 , P 0 10 and P 0 01 ,\nrespectively. It follows from Lemma 2.1 that all the nonzero codewords of C 1 have the same weight. Similarly, we know that all the codewords of C 2 \\C 1 have the same weight, and all the codewords of C\\C 2 have the same weight. Therefore, C is a relative three-weight code with respect to C 1 and C 2 .\nNext, we prove the necessary condition. Assume C is a relative three-weight code. In order to show that the value assignment m( ·) has same values on the points P 1 00 , P 0 10 and P 0 01 , respectively, we will prove the following general result:\nm(P ξ ηγ ) = a constant, \t (1) for any ﬁxed triple (ξ, η, γ).\nTo show (1) is true, we denote ξ + η + γ = k − i and use the induction on i, for i = 0, . . . , k − 1.\nFor i = 0, we have ξ + η + γ = k and P ξ ηγ = P G(k − 1, q), so, m(P ξ ηγ ) = m(P G(k − 1, q)) = n.\nFor i = 1, we have ξ + η + γ = k − 1 and P ξ ηγ is equal to one of the three kinds of subspaces P k 1 −1 (k\nNow, assume (1) is true for any i satisfying i < i 0 , i.e., (1) is true for any ﬁxed triple (ξ, η, γ) satisfying ξ+η+γ > k −i 0 . We will show that (1) is true for i = i 0 in the following. For any P ξ ηγ satisfying ξ + η + γ = k − i 0 , there exists a P ξ \u2032 η \u2032 γ \u2032 satisfying ξ \u2032 + η \u2032 + γ \u2032 = k − (i 0 − 2) such that P ξ ηγ ⊂ P ξ \u2032 η \u2032 γ \u2032 . We may distinguish the parameters into the following cases.\n(Case 1.) ξ \u2032 = ξ + 2. Then η \u2032 = η and γ \u2032 = γ. Since m(P ξ \u2032 η \u2032 γ \u2032 ) = (q + 1)m(P ξ+1 ηγ ) − qm(P ξ ηγ ), m(P ξ ηγ ) = q + 1\n). Thus, m(P ξ ηγ ) is a constant, by the inductive hypothesis.\n(Case 2.) ξ \u2032 = ξ + 1, η \u2032 = η + 1. Then γ \u2032 = γ. Since m(P ξ \u2032 η \u2032 γ \u2032 ) = qm(P ξ+1 ηγ ) + m(P ξ (η+1)γ ) − qm(P ξ ηγ ), m(P ξ ηγ ) = m(P ξ+1 ηγ )+ 1 q m(P ξ (η+1)γ ) − 1qm(P ξ \u2032 η \u2032 γ \u2032 ), which is a constant, by the inductive hypothesis.\n(Case 3.) ξ \u2032 = ξ + 1, γ \u2032 = γ + 1. Then η \u2032 = η. Similar to Case 2, we obtain m(P ξ ηγ ) = m(P ξ+1 ηγ )+ 1 q m(P ξ η(γ+1) ) − 1\n(Case 4.) ξ \u2032 = ξ, η \u2032 = η+2. Then γ \u2032 = γ. Similar to Case 1, we obtain m(P ξ ηγ ) = q + 1 q m(P ξ (η+1)γ ) − 1qm(P ξ \u2032 η \u2032 γ \u2032 ), which is a constant.\n(Case 5.) ξ \u2032 = ξ, η \u2032 = η + 1 and γ \u2032 = γ + 1. Similar to Case 2, we obtain m(P ξ ηγ ) = m(P ξ (η+1)γ )+ 1 q m(P ξ η(γ+1) ) − 1\n(Case 6.) ξ \u2032 = ξ, η \u2032 = η and γ \u2032 = γ + 2. Similar to Case 1, we obtain m(P ξ ηγ ) = q + 1 q m(P ξ η(γ+1) ) − 1qm(P ξ \u2032 η \u2032 γ \u2032 ), which is a constant.\nTherefore, we have proved that (1) is true for i = i 0 . By the induction (1) is true.\nExample 3.1: In the following, making use of the theorem above, we will construct a binary 5-dimensional code C, which\nis a relative three-weight code with respect to a 2-dimensional subcode C 1 and a 4-dimensional code C 2 . We ﬁrst give the following value assignment.\nTo satisfy the value assignment, we give the generator matrix G as follows. \n    \n1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1 1 0 1 0 0 0 1 1 1 0 1 0 0 0 1 0 0 1 0 0 1 1 1 0 0 1 0 0 1 1 1 0 0 1 0 0 1 0 0 1 0 1 1 0 1 0 0 1 0 1 1 0 1 0 0\n1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 1 1 1 1 1 1 1 1 0 0 0 0 0 1 1 1 1 1 1 1 0 0 0 0 1 1 1 1 0 0 0 0 1 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1 1 1 1 1\n    \nLet C be the code generated by G, subcode C 1 be generated by the ﬁrst 2 rows of G, and C 2 be generated by the ﬁrst 4 rows of G. By Theorem 3.1, C is relative three-weight code with respect to C 1 and C 2 . It is easy to verify that the nonzero codewords of C 1 have weight 16, the codewords of C 2 \\C 1 have weight 20, and the codewords of C\\C 2 have weight 22.\nWe ﬁrst brieﬂy present the application of relative three- weight codes to noiseless wire-tap channels of type II with the coset coding scheme (see [7] for the detail on this type of channels). Then we will focus on the application to secret sharing schemes.\nIn [7], the application of a pair ( C, D), where D is a subcode of C, to wire-tap channels of type II has been explained. Similarly, a triple ( C, C 1 , C 2 ), where C 1 and C 2 are subcodes of C and C 1 ⊂ C 2 , can be described as three senders with the same encoder. Suppose the information symbols corresponding to C 1 and C 2 \\C 1 have been leaked to the adversary; and the adversary tries to obtain the third sender\u2019s information symbol. When a relative three-weight code is employed in the noiseless wire-tap channel of type II, the adversary will face the same level of difﬁculty, in order to obtain each information symbol, r i , of the i-th sender (for i = 1, 2, 3).\nAnother important application of relative three-weight codes is to secret sharing schemes. To be self-contained, we brieﬂy introduce the secret sharing schemes based on linear codes (for the detail, see [8], [10]).\nLet G = (g 0 , g 1 , · · · , g n −1 ) be a generator matrix (without any all-zero column) of C. In the secret sharing scheme based on C, the secret is an element of GF (q), which is called the secret space. The scheme allows n − 1 participants P 1 , P 2 , · · · , P n −1 and a dealer. The dealer is a trusted person.\nIn order to compute the shares with respect to a secret s, the dealer chooses randomly a vector u = (u 0 , · · · , u k −1 ) ∈\nGF (q) k such that s = ug 0 . There are q k −1 such vectors u ∈ GF (q) k in total. The dealer then treats u as an information vector and computes the corresponding codeword\nSince t 0 = ug 0 = s, a set of shares {t i 1 , t i 2 , · · · , t i m }, 1 ≤ t i 1 < · · · < i m ≤ n − 1 and 1 ≤ m ≤ n − 1, determines the secret if and only if g 0 is a linear combination of g i 1 , · · · , g i m .\nIn [8], Massey has showed the following: Let G be a generator matrix of an [n, k] code C. In the secret sharing scheme based on C, a set of shares {t i 1 , t i 2 , · · · , t i m }, 1 ≤ i 1 < · · · < i m ≤ n − 1 and 1 ≤ m ≤ n − 1, determines the secret if and only if there is a codeword\nIf there is a codeword of (2) in C ⊥ , then the vector g 0 is a linear combination of g i 1 , · · · , g i m , say, g 0 =\nx j g i j . Then the secret s is recovered by computing s =\nx j t i j . If a group of participants can recover the secret by com-\nbining their shares, then any group of participants containing this group can also recover the secret. A group of participants is referred to as a minimal access set if they can recover the secret with their shares, while any of its proper subgroups cannot do so. Due to this fact, we are interested in the set of minimal access sets.\nDeﬁnition 4.1: We say that codeword c \u2032 covers a codeword c, if the support of c \u2032 contains the support of c. If a nonzero codeword c covers only its scalar multiples, but no other nonzero codewords, it is called a minimal codeword.\nFrom the preceding discussion, it is clear that there is a one- to-one correspondence between the set of minimal access sets and the set of minimal codewords of the dual code C ⊥ whose ﬁrst coordinate is 1. Thus, to determine the access structure of the secret sharing scheme, we need to determine the set of minimal codewords whose ﬁrst coordinate is 1. It is easy to see that in most cases, we are able to determine the set of minimal codewords, as long as we can determine the set of minimal codewords whose ﬁrst coordinate is 1. The problem of determining all the minimal codewords of a linear code, is called the covering problem in the literature [1], [8]. And it is well known that this is a hard problem for an arbitrary linear code. Currently, only a few classes of linear codes are known, for which the minimal codewords are completely determined [4], [10].\nMaking use of the results in [5], it is easy to prove the following lemma. We omit the proof here; in the later version of this paper [6], we will present a full proof.\nLemma 4.1: If C is an [n, k] relative two-weight code with respect to a subcode D, then all the nonzero codewords of C are minimal codewords unless dim D = 1 and the weight of\nthe codewords of D is equal to n. In the latter case, the set of minimal codewords is exactly C\\D.\nTheorem 4.2: Assume C(d 1 , d 2 , d) is a relative three-weight code with respect to C 1 and C 2 . Then all of the nonzero codewords of C(d 1 , d 2 , d) are minimal codewords except the following two cases:\n1) dim C 1 = 1, and C 1 and C 2 have the same effective length.\n2) dim C 1 = 1, and C 1 and C have the same effective length. In these two cases, all the codewords of C\\C 1 are minimal codewords of C(d 1 , d 2 , d).\n(Case 1.) d 1 = d 2 or d 2 = d. Then C(d 1 , d 2 , d) is a relative two-weight code. The minimal codewords of C are determined using Lemma 4.1.\n(Case 2.) d 1 = d > d 2 . We ﬁrst show that any codeword c ∈ C\\C 2 is a minimal codeword. If c covers a codeword c \u2032 ∈ C 1 , then c and c \u2032 have the same support positions since w(c) = w(c \u2032 ) = d. So, there exists a a ∈ GF (q) such that the codeword u = c − ac \u2032 has zero coordinate in at least one of the support positions of c, i.e., w(u) < d = d 1 . If u = 0, then c = ac \u2032 ∈ C 1 , a contradiction to c ∈ C\\C 2 . It follows that w(u) = d 2 . So, u ∈ C 2 \\C 1 . It follows c = ac \u2032 + u ∈ C 2 , again a contradiction to c ∈ C\\C 2 . So, c does not cover any codeword c \u2032 ∈ C 1 .\nWe now show that c ∈ C\\C 2 does not cover any codeword c \u2032 ∈ C 2 \\C 1 . Otherwise, we can similarly ﬁnd a a ∈ GF (q) such that u = c −ac \u2032 ̸= 0 and w(u) = d 2 < w(c) = d = d 1 . It follows that u ∈ C 2 \\C 1 . So, c = u + ac \u2032 ∈ C 2 , a contradiction to c ∈ C\\C 2 .\nNext, we show that c ∈ C\\C 2 does not cover any other codeword c \u2032 ∈ C\\C 2 unless c \u2032 = ac for some a ∈ GF (q). If c covers c \u2032 , then c and c \u2032 have the same support positions since w(c) = w(c \u2032 ) = d. So, we similarly ﬁnd a a ∈ GF (q) such that u = c \u2032 −ac and w(u) < d = d 1 . If u ̸= 0, then w(u) = d 2 and u ∈ C 2 \\C 1 . It follows that c covers the codeword u, a contradiction to the fact that c doesn\u2019t cover any codeword of C 2 \\C 1 . So, u = 0, i.e., c \u2032 = ac.\nFrom the discussion above, we showed that all the code- words of C\\C 2 are minimal codewords.\nNow, we show that all the codewords of C 2 \\C 1 are minimal codewords. Assume c ∈ (C 2 \\C 1 ). It is clear that c does not cover the codeword c \u2032 ∈ (C\\C 2 ) or c \u2032\u2032 ∈ C 1 , since w(c) = d 2 < w(c \u2032 ) = w(c \u2032\u2032 ) = d = d 1 . If c covers another codeword c \u2032 ∈ (C 2 \\C 1 ), then we can similarly ﬁnd u = c \u2032 − ac such that w(u) < w(c) = d 2 , since w(c) = w(c \u2032 ) = d 2 . So, u = 0, i.e., c \u2032 = ac for some a ∈ GF (q).\nLast, we show that all the codewords of C 1 are minimal codewords. Assume c ∈ C 1 . Then c does not cover c \u2032 ∈ ( C\\C 2 ). Otherwise, c \u2032 also covers c since w(c) = w(c \u2032 ). If c covers another codeword c \u2032 ∈ C 1 , then since w(c) = w(c \u2032 ) = d 1 , we can similarly ﬁnd u = c −ac \u2032 ∈ C 1 for some a ∈ GF (q)\nsuch that w(u) < w(c) = d 1 . Thus, u = 0, i.e., c = ac \u2032 . It is necessary to show that c does not cover any codeword c \u2032 ∈ (C 2 \\C 1 ). Assume the effective length of C 1 is n 1 . If dim C 1 > 1, then w(c) < n 1 . Without loss of generality, let the ﬁrst coordinate of c be zero and write c as\nwhere G is the generator matrix of C corresponding to the value assignment. Represent the ﬁrst column of G by p 1 , and deﬁne a set\nThen (x 1 , ...x k 1 , 0, ..., 0) is orthogonal to all the elements of S. Write c \u2032 ∈ (C 2 \\C 1 ) as\nIf c covers c \u2032 , then (y 1 , ...y k 1 , y k 1 +1 ..., y k 2 , 0, ..., 0) is orthogonal to the element of S, in particular, (y 1 , ...y k 1 , y k 1 +1 ..., y k 2 , 0, ..., 0) is orthogonal to the element p 0 = P L 1 (p 1 ) ∈ S, i.e., (y 1 , ...y k 1 , 0, ....0) is orthogonal to all the elements of S. It follows that (0, ...0, y k 1 +1 , ..., y k 2 , 0, ..., 0) is orthogonal to all the elements of S ∗ , where\nand L 1 and L 2 are given as in Section II. Since rank(S ∗ ) = k 2 − k 1 according to Theorem 3.1, we get y k 1 +1 = y k 1 +2 = · · · = y k 2 = 0. It follows that c \u2032 ∈ C 1 , which is a contradiction to the fact c \u2032 ∈ (C 2 \\C 1 ). This shows that any codeword c ∈ C 1 does not cover any codeword c \u2032 ∈ (C 2 \\C 1 ) if dim C 1 > 1.\nOn the other hand, if dim C 1 = 1 and n 1 < n 2 (n 2 is the effective length of C 2 ), then m(P 0 10 ) > 0. So, the rank of the set\nBy Theorem 3.1, we see that any codeword of C 1 has zero in the coordinate positions that S 1 represents, and any codeword c \u2032 ∈ (C 2 \\C 1 ) has nonzero in at least one of the coordinate positions that S 1 represents according to (3) and rank(S 2 ) = k 2 − k 1 . It follows that c ∈ C 1 does not cover any codeword c \u2032 when dim C 1 = 1 and n 1 < n 2 .\nUsing the techniques in the proof of Case 2, we can similarly prove the results for the following cases, i.e., Case 3 - Case 9.\n(Case 3.) d 1 = d < d 2 . Then all the codewords of C are minimal words.\n(Case 4.) d 1 < d 2 < d. Then all the codewords of C are minimal codewords.\n(Case 5.) d 1 < d < d 2 . Then all the codewords of C are minimal codewords.\n(Case 6.) d 2 < d 1 < d. Then all the codewords of C are minimal codewords except in the case that dim C 1 = 1 and C 1\nand C 2 have the same effective length. In the latter case, all the codewords of C\\C 1 are minimal codewords.\n(Case 7.) d 2 < d < d 1 . Then all the codewords of C are minimal codewords except in the following two cases: dim C 1 = 1 and C 1 and C 2 have the same effective length; dim C 1 = 1 and C 1 and C have the same effective length. In these two cases, all the codewords of C\\C 1 are minimal codewords.\n(Case 8.) d < d 1 < d 2 . Then all the codewords of C are minimal codewords except in the case that dim C 1 = 1 and C 1 and C have the same effective length. In the latter case, all the codewords of C\\C 1 are minimal codewords.\n(Case 9.) d < d 2 < d 1 . The result is the same as in Case 7.\nRemark 4.1: Comparing our three-weight codes with codes studied in [4], [10], it is showed that the family of three-weight codes contains new codes which are not covered by [4], [10]. In [6], we will give an example of three-weight code that does not belong to the classes of [4], [10].\nWe have investigated a class of three-weight codes, and presented their applications to wire-tap channels of type II as well as secret sharing schemes. Using the ﬁnite projective geometry, we ﬁrst established an approach to characterize the Hamming weights of codewords of a linear code. We then gave a sufﬁcient and necessary condition for a linear code to be a three-weight code, making use of the geometric approach. Furthermore, we have determined the minimal codewords of a three-weight code, for the application of the code to secret sharing schemes.\nThis work was supported by The National Science Founda- tion of China (No. 11171366 and No. 61170257)."},"refs":[{"authors":[{"name":"A. Ashikhmin"},{"name":"A. Barg"}],"title":{"text":"Minimal vectors in linear codes"}},{"authors":[{"name":"G. Bouyukliev"}],"title":{"text":"Classiﬁcation of Griesmer codes and dual transform"}},{"authors":[{"name":"D. Chen"},{"name":"T. Kløve"}],"title":{"text":"The weight hierarchies of q-ary codes of dimension 4"}},{"authors":[{"name":"Z. H. Li"},{"name":"T. Xue"},{"name":"H. Lai"}],"title":{"text":" Secret sharing schemes from binary linear codes"}},{"authors":[{"name":"Z. H. Liu"},{"name":"W. D. Chen"}],"title":{"text":"Notes on the value function"}},{"authors":[{"name":"Z. H. Liu"}],"title":{"text":"Two-weight and three-weight codes for crypto- graphic applications"}},{"authors":[{"name":"Y. Luo"},{"name":"C. Mitrpant"},{"name":"J. Han Vinck"},{"name":"F. Chen"}],"title":{"text":"Some new characters on the wire-tap channel of type II"}},{"authors":[{"name":"J. L. Massey"}],"title":{"text":"Minimal codewords and secret sharing"}},{"authors":[{"name":"A. Tsfasman"},{"name":"S. Vladuts"}],"title":{"text":"Geometric approach to higher weights"}},{"authors":[{"name":"J. Yuan"},{"name":"C. S. Ding"}],"title":{"text":"Secret sharing schemes from three classes of linear codes"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569565933.pdf"},"links":[{"id":"1569559967","weight":4},{"id":"1569564805","weight":4},{"id":"1569565775","weight":4},{"id":"1569566303","weight":4},{"id":"1569564249","weight":4},{"id":"1569566787","weight":4},{"id":"1569566733","weight":4},{"id":"1569563307","weight":4},{"id":"1569558681","weight":4},{"id":"1569555999","weight":4},{"id":"1569566217","weight":4},{"id":"1569558901","weight":9},{"id":"1569564881","weight":4},{"id":"1569554881","weight":9},{"id":"1569566909","weight":4},{"id":"1569564333","weight":4},{"id":"1569556671","weight":4},{"id":"1569558401","weight":4},{"id":"1569566233","weight":4},{"id":"1569564097","weight":4},{"id":"1569566949","weight":4},{"id":"1569565155","weight":14},{"id":"1569565885","weight":4},{"id":"1569557715","weight":4},{"id":"1569557275","weight":9},{"id":"1569565385","weight":4},{"id":"1569565661","weight":4},{"id":"1569565597","weight":4},{"id":"1569551905","weight":4},{"id":"1569564923","weight":4},{"id":"1569565769","weight":4},{"id":"1569561713","weight":4},{"id":"1569566933","weight":9},{"id":"1569566147","weight":4},{"id":"1569560785","weight":14},{"id":"1569565631","weight":4},{"id":"1569565565","weight":4},{"id":"1569561397","weight":4},{"id":"1569565315","weight":9}],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S14.T6.2","endtime":"17:20","authors":"Zihui Liu, Xin-Wen Wu","date":"1341507600000","papertitle":"On a Class of Three-Weight Codes with Cryptographic Applications","starttime":"17:00","session":"S14.T6: Applications of Codes in Cryptography","room":"Kresge Rehearsal A (033)","paperid":"1569565933"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
