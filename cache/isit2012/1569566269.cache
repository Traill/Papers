{"id":"1569566269","paper":{"title":{"text":"An algorithm for list decoding number ﬁeld codes"},"authors":[{"name":"Jean-Franc¸ois Biasse"},{"name":"Guillaume Quintin"}],"abstr":{"text":"Abstract\u2014We present an algorithm for list decoding codewords of algebraic number ﬁeld codes in polynomial time. This is the ﬁrst explicit procedure for decoding number ﬁeld codes whose construction were previously described by Lenstra [1] and Guruswami [2]. We rely on a new algorithm for computing the Hermite normal form of the basis of an O K -module due to Biasse and Fieker [3] where O K is the ring of integers of a number ﬁeld K."},"body":{"text":"Algorithms for list decoding Reed-Solomon codes, and their generalization the algebraic-geometric codes are now well understood. The codewords consist of sets of functions whose evaluation at a certain number of points are sent, thus allowing the receiver to retrieve them provided that the number of errors is manageable.\nThe idea behind algebraic-geometric codes can be adapted to deﬁne algebraic codes whose messages are encoded as a list of residues redundant enough to allow errors during the transmission. The Chinese Remainder codes (CRT codes) have been fairly studied by the community [4], [5]. The encoded messages are residues modulo N := p 1 , · · · , p n of numbers m ≤ K := p 1 · · · p k where p 1 < p 2 < · · · < p n are prime numbers. They are encoded by using\nDecoding algorithms for CRT codes were signiﬁcantly im- proved to reach the same level of tolerance to errors as those for Reed-Solomon codes [6], [7], [4]. As algebraic-geometric codes are a generalization of Reed-Solomon codes, the idea arose that we could generalize the results for CRT codes to redundant residue codes based on number ﬁelds. Indeed, we can easily deﬁne an analogue of the CRT codes where a number ﬁeld K plays the role of Q and its ring of integers O K plays the role of Z. Then, for prime ideals p 1 , · · · , p n such that N (p 1 ) < · · · < N (p n ), a message m ∈ O K can be encoded by using\nThe construction of good codes on number ﬁelds have been independently studied by Lenstra [1] and Guruswami [2]. They provided indications on how to chose number ﬁelds\nhaving good properties for the underlying codes. In particular, Guruswami [2] showed the existence of asymptotically good number ﬁeld codes, that is a family C i of [n i , k i , d i ] q codes of increasing block length with\nNeither of them could provide a decoding algorithm. In the concluding remarks of [2], Guruswami identiﬁes the applica- tion of the decoding paradigm of [8], [9], [4] to number ﬁeld codes as an open problem.\nContribution: The main contribution of this paper is to provide the ﬁrst algorithm for decoding number ﬁeld codes. We ﬁrst show that a direct adaptation of an analogue of Coppersmith\u2019s theorem due to Cohn and Heninger [10] allows to follow the approach of Boneh [6] which does not allow to reach the Johnson bound. Then we adapt the decoding paradigm of [8, Chap. 7] to number ﬁeld codes, by using methods for manipulating modules over the ring of integers of a number ﬁeld recently described in [3] to achieve the Johnson bound.\nThroughout this paper, we denote by K a number ﬁeld of degree d, of discriminant ∆ and of ring of integers O K . The prime ideals (p i ) i ≤n satisfy N (p 1 ) < N (p 2 ) < · · · < N (p n ), and we deﬁne N := i ≤n N (p i ) and B := i ≤k N (p i ) 1/d for integers k, n such that 0 < k < n. Before describing our algorithm in more details in the following sections, let us state the main result of the paper.\nTheorem 1. Let ε > 0, and a message m ∈ O K satisfying m ≤ B, then there is an algorithm that returns all the\nmessages m ∈ O K such that m ≤ B and that c(m) and c(m ) have mutual agreement t satisfying\nLet K be a number ﬁeld of degree d. It has r 1 ≤ d real embeddings (θ i ) i ≤r 1 and 2r 2 complex embeddings (θ i ) r 1 <i ≤r 1 +2r 2 (coming as r 2 pairs of conjugates). The ﬁeld K is isomorphic to O K ⊗ Q where O K denotes the ring of integers of K. We can embed K in\nand extend the θ i \u2019s to K R . Let T 2 be the Hermitian form on K R deﬁned by\nand let x := T 2 (x, x) be the corresponding L 2 -norm. Let (α i ) i ≤d be such that O K = ⊕ i Zα i , then the discriminant of K is given by ∆ = det 2 (T 2 (α i , α j )). The norm of an element x ∈ K is deﬁned by N (x) = i |θ i (x) |.\nWe encode our messages with prime ideals of O K . How- ever, for decoding, we need a more general notion of ideal, namely the fractional ideals of O K . A subset a ⊆ K is said to be a fractional ideal if ∃r ∈ Z, ra ⊆ O K . When a fractional ideal is contained in O K , we refer to it as an integral ideal.The sum and product of two fractional ideals of O K is given by\nAny non zero fractional ideal a of O K is invertible, that is there exists a −1 := {x ∈ K | xa ⊆ O K } such that aa −1 = O K . The norm of integral ideals is given by N (I) := [O K : I], which extends to fractional ideals by N (I/J) := N (I)/N (J). The norm of a principal ideal agrees with the norm of its generator N (xO K ) = |N (x)|.\nIn the following, we will study ﬁnitely generated sub O K - module of O K [y]. Let M ⊆ K l be a ﬁnitely generated O K - module. As in [11, Chap. 1], we say that [(a i ), (a i )] i ≤n , where a i ∈ K and a i is a fractional ideal of K, is a pseudo-basis for M if M = a 1 a 1 ⊕ · · · ⊕ a n a n . We also call a pseudo-matrix representing M the matrix of the coefﬁcients of the (a i ) i ≤n along with the ideals a i . The algorithm [3, Alg.4] returns a pseudo-matrix representing M where the matrix of the (a i ) i ≤n has a triangular shape in polynomial time.\nAn analogue of Coppersmith\u2019s theorem was described by Cohn and Heninger in [10]. It was used to provide an elegant way of decoding Reed-Solomon codes, and the possibility to use it for breaking lattice- based cryptosystems in O K modules was considered, although they concluded that it would not improve the state-of-the-art algorithms.\nTheorem 2 (Cohn-Heninger). Let f ∈ O K [X] be a monic polynomial of degree l, 0 < β ≤ 1, λ 1 , · · · , λ d > 0 and I \t O K an ideal. We can ﬁnd in polynomial time all the ω ∈ O K such that |ω| i := |σ i (ω) | ≤ λ i and\nAlthough not mentioned in [10], a straightforward adap- tation of Theorem 2 with β := \t i ≤k log N (p i )\nwhere 0 < k < n, I := i ≤n p i and ∀i, λ i := i ≤k N (p i ) 1/d provides a polynomial time algorithm for decoding number ﬁeld codes.\nTheorem 3. Let (r 1 , · · · , r n ) ∈ O n K and m ∈ O K satisfying ∀i, m = r i mod p i , then Theorem 2 applied to f (ω) := ω −m allows to return in polynomial time a list of m ∈ O K with N (m ) ≤ i ≤k N (p i ) that differ from m in at most e places where\nIn the rest of the paper, we present a method based on Guruswami\u2019s general framework for residue codes [8] that allows us to get rid in the dependency in log N (p n ) log N (p\nin the decoding bound thus reaching the Johnson bound.\nA Johnson-type bound is a positive number J depending on the distance, the blocklength and the cardinalities of the alphabets constituting the code. It garanties that a \u201csmall\u201d number of codewords are in any sphere of radius J . By \u201csmall\u201d number, we mean a number of codewords which is linear in the code blocklength and the dimension of the code. In our case, the Johnson-type bound for number ﬁelds codes depends only on the code blocklength and its minimal distance, and \u201csmall\u201d means polynomial in n i=1 log N (p i ).\nThe Johnson-type bound of [8, Section 7.6.1] remains valid for number ﬁeld codes. For any prime ideal p ⊂ O K , the quotient O K /p is a ﬁnite ﬁeld. Thus the i\u2019th symbol of a codeword comes from an alphabet of size N (p i ) = |O K /p i | and [8, Th. 7.10] can be applied. Let t be the least positive integer such that t i=1 N (p i ) > 2B d d , where d = [K : Q] and let T = t i=1 N (p i ). Then, by [2, Lem. 12], the minimal hamming distance of the number ﬁelds code is at least n −t+1. Using [8, Th. 7.10], we can show that for a given message and ε > 0, only a \u201csmall\u201d number of codewords satisfy\nwhere a i = 1 if the codeword and the message agree at the i-th position, a i = 0 otherwise. Thus, if our list decoding algorithm returns all the codewords having at most n − (t + ε)n errors then this number is garanteed to be \u201csmall\u201d. Therefore, the Johnson bound appears to be a good objective for our algorithm. Note that we would derive a different bound by using weighted distances. In particular, by using the log-weighted hamming distance i.e. d(x, y) =\nIn this section, we give a high-level description of our decoding algorithm. We follow the approach of the general framework described in [8], making the arrangements required in our context. Our code is the set of m ∈ O K such that\nm ≤ B where B = i ≤k N (p i ) 1/d . We also deﬁne N := i ≤n N (p i ). A codeword m is encoded via\nWe ﬁnd the codewords m with desired weighted agreement by computing roots of a polynomial c ∈ O K [y] that satisﬁes\nm ≤ B =⇒ c(m) < F, \t (2) for an appropriate bound F . We choose the polynomial c satisfying (2) in the ideal i ≤n J z i i ⊆ O K [y] where\nWith such a choice of a polynomial, we necessarily have c(m) ∈ i p z i a i i , where a i = 1 if c(m) mod p i = r i , 0 otherwise. In particular, if c(m) = 0 then N (c(m)) ≥\nN (p i ) z i a i . In addition, we know, from the inequality beween arithmetic and geometric mean, that c(m) ≥ √\nd N (c(m)) 1/d . We thus know that if the weighted agreement satisﬁes\nd ( i N (p i ) z i a i ) 1/d > F , then c(m) has to be zero, since otherwise it would contradict (2).\nRequire: O K , z 1 , · · · , z n , B, Z, r 1 , · · · , r n ∈ i O K /p i . Ensure: All m such that i a i z i > Z.\n2: Find c ∈ i ≤n J z i i ⊆ O K [y] of degree at most l such that m ≤ B =⇒ c(m) < F .\n3: Find all roots of c and report those roots ξ such that ξ ≤ B and i a i z i > Z.\nIn this section, given weights (z i ) i ≤n , we prove the exis- tence of a polynomial c ∈ i J z i i and a constant F > 0 such that for all m ≤ B, m ∈ O K , we have c(m) ≤ F . This proof is not constructive. The actual computation of this polynomial will be described in Section VII. We ﬁrst need to estimate the number of elements of O K bounded by a given size.\nLemma 1. Let F > 0 and 0 < γ < 1, then the number of x ∈ O K such that x ≤ F is at least\nProof: As in [12, Chap. 5], we use the standard results of Minkowski theory for our purposes. More precisely, there is an isomorphism f : K R −→ R r 1 +2r 2 and a scalar product (x, y) := \t i ≤r\ntransferring the canonical measure from K R to R r 1 +2r 2 . Let λ = f ( O K ), X := {x ∈ K R | x ≤ F }, and m ∈ N. We know from Minkowski\u2019s lattice point theorem that if Vol(X) > m2 d det(λ), then #(f (x) ∩ λ) ≥ m. As Vol(X) = 2 r 2 2π d/2 F d /Γ(d/2) and det(λ) = |∆|, we have the desired result.\nThen, we must derive from Lemma 1 an analogue of [8, Lemma 7.6] in our context. This lemma allows us to estimate the number of polynomials of degree l satisfying (2). To simplify the expressions, we use the following notation in the rest of the paper\nLemma 2. For positive integers B, F , the number of poly- nomials c ∈ O K [y] of degree at most l satisfying (2) is at least\nProof: Let c(y) = c 0 +c 1 y+ · · ·+c l y l . We want the c i \u2019s to satisfy c i m i < F /(l + 1) whenever m ≤ B. This is the case when c i < F /(B i (l + 1)). By Lemma 1, there are at least α d,∆,γ F /((l + 1)B i ) d possibilities for c i . Therefore, the number of polynomials c satisfying (2) is at least\nNow that we know how to estimate the number of c ∈ O K [y] of degree at most l satisfying (2), we need to ﬁnd a lower bound on F to ensure that we can ﬁnd such a polynomial in i J z i i . The following lemma is an equivalent of [8, Lemma 7.7].\nProof: Let us apply Lemma 2 to F = F/2. There are at least\npolynomial c ∈ O K [y] satisfying m ≤ B ⇒ c(m) < F/2. In addition, we know from [8, Corollary 7.5] that\n|N (p i ) |( zi+1 2 ) ≥ |O K [y]/ i J z i i |, which implies that if (4) is satisﬁed, then necessarily\nThis means that there are at least two distinct polynomials c 1 , c 2 ∈ O K [y] of degree at most l such that (c 1 − c 2 ) ∈\nJ z i i and c 1 (m) , c 2 (m) < F/2 whenever m ≤ B. The choice of c := c 1 − c 2 ﬁnishes the proof.\nLet l > 0 be an integer to be determined later. To compute c ∈ i J z i i of degree at most l satisfying (2), we need to ﬁnd a short pseudo-basis of the sub O K -module M ∩ i J z i i of K l+1 where M is the O K -module of the elements of O K [y] of degree at most l embedded in K l+1 via i c i y i → (c i ). We ﬁrst compute a pseudo-generating set for each M ∩ J z i i , then we compute a pseudo-basis for their intersection, and we ﬁnally call the algorithm of [13] to produce a short pseudo- basis of M ∩ i J z i i from which we derive c.\nAn algorithm for computing a pseudo-basis of the intersec- tion of two modules given by their pseudo-basis is described by Cohen in [11, 1.5.2]. It relies on the HNF algorithm for O K -modules. The HNF algorithm presented in [11, 1.4] is not polynomial, but a variant recently presented in [3] enjoys this property. We can therefore apply [11, 1.5.2] with the HNF of [3] successively for each pseudo-basis of M ∩J z i i to produce a pseudo-basis of M ∩ i J z i i .\nRequire: ( p i , z i ) i ≤n , l, N , B, F such that ∃c ∈ i J z i i of degree at most l satisfying (2) for F , and the encoded message (r 1 , · · · , r n ) ∈ i O K /p i .\n2d F \t of \t degree \t at most l.\n8: Deduce a pseudo-basis [(d i ), (d i )] i ≤l+1 of the module M 2 given by\n9: Let [(b i ), (b i )] i ≤l+1 be a short pseudo-basis of M 2 ob- tained with the reduction algorithm of [13].\n10: Let x 1 , x 2 be a short basis of b 1 obtained with [13, Th. 3].\nTo derive our main result, we need to consider weights z i > 0 in R rather than Z. Let\nthen by combining (3), (4) and Algorithm 2, we know that given (r 1 , · · · , r n ) ∈ \t i ≤n O K /p i , l > 0, B =\nN (p i ) 1/d and integer weights z i > 0, Algorithm 2 returns a polynomial c of degree at most l such that all m ∈ O K satisfying m ≤ B and\n(where a i = 1 if m mod p i = r i , 0 otherwise) are roots of c. In the following, we no longer assume the z i to be integers. However, we will use our previous results with the integer weights z ∗ i := Az i for a sufﬁciently large integer A to be determined.\nO K /p i , then our algorithm ﬁnds all the m ∈ O K such that m ≤ B and\nProof: Note that we can assume without loss of generality that z max = 1. Let z ∗ i = Az i for a sufﬁciently large integer A, which thus satisﬁes Az i ≤ z ∗ i < Az i + 1. The decoding condition (5) is met whenever\n  \n≤n Z i log N (p i ) log(2 d 2 B d )\n  \nWe assume that A ≥ log(2 d 2 B d ), which ensures that l > 0. For this choice of l, condition (6) is satisﬁed whenever\na i z i log N (p i ) ≥ 3d 2A\nA i ≤n Z i log N (p i ) log(2 d 2 B d )\n \n \n \nAssume that A ≥ 10 log N ε and A ≥ log β d,∆,γ log N , then for N large enough, the right side of (7) is at most\n \n \n \n \nThe degree l of our decoding polynomial c is therefore polynomial in log N , 1 ε , d and log |∆|. By [14, 2.3], we know that the complexity to ﬁnd the roots of c is polynomial in d, l and in the logarithm of the height of c, which we already proved to be polynomial in the desired values.\nCorollary 1. Let ε > 0, k < n and prime ideals p 1 , · · · p n sat- isfying N (p i ) < N (p i+1 ) and log N (p k+1 ) ≥ (k log N (p k )+ d 2 ), then with the previous notations, our algorithm ﬁnds a list of all codewords which agree with a received word in t places provided t ≥ k(n + ε).\nProof: The proof is similar to the one of [8, Th. 7.14]. The main difference is that we deﬁne δ := k − log(2 d2 B d ) log N (p\nwhich satisﬁes δ ≥ 0 since by assumption log N (p k+1 ) ≥ (k log N (p k ) + d 2 ). We apply Proposition 1 with z i = 1/ log N (p i ) for i ≥ k+1, z i = 1/ log N (p k+1 ) for i ≤ k, and ε = ε/ log N (p k+1 ). It allows us to retrieve the codewords whose number of agreements t is at least\nThis condition is met whenever t ≥ δ + (k − δ)(n − δ + ε). From the Cauchy-Schwartz inequality, we notice that\nwhich proves that our decoding algorithm works when t ≥ k(n + ε).\nWe presented the ﬁrst method for list decoding number ﬁeld codes. A straightforward application of Theorem 2 allows to derive a decoding algorithm in polynomial time. However, we cannot achieve the Johnson bound with this method. To solve this problem, we described an analogue of the CRT list decoding algorithm for codes based on number ﬁelds. This is the ﬁrst algorithm allowing list decoding of number ﬁeld codes up to the Johnson bound. We followed the approach of [8, Ch. 7] that provides a general frameworks for list decoding of algebraic codes, along with its application to CRT codes. The modiﬁcations to make this strategy efﬁcient in the context of number ﬁelds are substantial. We needed to refer to the theory\nof modules over a Dedekind domain, and carefully analyse the process of intersecting them, as well as ﬁnding short elements. We proved that our algorithm is polynomial in the size of the input, that is in d, log(N ), log |∆| and 1 ε .\nThe ﬁrst author would like to thank Guillaume Hanrot for his helpful comments on the approach based on Coppersmith\u2019s theorem. We also thank an anonymous referee for helpful comments on this paper."},"refs":[{"authors":[{"name":"H. Lenstra"}],"title":{"text":"Codes from algebraic number ﬁelds"}},{"authors":[{"name":"V. Guruswami"}],"title":{"text":"Constructions of codes from number ﬁelds"}},{"authors":[{"name":"J.-F. Biasse"},{"name":"C. Fieker"}],"title":{"text":"A polynomial time algorithm for computing the hnf of a module over the integers of a number ﬁeld"}},{"authors":[{"name":"V. Guruswami"},{"name":"A. Sahai"},{"name":"M. Sudan"}],"title":{"text":"Soft-decision decoding of chinese remainder codes"}},{"authors":[{"name":"D. Mandelbaum"}],"title":{"text":"On a class of arithmetic codes and a decoding algorithm (corresp.)"}},{"authors":[{"name":"D. Boneh"}],"title":{"text":"Finding smooth integers in short intervals using crt decoding"}},{"authors":[{"name":"O. Goldreich"},{"name":"D. Ron"},{"name":"M. Sudan"}],"title":{"text":"Chinese remaindering with errors"}},{"authors":[{"name":"V. Guruswam"}],"title":{"text":"List Decoding of Error-Correcting Codes: Winning Thesis of the 2002 ACM Doctoral Dissertation Competition (Lecture Notes in Computer Science)"}},{"authors":[{"name":"V. Guruswami"},{"name":"M. Sudan"}],"title":{"text":"Improved decoding of reed-solomon and algebraic-geometric codes"}},{"authors":[{"name":"H. Cohn"},{"name":"N. Heninger"}],"title":{"text":"Ideal forms of coppersmith\u2019s theorem and guruswami-sudan list decoding"}},{"authors":[{"name":"H. Cohe"}],"title":{"text":"Advanced topics in computational algebraic number theory, ser"}},{"authors":[{"name":"J. Neukirc"}],"title":{"text":"Algebraic number theory, ser"}},{"authors":[{"name":"C. Fieker"},{"name":"D. Stehl´e"}],"title":{"text":"Short bases of lattices over number ﬁelds"}},{"authors":[{"name":"A. Ayad"}],"title":{"text":"A lecture on the complexity of factoring polynomials over global ﬁelds"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569566269.pdf"},"links":[{"id":"1569559617","weight":5},{"id":"1569566683","weight":5},{"id":"1569556029","weight":5},{"id":"1569552245","weight":5},{"id":"1569560833","weight":10},{"id":"1569564233","weight":5},{"id":"1569560427","weight":10},{"id":"1569566941","weight":5},{"id":"1569566089","weight":5},{"id":"1569564989","weight":5},{"id":"1569566193","weight":5},{"id":"1569566425","weight":5},{"id":"1569566553","weight":5},{"id":"1569565393","weight":5},{"id":"1569565441","weight":5},{"id":"1569566275","weight":21},{"id":"1569565961","weight":5},{"id":"1569560503","weight":5},{"id":"1569566133","weight":5},{"id":"1569566631","weight":5},{"id":"1569565571","weight":5},{"id":"1569564411","weight":5},{"id":"1569565865","weight":5},{"id":"1569566641","weight":5},{"id":"1569564437","weight":5},{"id":"1569565593","weight":5},{"id":"1569566435","weight":5},{"id":"1569566577","weight":5},{"id":"1569560459","weight":5},{"id":"1569565165","weight":5},{"id":"1569566797","weight":10}],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S1.T5.3","endtime":"10:50","authors":"Jean-Francois Biasse, Guillaume Quintin","date":"1341225000000","papertitle":"An algorithm for list decoding number field codes","starttime":"10:30","session":"S1.T5: List Decoding and Reed-Solomon Codes","room":"Kresge Little Theatre (035)","paperid":"1569566269"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
