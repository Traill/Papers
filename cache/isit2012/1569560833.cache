{"id":"1569560833","paper":{"title":{"text":"List Decoding Algorithms based on Gröbner Bases for General One-Point AG Codes"},"authors":[{"name":"Olav Geil ∗"},{"name":"Ryutaroh Matsumoto \u2020"},{"name":"Diego Ruano ∗"}],"abstr":{"text":"Abstract\u2014We generalize the list decoding algorithm for Hermi- tian codes proposed by Lee and O\u2019Sullivan [15] based on Gröbner bases to general one-point AG codes, under an assumption weaker than one used by Beelen and Brander [4]. By using the same principle, we also generalize the unique decoding algorithm for one-point AG codes over the Miura-Kamiya C ab curves proposed by Lee, Bras-Amorós and O\u2019Sullivan [14] to general one-point AG codes, without any assumption. Finally we extend the latter unique decoding algorithm to list decoding, modify it so that it can be used with the Feng-Rao improved code construction, prove equality between its error correcting capability and half the minimum distance lower bound by Andersen and Geil [3] that has not been done in the original proposal, and remove the unnecessary computational steps so that it can run faster."},"body":{"text":"We consider the list decoding of one-point algebraic geome- try (AG) codes. Guruswami and Sudan [12] proposed the well- known list decoding algorithm for one-point AG codes, which consists of the interpolation step and the factorization step. The interpolation step has large computational complexity and many researchers have proposed faster interpolation steps, see [4, Figure 1]. Lee and O\u2019Sullivan [15] proposed a faster interpolation step based on the Gröbner basis theory for one- point Hermitian codes. Little [16] generalized their method [15] by using the same assumption as Beelen and Brander [4, Assumptions 1 and 2]. The aim of the ﬁrst part of this paper is to generalize the method [15] to an even wider class of algebraic curves than [16].\nThe second part proposes another list decoding algorithm whose error-correcting capability is higher than [4], [12], [15], [16] and whose computational complexity is empirically manageable. Lee, Bras-Amorós and O\u2019Sullivan [13], [14] proposed a unique decoding (not list decoding) algorithm for primal codes based on the majority voting inside Gröbner bases.\nThere were several rooms for improvements in the original result [14], namely, (a) they have not clariﬁed the relation between its error-correcting capability and existing minimum distance lower bounds except for the Hermitian codes, (b) they assumed that the maximum pole order used for code construction is less than the code length, and (c) they have not shown how to use the method with the Feng-Rao improved code construction [6]. In the second part of this paper, we shall (1) prove that the error-correcting capability of the original proposal is always equal to half of the bound in [3] for the minimum distance of one-point primal codes, (2) generalize their algorithm to work with any one-point AG codes, (3) modify their algorithm to a list decoding algorithm, (4) remove the assumptions (b) and (c) above, and (5) remove unnecessary computational steps from the original proposal. The proposed algorithm is implemented on the Singular computer algebra\nsystem [11], and we veriﬁed that the proposed algorithm can correct more errors than [4], [12], [15], [16] with manage- able computational complexity. The omitted proofs and the implementation of the proposed algorithm are available as the expanded versions [7], [8] of this conference paper.\nOur study heavily relies on the standard form of algebraic curves introduced independently by Pellikaan [10] and Miura [20]. Let F/F q be an algebraic function ﬁeld of one variable over a ﬁnite ﬁeld F q with q elements. Let g be the genus of F. Fix n + 1 distinct places Q, P 1 , . . . , P n of degree one in F and a nonnegative integer u. We consider the following one-point algebraic geometry (AG) code\nLet N 0 be the set of nonnegative integers. For (m 1 , . . . , m t ), (n 1 , . . . , n t ) ∈ N t 0 , we deﬁne the monomial order such that (m 1 , . . . , m t ) (n 1 , . . . , n t ) if a 1 m 1 +· · ·+a t m t > a 1 n 1 +· · ·+a t n t , or a 1 m 1 + · · · + a t m t = a 1 n 1 + · · · + a t n t , and m 1 = n 1 , m 2 = n 2 , . . . , m i− 1 = n i− 1 , m i < n i , for some 1 ≤ i ≤ t. Note that a Gröbner basis of I with respect to can be computed by [21, Theorem 15] or [22, Theorem 4.1], starting from any a ﬃne deﬁning equations of F/F q .\nFor i = 0, . . . , a 1 − 1, we deﬁne b i = min{m ∈ H(Q) | m ≡ i (mod a 1 )}, and L i to be the minimum element (m 1 , . . . , m t ) ∈ N t 0 with respect to such that a 1 m 1 +· · ·+a t m t = b i . Then we have 1 = 0 if we write L i as ( 1 , . . . , t ). For each L i = (0,\nThe footprint of I, denoted by ∆(I), is {(m 1 , . . . , m t ) ∈ N t 0 | X m 1 1 · · · X m t t is not the leading monomial of any nonzero polynomial in I with respect to }, and deﬁne B = {x m 1 1 · · · x m t t | (m 1 , . . . , m t ) ∈ ∆(I)}. Then B is a basis of L(∞Q) as an F q - linear space [1], two distinct elements in B have di ﬀerent pole\ny i | m ∈ N 0 , i = 0, . . . , a 1 − 1}. \t (1) Equation (1) shows that L(∞Q) is a free F q [x 1 ]-module with a basis {y 0 , . . . , y a 1 −1 }.\nLet v Q be the unique valuation in F associated with the place Q. The semigroup S = H(Q) is equal to S = {ia 1 − v Q (y j ) | 0 ≤ i, 0 ≤ j < a 1 }. For each nongap s ∈ S there is a unique monomial x i 1 y j ∈ L(∞Q) with 0 ≤ j < a 1 such that −v Q (x i 1 y j ) = s by [18, Proposition 3.18], and let us denote this monomial by ϕ s . Let Γ ⊂ S , and we may consider the one-point codes\nC Γ = (ϕ s (P 1 ), . . . , ϕ s (P n )) | s ∈ Γ . \t (2) One motivation for considering these codes is that it was shown in [3] how to increase the dimension of the one-point codes without decreasing the bound for the minimum distance.\nIn the famous list decoding algorithm for the one-point AG codes in [12], we have to compute the univariate interpolation polynomial whose coe ﬃcients belong to L(∞Q). Lee and O\u2019Sullivan [15] proposed a faster algorithm to compute the interpolation polynomial for the Hermitian one-point codes. Their algorithm was sped up and generalized to one-point AG codes over the so-called C ab curves [19] by Beelen and Brander [4] with an additional assumption. In this section we generalize Lee-O\u2019Sullivan\u2019s procedure to general one-point AG codes with an assumption weaker than [4, Assumption 2], which will be introduced in and used after Assumption 2.\nLet m be the multiplicity parameter in [12]. Lee and O\u2019Sullivan introduced the ideal I r ,m containing the interpo- lation polynomial corresponding to the received word r and the multiplicity m. The ideal I r ,m contains the interpolation polynomial as its minimal nonzero element with respect to the monomial order. We will give another module I r ,m for general algebraic curves, from which we can also obtain the required interpolation polynomial.\nLet r = (r 1 , . . . , r n ) ∈ F n q be the received word. For a divisor G of F, we deﬁne L(−G + ∞Q) = ∞ i =1 L(−G + iQ). We see that L(−G + ∞Q) is an ideal of L(∞Q) [17].\nLet h r ∈ L(∞Q) such that h r (P i ) = r i . Computation of such h r is easy provided that we can construct generator matrices for C u for every u. We can choose h r so that −v Q (h r ) ≤ n +2g−1.\nLet Z be transcendental over L(∞Q), and D = P 1 +· · ·+ P n . Deﬁne the set I r ,m = {Q(Z) ∈ L(∞Q)[Z] | Q(Z) has multi- plicity m for all (P i , r i )}. This deﬁnition of the multiplicity is the same as [12]. Therefore, we can ﬁnd the interpolation polynomial used in [12] from I r ,m . We shall explain how to ﬁnd e ﬃciently the interpolation polynomial from I r ,m .\nFor i = 0, . . . , m and j = 0, . . . , a 1 − 1, let η i , j to be an element in L(−iD + ∞Q) such that −v Q (η i , j ) is the minimum among {−v Q (η) ∈ L(−iD +∞Q) | −v Q (η) ≡ j (mod a 1 )}. Such elements η i , j can be computed by [17] before receiving r. It was also shown [17] that {η i , j | j = 0, . . . , a 1 − 1} generates L(−iD + ∞Q) as an F q [x 1 ]-module. Note also that we can choose η 0,i = y i deﬁned in Sec. II. By Eq. (1), all η i , j and h r can be expressed as polynomials in x 1 and y 0 , . . . , y a 1 −1 . Thus\nTheorem 1: Let ≥ m. {(Z − h r ) m−i η i , j | i = 0, . . . , m, j = 0, . . . , a 1 − 1} ∪{Z −m (Z − h r ) m η 0, j | = 1, . . . , j = 0, . . . , a 1 − 1} generates I r ,m, = I r ,m ∩ {Q(Z) ∈ L(∞Q)[Z] | deg Z Q (Z) ≤ } as an F q [x 1 ]-module.\nC. Computation of the Interpolated Polynomial from the In- terpolation Ideal I r ,m\nFor (m 1 , . . . , m t , m t +1 ), (n 1 , . . . , n t , n t +1 ) ∈ N t +1 0 , we deﬁne the monomial order u in F q [X 1 , . . . , X t , Z] such that (m 1 , . . . , m t , m t +1 ) (n 1 , . . . , n t , n t +1 ) if a 1 m 1 +· · ·+a t m t +um t +1 > a 1 n 1 + · · · +a t n t +un t +1 , or a 1 m 1 +· · ·+a t m t +um t +1 = a 1 n 1 +· · ·+a t n t + un t +1 , and m 1 = n 1 , m 2 = n 2 , . . . , m i− 1 = n i− 1 , m i < n i , for some 1 ≤ i ≤ t + 1. As done in [15], the interpolation polynomial is the smallest nonzero polynomial with respect to u in the preimage of I r ,m . Such a smallest element can be found from a Gröbner basis of the F q [x 1 ]-module I r ,m, in Theorem 1. To ﬁnd such a Gröbner basis, Lee and O\u2019Sullivan proposed the following general purpose algorithm as [15, Algorithm G].\nTheir algorithm [15, Algorithm G] e ﬃciently ﬁnds a Gröb- ner basis of submodules of F q [x 1 ] s for a special kind of generating set and monomial orders. Please refer to [1] for Gröbner bases for modules. Let e 1 , . . . , e s be the standard basis of F q [x 1 ] s . Let u x , u 1 , . . . , u s be positive integers. Deﬁne the monomial order in F q [x 1 ] s such that x n 1 1 e i LO x n 2 1 e j if n 1 u x + u i > n 2 u x + u j or n 1 u x + u i = n 2 u x + u j and i > j. For f = s i =1 f i (x 1 )e i ∈ F q [x 1 ] s , deﬁne ind( f ) = max{i | f i (x 1 ) 0}, where f i (x 1 ) denotes a univariate polynomial in x 1 over F q . Their algorithm [15, Algorithm G] e ﬃciently computes a Gröbner basis of a module generated by g 1 , . . . , g s ∈ F q [x 1 ] s such that ind(g i ) = i. The computational complexity is also evaluated in [15, Proposition 16].\nLet be the maximum Z-degree of the interpolation poly- nomial in [12]. The set I r ,m, in Theorem 1 is an F q [x 1 ]- submodule of F q [x 1 ] a 1 ( +1) with the module basis {y j Z k | j = 0, . . . , a 1 − 1, k = 0, . . . , }.\nAssumption 2: We assume that we have f ∈ L(∞Q) whose zero divisor ( f ) 0 = D.\nObserve that Assumption 2 is implied by [4, Assumption 2] and is weaker than [4, Assumption 2]. Let f be the ideal of L(∞Q) generated by f . By [17, Corollary 2.3] we have L(−D + ∞Q) = f . By [17, Corollary 2.5] we have L(−iD + ∞Q) = f i .\nWithout loss of generality we may assume existence of x ∈ L(∞Q) such that f ∈ F q [x ]. By changing the choice of x 1 , . . . , x t if necessary, we may assume x 1 = x and f ∈ F q [x 1 ] without loss of generality, while it is better to make −v Q (x 1 ) as small as possible in order to reduce the computational complexity. Under the assumption f ∈ F q [x 1 ], f i y j satisﬁes the required condition for η i , j in Theorem 1. By naming y j z k as e 1 + j+ku , the generators in Theorem 1 satisfy the assumption in [15, Algorithm G] and we can e ﬃciently compute the interpolation polynomial required in the list decoding algorithm in [12].\nProposition 3: We assign the weight −iv Q (x 1 ) − v Q (y j ) + ku to the module element x i 1 y j z k when we use [15, Algorithm G] to ﬁnd the minimal Gröbner basis of I r ,m, . Under Assumption 2, the number of multiplications in [15, Algorithm G] with the generators in Theorem 1 is at most\nA unique decoding algorithm for one-point codes over C ab curves has recently been introduced in [14]. This algorithm is also based on the interpolation approach, an ideal containing the interpolation polynomials of a received word is computed. Moreover, the algorithm in [14] combines the interpolation ap- proach with syndrome decoding with majority voting scheme. However, this algorithm only considers the non-improved code C u assuming that u < n.\nThe aim of this section is to extend this algorithm for one-point codes deﬁned over general curves without assuming u < n, besides, the modiﬁed algorithm performs list decoding. Furthermore, we can speed up the algorithm and deal with Feng-Rao improved codes by changing the majority voting. Still, the main structure of the algorithm remains the same. We stress that we do not assume Assumption 2 in this section.\nLet F/F q be an algebraic function ﬁeld as in Sec. II, we consider the same notation and concepts already introduced in Secs. II and III. Let Γ = {s 1 , s 2 , . . . , s k } ⊂ S and consider the code C Γ deﬁned in Eq. (2). We will assume that Γ = Γ indep , where\nΓ indep = {s ∈ Γ | ev(ϕ s ) ev(ϕ s ) : s ∈ Γ, s < s }, (4) since there is no interest in considering s ∈ Γ \\ Γ indep . Let r be a received word. Choose any codeword in C Γ as c and deﬁne e (c) = r − c. Then there is a unique\nAs in Sec. III-C, we consider L(∞Q) as an F[x 1 ]-module of rank a 1 with basis {y j | 0 ≤ j < a 1 }. For f ∈ F[x 1 ], we denote by f [x k 1 ] the coe ﬃcient of the term x k 1 in f .\nThe following ideal containing the interpolation polynomial for a received word r is deﬁned in [14],\nMoreover, I r is a special case of the interpolation ideal in [15]. Thus, by Sec. III, we have that L(∞Q)z ⊕ L(∞Q) is a free F q [x 1 ]-module of rank 2a 1 with basis {y j z , y j | 0 ≤ j < a 1 }. Hence an element in L(∞Q)z ⊕ L(∞Q) can be uniquely expressed by monomials in\npressed by monomials in Ω 0 = {x i 1 y j | 0 ≤ i, 0 ≤ j < a 1 } . By the previous section,\ni ∈ L(∞Q) such that −v Q ( i ) is the minimum among { f ∈ J e (c) | −v Q ( f ) ≡ i (mod a 1 )}, for i = 0, . . . , a 1 − 1. One has that { 0 , 1 , . . . , a 1 −1 } is a module-Gröbner basis with respect to the restriction to L(∞Q) of the order > u introduced in Sec. III-C (which is independent of u). Note that −v Q (J e (c) ) = {s − v Q ( i )|0 ≤ i < a 1 , s ∈ S }. Then\nBefore describing the algorithm, we remark that its cor- rectness is based in a straightforward generalization of some results in [14, Sec. III-A]. In particular, we will directly refer to these results in the description of the algorithm, because\nthe same proofs in [14] will hold after considering y j instead of y j and prec(s) instead of s − 1, where prec(s) = max{s ∈ S : s < s}, for s ∈ S . The reader should also be aware that in this section we follow the notation of previous sections, however, the notation in [14] is di ﬀerent. Namely, P ∞ denotes Q , R denotes L(∞Q), δ denotes −v Q , x denotes x 1 and the semigroup S is the one generated by {a, a 1 , . . . , a t } in [14].\nWe can now describe the extension of the algorithm in [14]. For a constant τ ∈ N the following procedure ﬁnds all the codewords within Hamming distance τ from the received word r\n1) Initialization: Let N = −v Q (h r ) and G be the Gröbner basis of the F q [x 1 ]-module I r deﬁned above. Let r (s k ) = r and B (s k ) = G. We consider now the steps Pairing, Voting, Rebasing for s ∈ S ∩ [0, N] in decreasing order until the earlier termination condition is veriﬁed or, otherwise, until s = s 1 .\n(7) and we will determine ω s by majority voting in step 3) provided that wt(e ) ≤ τ. Let B (s) = {g (s) i , f (s) i | 0 ≤ i < a 1 } be a Gröbner basis of the F q [x 1 ]-module I r (s) with respect to > s where\nand let ν (s) i = LC(d i ,i ). We assume that LT( f (s) i ) = a i ,i y i z and LT(g (s) i ) = d i ,i y i . By [14, Lemmas 2,3,4], one has that\nand −v Q (a i ,i y i ) ≤ −v Q ( i ) and −v Q (d i ,i y i ) ≤ −v Q (η i ) or, equivalently, deg(a i ,i ) ≤ deg x 1 (LT( i )) and deg(d i ,i ) ≤ deg x\nFor 0 ≤ i < a 1 , there are unique integers 0 ≤ i < a 1 and k i satisfying\n−v Q (a i ,i y i ) + s = a 1 k i − v Q (y i ). Note that by the deﬁnition above\ni = i + s mod a 1 , \t (8) and the integer −v Q (a i ,i y i ) + s is a nongap if and only if k i ≥ 0. Now let c i = deg x (d i ,i ) − k i . Note that the map i → i is a permutation of {0, 1, . . . , a − 1} and that the integer c i is deﬁned such that a 1 c i = −v Q (d i ,i y i ) + v Q (a i ,i y i ) − s.\n3) Voting: For each i ∈ {0, . . . a 1 − 1}, we set µ i = LC(a i ,i y i ϕ s ), w i = − b i ,i [x k i ] µ\nWe remark that the leading coe ﬃcient µ i must be con- sidered after expressing a i ,i y i ϕ s by monomials in Ω 0 . Let\nThe error correction capability of the algorithm will be determined by the values ν(s). The number ν(s) was introduced in [14, Proposition 10], we will show in Proposition 4 that it is equivalent to the cardinality of some sets introduced in [3] for bounding the minimum\nWe consider two di ﬀerent candidates depending on whether s ∈ Γ or not:\nLet w s = w. If several w\u2019s satisfy the condition above, repeat the rest of the algorithm for each of them. As s decreases, ν(s) increases and at some point we have 2τ < ν(s) and at that point at most one w veriﬁes condition (10).\nAn interesting di ﬀerence to the Feng-Rao majority vot- ing is as follows: In the Feng-Rao voting, when wt(e) is large, voting for the correct codeword can disappear, i.e., there can be no vote for the correct codeword. In contrast to this, in the Gröbner based majority voting, the correct codeword always has a vote, because I r contains all the possible codewords and errors.\n4) Rebasing: We consider the automorphism of L(∞Q)[z] given by z → z + wϕ s that preserves the leading terms with respect to > s . Hence B (s) is mapped to a set which is a Gröbner basis of { f (z + wϕ s ) | f ∈ I r (s) } with respect to > s . However, this set is not (in general) a Gröbner basis with respect to > prec(s) , which will be used in the next iteration. Thus, we will update it, for each i ∈ {0, . . . a 1 − 1}:\n> 0, then let g (prec(s)) i \t = f (s) i (z + wϕ s )\ng (s) i (z + wϕ s ) and let ν (prec(s)) i \t = µ i (w − w i ).\n\u2022 If w i \t w and c i ≤ 0, then let g (prec(s)) i \t = g (s) i (z + wϕ s )\nx −c i g (s) i (z + wϕ s ) and let ν (prec(s)) i \t = ν (s) i .\nis a Gröbner basis of { f (z + wϕ s ) | f ∈ I r (s) } = I r (prec(s)) with respect to > prec(s) , where r (prec(s)) = r (s) − ev(wϕ s ). We remark that the new Gröbner basis B (prec(s)) must be considered after expressing it by monomials in Ω 1 .\n5) Earlier termination: The module I r is a curve theoretic generalization of the genus zero case considered in [2, Deﬁnition 9]. Let f min = α 0 + zα 1 having the smallest −v Q (α 1 ) among f (prec(s)) 0 \t , . . . , f (prec(s)) a\n. When the genus is zero and the number of errors is less than half the minimum distance, we can immediately ﬁnd the codeword by −α 0 /α 1 [2, Theorem 12].\niteration in this algorithm shrinks, where Γ (s) = {s ∈ Γ | s ≤ s}, while the number of errors remains the same, at some point its minimum distance becomes relatively large compared to the number of errors. Then f min should provide the codeword by −α 0 /α 1 . Actually, this phenomenon has also been veriﬁed by our computer experiments in Sec. IV-D.\nHence, we propose the following earlier termination criterion: Let d AG (C Γ ) = min s∈ Γ ν(s) be the bound for the minimum distance in [3]. If d AG (C Γ (prec(s)) ) > 2τ, then check whether α 0 /α 1 ∈ L(∞Q), ev(−α 0 /α 1 ) ∈ C Γ (prec(s)) and\n       \n       \nϕ s ) into the list of codewords, and avoid proceeding with prec(s). Otherwise, iterate the procedure with prec(s).\nThe procedure above is based on the following observa- tions:\n\u2022 If there exists a codeword c ∈ C Γ (prec(s)) with Ham- ming distance ≤ τ from r (prec(s)) , then, by Proposition 5, executing the iteration on I r (prec(s)) gives the only codeword c as the list of codewords, corresponding to −α 0 /α 1 . Therefore, iterations with lower s are meaningless.\n\u2022 It was proved in [5, Lemmas 2.3 and 2.4], that if 2wt(ev(β)−r (prec(s)) ) +2g < n−s then β must appear as − α 0 /α 1 . Then we can terminate the algorithm at lat- est s = max{s | 2τ + 2g < n − s}. Because, under this assumption, any other codeword ev(β ) ∈ C Γ (prec(s)) gives −α 0 /α 1 with −v Q (α 1 ) > −v Q (α 1 ), hence β\ncannot correspond to f min . Note that the genus zero case was proved in [2, Theorem 12].\n6) Termination: After reaching s = max{s | 2τ + 2g < n − s} or after verifying the earlier termination condition, include the recovered message (w s 1 , w s 2 , . . . , w s k ) in the output list.\nIn [14], ν(s) was introduced in the same way as in Eq. (9). We claim that ν(s) is equivalent to the sets used in [3], [9] for bounding the minimum distance. Let Γ indep as in Eq. (4). Let S indep = {u | C u C u− 1 }. Deﬁne\nλ(s) = |{ j ∈ S | j + s ∈ S indep }| . \t (11) The bound in [3, Propositions 27 and 28] for the minimum distance of C Γ is\nThe following proposition implies that d u = min{ν(s) | s ∈ S , s ≤ u} is equivalent to d AG (C u ), and therefore [3, Theorem 8] implies [14, Proposition 12].\nWe will prove in this section the correctness and error correction capability of the algorithm. Using [14, Lemmas 6,7 and Proposition 8] we have the following proposition that is an extension of [14, Proposition 10].\nProposition 5: Let λ(s) = ν(s) as in Eqs. (9) and (11). We have\nOne has that the set B (s) is a Gröbner basis of the F q [x 1 ]- module I r (s) with respect to > s by [14, Proposition 11] and combining this with Proposition 5, we obtain the error cor- rection capability of the algorithm in Sec. IV-A as a unique decoding algorithm. Moreover, it a list-decoding algorithm with error bound τ by Eq. (10).\nTheorem 6: Let r = c + e(c). If wt(e(c)) ≤ τ then c is in the output list of the algorithm in Sec. IV-A. If 2wt(e(c)) < d AG (C Γ ) then w s = ω s for all s ∈ Γ and\nD. Computer experiments: Comparison against Guruswami- Sudan algorithm\nWe implemented the proposed list decoding algorithm on Singular [11] and decoded 1,000 randomly generated code- words with the following conditions. Firstly we used the one- point primal code C u with u = 20 on the Klein quartic over F 8 . It is [23, 18] code and its AG bound [3] is 4 while Goppa bound is 3. Guruswami-Sudan decoding can decode up to 1. Our algorithm can list all the codewords within Hamming distance 2. The errors were uniformly randomly generated among the vectors with Hamming weight 2 and executed the decoding algorithm with τ = 2. With 757 transmissions the list size was 1, with 180 transmissions the list size was 2, and with 63 transmissions the list size was 3, where the list size means the number of codewords whose Hamming distance from the received word is ≤ τ. The maximum number of iterations was 266, the minimum was 11, the average was 195.7, and the standard deviation was 60.5.\nSecondly we used the improved code construction [6] with the designed minimum distance 6. It is a [64, 55] code. In order to have the same dimension by C u we have to set u = 60, whose AG bound [3] is 4 and the Guruwsami-Sudan can correct 2 errors. The proposed algorithm ﬁnds all codewords in the improved code with 3 errors. The errors were uniformly randomly generated among the vectors with Hamming weight 3. With 998 transmissions the list size was 1, and with 2 transmissions the list size was 2. The maximum number of iterations was 1128, the minimum was 14, the average was 794.2, and the standard deviation was 179.8.\nThirdly we used the same code as the second experiment, while the errors with Hamming weight 3 were randomly gener- ated toward another nearest codeword. With 901 transmissions the list size was 2, and with 99 transmissions the list size was 5. The maximum number of iterations was 818, the minimum was 196, the average was 754.5, and the standard deviation was 185.3. Observe that the list size cannot become 1 under this condition, and the simulation conﬁrmed it.\nWe generalized the two decoding algorithms [15], [14] to all algebraic curves. We also extend the latter algorithm [14] to a list decoding one. The resulted list decoding algorithm can correct more errors than the Guruswami and Sudan algorithm [12]. The detailed analysis of the computational complexity of the latter one is a future research agenda.\nThe authors would like to thank an anonymous reviewer for pointing out errors in the initial manuscript. This research was partially supported by the MEXT Grant-in-Aid for Scientiﬁc\nResearch (A) No. 23246071, the Villum Foundation through their VELUX Visiting Professor Programme 2011\u20132012, the Danish National Research Foundation and the National Sci- ence Foundation of China (Grant No.11061130539) for the Danish-Chinese Center for Applications of Algebraic Geome- try in Coding Theory and Cryptography and by Spanish grant MTM2007-64704."},"refs":[{"authors":[{"name":"W. W. Adam"},{"name":"P. Loustauna"}],"title":{"text":"An Introduction to Gröbner Bases, ser"}},{"authors":[{"name":"M. Ali"},{"name":"M. Kuijper"}],"title":{"text":"A parametric approach to list decoding of Reed-Solomon codes using interpolation"}},{"authors":[{"name":"H. E. Andersen"},{"name":"O. Geil"}],"title":{"text":"Evaluation codes from order domain theory"}},{"authors":[{"name":"P. Beelen"},{"name":"K. Brander"}],"title":{"text":"E ﬃcient list decoding of a class of algebraic- geometry codes"}},{"authors":[{"name":"P. Beelen"},{"name":"T. Høholdt"}],"title":{"text":"The decoding of algebraic geometry codes"}},{"authors":[{"name":"G. L. Feng"},{"name":"T. R. N. Rao"}],"title":{"text":"Improved geometric Goppa codes part I, basic theory"}},{"authors":[{"name":"O. Geil"},{"name":"R. Matsumoto"},{"name":"D. Ruano"}],"title":{"text":"List decoding algorithm based on voting in Gröbner bases for general one-point AG codes"}},{"authors":[],"title":{"text":"Generalization of the Lee-O\u2019Sullivan list decoding for one-point AG codes"}},{"authors":[{"name":"O. Geil"},{"name":"C. Munuera"},{"name":"D. Ruano"},{"name":"F. Torres"}],"title":{"text":"On the order bounds for one-point AG codes"}},{"authors":[{"name":"O. Geil"},{"name":"R. Pellikaan"}],"title":{"text":"On the structure of order domains"}},{"authors":[{"name":"G.-M. Greuel"},{"name":"G. Pﬁster"},{"name":"H. Schönemann"}],"title":{"text":"Singular 3.0"}},{"authors":[{"name":"V. Guruswami"},{"name":"M. Sudan"}],"title":{"text":"Improved decoding of Reed-Solomon and algebraic-geometry codes"}},{"authors":[{"name":"K. Lee"}],"title":{"text":"Unique decoding of plane AG codes revisited"}},{"authors":[{"name":"K. Lee"},{"name":"M. Bras-Amorós"},{"name":"M. E. O\u2019Sullivan"}],"title":{"text":"Unique decoding of plane AG codes via interpolation"}},{"authors":[{"name":"K. Lee"},{"name":"M. E. O\u2019Sullivan"}],"title":{"text":"List decoding of Hermitian codes using Gröbner bases"}},{"authors":[{"name":"J. B. Little"}],"title":{"text":"List decoding for AG codes using Gröbner bases"}},{"authors":[{"name":"R. Matsumoto"},{"name":"S. Miura"}],"title":{"text":"Finding a basis of a linear system with pairwise distinct discrete valuations on an algebraic curve"}},{"authors":[],"title":{"text":"On construction and generalization of algebraic geometry codes"}},{"authors":[{"name":"S. Miura"}],"title":{"text":"Algebraic geometric codes on certain plane curves"}},{"authors":[],"title":{"text":"Linear codes on a ﬃne algebraic curves"}},{"authors":[{"name":"K. Saints"},{"name":"C. Heegard"}],"title":{"text":"Algebraic-geometric codes and multidimen- sional cyclic codes: A uniﬁed theory and algorithms for decoding using Gröbner bases"}},{"authors":[{"name":"L.-Z. Tang"}],"title":{"text":"A Gröbner basis criterion for birational equivalence of a ﬃne varieties"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569560833.pdf"},"links":[],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S1.T5.2","endtime":"10:30","authors":"Olav Geil, Ryutaroh Matsumoto, Diego Ruano","date":"1341223800000","papertitle":"List Decoding Algorithms based on Gröbner Bases for General One-Point AG Codes","starttime":"10:10","session":"S1.T5: List Decoding and Reed-Solomon Codes","room":"Kresge Little Theatre (035)","paperid":"1569560833"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
