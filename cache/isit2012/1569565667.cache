{"id":"1569565667","paper":{"title":{"text":"An Analytic Upper Bound on T-Complexity"},"authors":[{"name":"Ulrich Speidel"},{"name":"T. Aaron Gulliver"}],"abstr":{"text":"Abstract\u2014The Titchener T-complexity C T of a string has appli- cations in, e.g., randomness testing, event detection and similarity comparison. Like the Lempel-Ziv production complexity, the upper bound of C T is demonstrably not a linear function of the string length. Knowledge of the bound for a given length is however required in order to convert C T into a measure with linear upper bound such as Titchener\u2019s T-information. For this reason, the upper bound of C T has been investigated before by several authors, with various asymptotic solutions proposed. We present a new analytic closed-form asymptotic upper bound for C T based on the Hurwitz-Lerch zeta function."},"body":{"text":"Let A be a ﬁnite alphabet and let A ∗ denote the set of all ﬁnite strings over A. For x, y ∈ A ∗ , let xy denote the concatenation of x and y. For α ∈ IN and the empty string λ, let x α denote the concatenation of α copies of x, with x 0 = λ.\nTitchener\u2019s T-codes [3], [4] are variable length codes con- structed from A in i ∈ IN via a recursive copy and append process called T-augmentation. Starting with A as a trivial T- code, T-augmentation is deﬁned by the following recurrence\ndenotes the T-code (set) after i T- augmentation (TA) steps. p i+1 is called the (i + 1)th T- preﬁx and k i+1 is referred to as the (i + 1)th T-expansion parameter . T-augmentation may also be visualised graphically as copying the decoding tree of A (k 1 ,k 2 ,...,k i ) (p\na total of k i+1 + 1 times and connecting the copies to each other via the codeword (leaf node) p i+1 . The resulting tree is then that\n. The number of T-augmentation steps i is called the T-augmentation level; A (k 1 ,k 2 ,...,k i+1 ) (p\nis thus a code at T-augmentation level i + 1.\nIf all k i+1 = 1 in a series of TAs, we write the code as A (p 1 ,p 2 ,...,p i ) and refer to the code and the TA sequence as simple . If x ∈ A (p 1 ,p 2 ,...,p i ) =⇒ |x| ≥ |p i+1 |, the code and the sequence are said to be minimal, and strictly minimal if |p i+1 | ≥ |p i | for all i. If they are both simple and minimal, they are said to be systematic if x ∈ A (p 1 ,p 2 ,...,p i ) =⇒ |x| ≥ |p i+1 |.\nT-codes have the special property that their T-preﬁxes and T-expansion parameters can be recovered from any of their longest codewords ˆ xa. These longest codewords are unique for each code and have the form\nsuch that ˆ x uniquely identiﬁes the set. Moreover, for each ﬁnite string ˆ x, there exists a unique T-code whose codewords are ˆ xa for a ∈ A, i.e., the mapping between T-codes and ﬁnite strings is bijective. An algorithm that derives the p i and k i for any given ˆ x is referred to as T-decomposition. An O(|x| log |x|) version of the algorithm exists and has been implemented [8]. Titchener [5] deﬁned the T-complexity C T of A (k 1 ,k 2 ,...,k n ) (p\n(or recovered by T-decomposition of ˆ x). C T represents the number of bits required to address the state space of a T-code decoder, i.e., the log of the number of internal nodes in the decoding\n. Titchener showed that the upper bound for C T is not linear in |ˆ x|. He also conjectured on the basis of empirical evidence that the logarithmic integral [1] was asymptotically equivalent to the upper bound of C T .\nThis has since been revisited by Titchener et al. [9], Spei- del [10], Hamano and Yamamoto [12], Hamano [13], and Clark and Teutsch [14].\nIn this paper, we discuss the background of some of their results and present a new analytic asymptotic bound based on the expansion of the Hurwitz-Lerch zeta function [7].\nThe upper bound may be approached in two ways: as the shortest |ˆ xa| for a given C T , or as the largest C T for a given |ˆ xa|. The former route was chosen by all authors above, and also the one chosen for deriving our result here (although, strictly speaking, one ought to refer to the problem as the lower bound on string length for a given T-complexity). This route is assisted by a number of conjectures which have at times been supported by informal arguments, but may also be formalised by the following theorems.\nand two distinct codewords w 1 , w 2 ∈ A (k 1 ,k 2 ,...,k i−1 ) (p\n. Consider now two successive TAs of A (k 1 ,k 2 ,...,k i−1 ) (p\nwith two T-expansion parameters κ 1 and κ 2 such that the T-preﬁxes p i and p i+1 are chosen from {w 1 , w 2 }, respectively, and the T-expansion parameter associated with w 1 is κ 1 and that associated with w 2 is κ 2 . Then\nProof: C T depends on the T-expansion parameters only, and all we do here is swap two terms in the sum in (3). The codeword length distributions in both cases are based on the\n. The ﬁnal sets in each case result from applying (1) twice. In the ﬁrst case, A (k 1 ,k 2 ,...,k i−1 ,κ 1 ,κ 2 ) (p\n, we get the following subsets of codewords for 0 ≤ κ ≤ κ 1 and 0 ≤ κ ≤ κ 2 unless stated otherwise.\n\\{w 1 , w 2 }. Note that the codeword distribution of this subset would be the same if we ﬁrst T-augmented with w 2 and κ 2 and then with w 1 and κ 1 .\n2) Codewords from the ﬁrst TA of the form w κ 1 w 2 . In the second TA, these turn into codewords of the form w κ 2 w κ 1 w 2 with κ > 0. This subset has the same codeword length distribution as the set of codewords of the form w κ +1 2 w κ 1 with κ > 0.\n3) The codeword w κ 1 +1 1 \t from the ﬁrst TA, which gives rise to the codewords w κ 2 w κ 1 +1 1 \t in the second TA.\nThe union of the last three of these subsets with the string w κ 2 +1 2 w κ 1 +1 1 \t and the empty string can be written as w k 2 2 w k 1 1\nwith 0 ≤ k 1 ≤ κ 1 + 1 and 0 ≤ k 2 ≤ κ 2 + 1, respectively. Note that the codeword distribution of this union would also be the same if we ﬁrst T-augmented with w 2 and κ 2 and then with w 1 and κ 1 and used w κ 1 +1 2 w κ 2 +1 1 \t instead of w κ 2 +1 2 w κ 1 +1 1 . Thus, the codeword length distribution is invariant under a change in the order of the T-augmentations.\nCorollary 2.2: The length of the longest codewords and the T-complexity of the code / longest codewords are invariant under a change in the order of the T-augmentations.\nN.B.: This follows immediately from the fact that any change in the order of the TAs can be reduced to a series of pair-wise swaps of TAs, to each of which the previous theorem can be applied.\nwith the same T-complexity and codeword length distribution as that of C, such that |p i | ≤ |p j | for all i < j.\nProof: by construction. Given C, we can apply a series of pair-wise swaps in accordance with Theorem 2.1 such that\nTheorem 2.4: A T-code C whose longest codewords ˆ xa are the shortest for a given C T does not contain codewords shorter than the longest T-preﬁx, i.e., C is minimal.\nProof: Presume that C is not minimal. Then there exists a codeword w ∈ C that is shorter than at least one of the T- preﬁxes in the construction of C. The proof of Theorem 2.3 implies that there exists a T-code A (k 1 ,k 2 ,...,k n ) (p\nwith the same codeword and T-preﬁx length distribution as C such that p n is the longest T-preﬁx and that contains a word w with |w | = |w| < |p n |. This means that w ∈ A (k 1 ,k 2 ,...,k n−1 ) (p\nas a TA cannot generate new codewords that are shorter than the T- preﬁx. Thus, we could use w in place of p n for the last TA, and by (2) obtain longest codewords shorter than ˆ xa. Thus, C must be minimal.\nThe published literature to date also generally assumes that the shortest |ˆ xa| for a given C T is achieved when the associ- ated T-code is systematic or concentrates on this case [9], [10], [12], [13]. This assumption is naturally restricted, as k i = 1 in (3) implies that C T will be an integer.\nIn [11] the authors and Makwakwa derived a number of results which are not based on this assumption. The following theorem is a partial summary of these results and is given here without proof:\n\u2022 No two distinct codewords in a T-code belong to the same cyclic equivalence class (CEC) 1 .\n\u2022 For any given non-periodic CEC, any T-code C either has a T-preﬁx or a codeword from this CEC, or contains codewords that in combination yield a string from that CEC (i.e., such a string can become a codeword as a result of further TAs).\n\u2022 Any codewords from periodic CECs are generated by the last term in (1).\nTheorem 2.6: For any positive integer c, a systematic T- code C with longest codewords of the form ˆ xa exists such that C T (C) = c and |ˆ xa| ≤ | ˆ x a| for any other T-code C\nProof: Theorem 2.4 ensures that the minimality criterion for C can be met. For a minimal C, there exists a minimal length such that |p i | ≤ for all i and all codewords are of length or longer. Equation (1) then implies that any further codewords we can generate by T-augmenting C must be of length 2 or longer, i.e., all possible codewords up to length 2 − 1 have already been created by the TA sequence that generated C. By Theorem 2.5, all non-periodic codewords of these lengths have already been generated, one for each non- periodic cyclic equivalence class, and any such codeword up\nto length − 1 would have been used as a T-preﬁx. If a non- systematic C were to yield shorter ˆ x a for C T (C ) = c, this could conceivably happen in one of two ways:\n1) By using k i > 1, we might be able to create at least one additional codeword w with |w| < in our TA sequence. If we were to T-augment with w as part of a minimal code C , we could \u201csave\u201d one codeword of length , thereby shortening the longest codewords of C by |w| − . By our argument above, the additional w cannot be non-periodic because the number of non- periodic codewords up to length 2 − 1 is limited by the number of CECs for each length, and minimal TA already guarantees a codeword for each non-periodic CEC for all lengths less than , meaning that all possible non-periodic codewords are already created in other ways. So w would have to be periodic. As every T- augmentation creates exactly one periodic codeword, the only difference that this could make is to the number of periodic codewords that are smaller than and thus eligible to be used as T-preﬁxes in place of a T-preﬁx of length . The baseline k i = 1 case creates the codeword p 2 i , which is part of ˆ x and always shorter than any conceivable w = p k i +1 i \t that we could create with a k i > 1. If we were to use p k i +1 i \t with k i > 1 in such a minimal TA sequence, p 2 i would not be created and thus would not be available as a T-preﬁx, i.e., we would have to substitute p 2 i in ˆ x by the longer string w \u2013 the opposite of what we are trying to achieve. Similarly, any periodic codewords subsequently created as a result of having p k i +1 i \t in the set would have lengths that are multiples of |p k i +1 i |, which would each be longer than the corresponding multiples of |p 2 i | that they might replace. u|p 2 i | ≤ and v|p k i +1 i | ≤ also imply that v ≤ u, i.e., such an attempt cannot increase the number of codewords less than or equal to .\n2) By having a k i = 2 u −1 for some u > 1, and thus having a single T-preﬁx contributing more than 1 to C T (C ) as a simple TA would. However, this means an additional contribution of |p k i −1 i | = (k i − 1)|p i | to ˆ x a over the systematic case. To \u201ccompensate\u201d for this extra length, we could drop u−1 T-preﬁxes of at most length that we would need in the systematic case. This would require (2 u −2)|p i | < (u−1) to yield a shorter ˆ x a. For u = 2, we would need to drop one T-preﬁx of length , which gives the condition 2|p i | < . This implies |p 2 i | < , i.e., p 2 i would have been a T-preﬁx in the simple case. With k i = 3, we now lose this codeword. In order to restore C T , we would have to substitute p 2 i by either p 4 i or a codeword of length , whichever is shorter. If |p 4 i | < , then p 4 i would have to be substituted by p 8 i or a codeword of length , and so on, i.e., we would have to keep doubling the length of the substituting T- preﬁx each time until it reaches or exceeds . At this point, another codeword of at least length would have to be substituted as a T-preﬁx to restore C T (C ). This\nwould negate the gain we just made. For u = 3, we have 6|p i | < 2 , which means we now lose both p 2 i and p 4 i . Following the same argument as before, two substitutes of length at least are required, and again any gains are lost. A similar argument can be given for larger u.\nThus, a non-systematic C cannot yield | ˆ x a| < |ˆ xa|, which proves the theorem 2 .\nSystematic codes thus achieve the shortest |ˆ xa| for inte- ger C T . This result is not unexpected: It is much easier to show that a T-expansion parameter of 1 and the choice of one of the shortest codewords in the code as T-preﬁx result in the maximal possible C T (p\n. This weaker result motivated many previous authors [9], [10], [12], [13] to restrict their treatment to the systematic case. The proof given here however means that this result applies to all TA sequences as long as we restrict C T to integer values, which lends further weight to the motivation for their work.\nFor integer C T , the systematic construction of the bound of C T as a function of |ˆ xa| implies that it is piecewise linear, with gradients from 1 to 1/ . This reﬂects the fact that each additional simple T-augmentation with a T-preﬁx of length\nadds to |ˆ xa| and 1 to C T . The width of the intervals over which the bound is linear with gradient 1/j, for 1 ≤ j ≤ , is given by jm j , where m j is the number of T-preﬁxes of length j ≤ that can occur in a systematic TA sequence.\nTheorem 2.5 implies that m j is related to the number N c (j) of cyclic equivalence classes (CECs) for j: As systematic TA always generates one permutation of each non-periodic ﬁnite string but not of every periodic string, m j is bounded below by the number of non-periodic CECs for strings of length [6]\nwhere µ(m) is the M¨obius function, which is 0 if m is not the product of distinct primes, +1 if it is the product of an even number of distinct primes, and −1 otherwise, with µ(1) = 1. Similarly, m j is bounded above by the total number of CECs for j [6]\nwhere φ(m) is Euler\u2019s totient function, the number of integers less than m and relatively prime to m. As M (#A, j) ≤ #A j /j ≤ N (#A, j), asymptotically we have\nTitchener et al. [9] arrived at (6) via a different path not involving cyclic equivalence. The ﬁrst author of this paper observed the relationship to cyclic equivalence in [10], how- ever still requiring that the bounds for m j be computed\nnumerically. Equation (6) is also used by Hamano and Ya- mamoto in [12] (see also Hamano [13]), who also note the relationship to CECs but do not make use of it, instead deriving their bound for binary strings through a differential equation method. Asymptotically, the bounds or conjectured bounds for C T derived in these papers are compatible and mirror the fundamental form ˆ x/ log ˆ x of the Lempel-Ziv production complexity [2]. Clark and Teutsch [14] on the other hand do not consider asymptotics. They present a \u201cbig-O\u201d bound for C T and arbitrary alphabets as O(|ˆ x| log 2 log #A |ˆ x|/ log 2 #A |ˆ x|.\nFrom the interval widths jm j and (6), we can approximate |ˆ xa| at the end of the th interval by a simple geometric series sum\n+1 − 1 #A − 1\nThis can be written in terms of the Hurwitz-Lerch zeta function Φ as [7]\nwhere the last line uses the ﬁrst two terms of the series expansion of Φ. Substituting (8) for + 1 yields\nNote that the ﬁrst term dominates (11) for large |ˆ xa|. This expression then has the form |ˆ xa|/ log |ˆ xa|, which conﬁrms the earlier results.\nWe now consider the tightness of the bound. For j where the number of words exceeds r j /j, we can use these \u201cexcess\u201d periodic words as substitutes for longer T-preﬁxes. However, as N n (j) and N c (j) are asymptotically equivalent for large j, the bound is asymptotically still tight. Some of these excess words are also needed to \u201ccompensate\u201d for j where there are fewer than r j /j codewords.\nNon-systematic TA is known to yield non-integer C T (ˆ xa) above the piecewise linear bound for systematic TA for some\nˆ xa. However, as we have seen above, the effect of non- systematic TA is restricted to producing different periodic T- preﬁxes only. As their number is asymptotically negligible compared to the available non-periodic codewords, the bound should remain asymptotically tight.\nExperimentally, the true convergence may be assessed by comparison with the actual systematic bound, the |ˆ xa|/ log 2 |ˆ xa| bound, and Titchener\u2019s empirical bound [5], up to string lengths where computing the actual systematic bound is feasible. For C T = 1, 000 under systematic TA of a binary alphabet, we obtain |ˆ xa| = 11, 200. The |ˆ xa|/ log 2 |ˆ xa| bound yields 11, 200/ log 2 11, 200 ≈ 833 here, i.e., just over 83% of the actual value. Our bound for this length suggests ≈ 956 TAs, i.e., 95.6% of the actual value. Titchener\u2019s empirical bound formula using the logarithmic integral comes within less than 0.1% of the actual value. For C T = 5, 000, we have |ˆ xa| = 69, 439, and the values for the respective analytical bounds reach 86.3% and 97.1%, with Titchener\u2019s bound again at more than 99.9% of the actual value. For C T = 10, 000, we have |ˆ xa| = 150, 555, and 87.5% / 97.7% respectively. Titchener\u2019s bound predicts C T ≈ 10, 007.5 for this length.\nAn analytic bound on the T-complexity was derived based on the number of codewords available for use as T-preﬁxes. It is asymptotically tight and applies to ﬁnite alphabets of arbitrary cardinality. Both the bound and our considerations regarding the choice of T-preﬁxes and T-expansion parameters for minimizing the length of the longest codewords vindicate the approach taken and the results obtained in previous publi- cations by various authors. Numerically, the bound presented here converges much faster than the |ˆ xa|/ log 2 |ˆ xa| bound and is easier / faster to compute numerically than the logarithmic integral. Improvements to our bound leading to faster conver- gence are conceivable, e.g., through less coarse approximation and the use of additional terms in the series expansion of Φ."},"refs":[{"authors":[{"name":"M. Abramowit"},{"name":"I. A. Stegu"}],"title":{"text":"Eds"}},{"authors":[{"name":"A. Lempel"},{"name":"J. Ziv"}],"title":{"text":"On the complexity of ﬁnite sequences"}},{"authors":[{"name":"M. R. Titchener"}],"title":{"text":"Digital encoding by means of new T-codes to provide improved data synchronisation and message integrity"}},{"authors":[{"name":"M. R. Titchener"}],"title":{"text":"Generalized T-codes: Extended construction algorithm for self-synchronizing variable-length codes"}},{"authors":[{"name":"M. R. Titchener"}],"title":{"text":"Deterministic computation of string complexity, information and entropy"}},{"authors":[{"name":"K. Cattell"},{"name":"F. Ruskey"},{"name":"J. Sawada"},{"name":"M. Serra"},{"name":"C. R. Miers"}],"title":{"text":"Fast algorithms to generate necklaces, unlabeled necklaces, and irreducible polynomials over GF(2)"}},{"authors":[{"name":"C. Ferreira"},{"name":"J. L. L´opez"}],"title":{"text":"Asymptotic expansions of the Hurwitz- Lerch zeta function"}},{"authors":[{"name":"J. Yang"},{"name":"U. Speidel"}],"title":{"text":"A T-decomposition algorithm with O(n log n) time and space complexity"}},{"authors":[{"name":"M. R. Titchener"},{"name":"A. Gulliver"},{"name":"R. Nicolescu"},{"name":"U. Speidel"},{"name":"L. Staiger"}],"title":{"text":"Deterministic complexity and entropy"}},{"authors":[{"name":"U. Speidel"}],"title":{"text":"On the bounds of the Titchener T-complexity"}},{"authors":[{"name":"T. A. Gulliver"},{"name":"I. Makwakwa"},{"name":"U. Speidel"}],"title":{"text":"On the generation of aperiodic and periodic necklaces via T-augmentation"}},{"authors":[{"name":"K. Hamano"},{"name":"H. Yamamoto"}],"title":{"text":"A differential equation method to derive the formulas of the T-complexity and the LZ-complexity"}},{"authors":[{"name":"K. Hamano"}],"title":{"text":"Analysis and applications of the T-complexity"}},{"authors":[{"name":"G. Clark"},{"name":"J. Teutsch"}],"title":{"text":"Maximizing T-complexity"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569565667.pdf"},"links":[],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S15.T6.1","endtime":"10:10","authors":"Ulrich Speidel, T. Aaron Gulliver","date":"1341568200000","papertitle":"An Analytic Upper Bound on T-Complexity","starttime":"09:50","session":"S15.T6: Fundamental Limits on Complexity","room":"Kresge Rehearsal A (033)","paperid":"1569565667"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
