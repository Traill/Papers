{"id":"1569565241","paper":{"title":{"text":"Observability, Controllability and Local Reducibility of Linear Codes on Graphs"},"authors":[{"name":"G. David Forney"},{"name":"Jr."},{"name":"Heide Gluesing-Luerssen"}],"abstr":{"text":"Abstract\u2014This paper is concerned with the local reducibility properties of linear realizations of codes on ﬁnite graphs.\nTrimness and properness are dual properties of constraint codes. A linear realization is locally reducible if any constraint code is not both trim and proper. On a ﬁnite cycle-free graph, a linear realization is minimal if and only if every constraint code is both trim and proper.\nA linear realization is called observable if it is one-to-one, and controllable if all constraints are independent. Observability and controllability are dual properties. An unobservable or uncontrollable realization is locally reducible. A parity-check realization is uncontrollable if and only if it has redundant parity checks. A tail-biting trellis realization is uncontrollable if and only if its trajectories partition into disconnected subrealizations. General graphical realizations do not share this property."},"body":{"text":"For conventional linear state-space (trellis) realizations of codes or systems, minimality is well understood and can be characterized in many ways; see [8], [2] and the references therein.\nFor realizations on more general graphs, the situation is much less studied and more complicated. In particular, a given code does not have a unique minimal realization on a graph with cycles; see [7] for a detailed discussion of the speciﬁc class of tail-biting trellis realizations. Yet it has long been known that realizations on graphs with cycles can be much simpler, and therefore may allow more powerful iterative decoding algorithms.\nIn this paper, we will study properties of linear realizations on general graphs that allow \u201clocal reduction\u201d operations. For instance, we will show that local reduction is possible if any constraint code in the realization is not both trim and proper; moreover, when the graph of the realization is cycle-free, the converse is sufﬁcient for minimality. We go on to show that a realization is locally reducible if it is not observable (one-to- one) or uncontrollable (has dependent constraints). We show that the effects of uncontrollability are similar for tail-biting trellis realizations to those for conventional trellis realizations, but that this result does not generalize straightforwardly to the general case.\nAll of our realizations will be ﬁnite and linear. We will generally use the notation and terminology of [1] and [7].\nA linear code C over a ﬁnite ﬁeld F is a subspace of a symbol sequence space A = Π k∈I A A k , where each symbol alphabet A k is a ﬁnite-dimensional vector space over F, and I A is a ﬁnite index set. For a state realization of C, we deﬁne also a set {S j : j ∈ I S } of state spaces S j and a set {C i : i ∈ I C } of local constraint codes C i , where each constraint code C i involves some subsets A (i) = k∈I\nS j of the symbol and state variables, respectively. In a linear realization, each state space S j and each constraint code C i is a vector space over F. The state sequence space is\nThe behavior of a realization is the set B of all pairs (a, s) ∈ A × S such that all constraints are satisﬁed; i.e., (a (i) , s (i) ) ∈ C i for all i. The code C that it generates or realizes is the set of all symbol sequences a ∈ A that appear in some (a, s) ∈ B; i.e., the projection B |A of B on A.\nA state realization is called normal if every symbol vari- able is involved in precisely one constraint code, and every state variable is involved in precisely two constraint codes. As shown in [1], any realization may be straightforwardly \u201cnormalized\u201d by introducing replica variables and equality constraints. Therefore we will assume henceforth that all realizations are normal. A normal realization has a natural graphical representation, a normal graph, in which constraint codes are represented by vertices, states by ordinary edges, and symbol variables by half-edges; see [1]. We will assume that all normal graphs are connected.\nA trellis realization is a normal realization in which every constraint code involves precisely two state variables. Thus the graph of a trellis realization must be either a ﬁnite chain graph, called a conventional trellis realization, or a single-cycle graph, called a tail-biting trellis realization. We will depict trellis realizations by traditional trellis diagrams, in which all branches, states and symbols are shown explicitly.\nA realization of a code C will be called observable if for each a ∈ C there is precisely one pair (a, s) ∈ B. We deﬁne the unobservable behavior B u as the set of pairs (0, s) ∈ B; thus a realization is observable iff B u is trivial.\nA realization will be called state-trim if each state appears on a valid trajectory; i.e., if the projection of B onto each S j is S j (surjective). Similarly, using trellis terminology, a real- ization will be called branch-trim if the projection of B onto each constraint code C i is surjective. A state-trim and branch- trim realization is called reduced [7].\nA constraint code C i will be called trim if the projection of C i onto every state space S j that is involved in C i is surjective, and proper if it has no nonzero codewords whose support is a single state space S j .\nAs in [7], a realization with state spaces S j is called minimal if there exists no realization of the same code with state spaces ˜ S j that has the same graph topology (i.e., the same in- dex sets I A , I S , I C , I A (i) , I S (i) ) such that dim ˜ S j ≤ dim S j for all j, with at least one strict inequality. It is well known that on a cycle-free graph a minimal realization is unique up to isomorphism; however, on a graph with cycles, there is in general no unique minimal realization.\nIn this paper, a realization will be called locally reducible if there is a replacement of one state space S j by a smaller state space, and a corresponding reduction of the constraint codes involving S j , such that the resulting realization realizes the same code. (More general notions of local reducibility will be considered in [5].) We use two dual methods of reducing a state space, namely restricting and taking quotients; these operations will be called trimming and merging, respectively.\nWe brieﬂy recall some of the basic duality principles that will be used heavily in this paper, following [1], [4].\nIf V is a ﬁnite-dimensional vector space over a ﬁnite ﬁeld F, then its linear-algebra dual space ˆ V is a vector space over F of the same dimension such that there is a well-deﬁned inner product ·, · : V × ˆ V → F. Given any basis of V , there exists a dual basis for ˆ V such that the inner product of two vectors in V and ˆ V is equal to the dot product of their respective coordinate vectors. Two elements v ∈ V, ˆ v ∈ ˆ V are orthogonal if v, ˆ v = 0.\nIf W ⊆ V is a subspace, then its orthogonal space W ⊥ ⊆ ˆ V is the space of all vectors in ˆ V that are orthogonal to all vectors in W . We have (W ⊥ ) ⊥ = W and ˆ W ∼ = ˆ V /W ⊥ , implying dim W + dim W ⊥ = dim ˆ V = dim V .\nIf V = Π k V k is a ﬁnite direct product of vector spaces V k , then ˆ V = Π k ˆ V k , with inner product given by the componen- twise sum v, ˆ v = k v k , ˆ v k . If W = Π k W k is a direct product of subspaces W k ⊆ V k , then W ⊥ = Π k W ⊥ k ⊆ ˆ V .\nA key duality lemma for linear codes is projection/cross- section duality [1]. For any subset J ⊆ I A of an index set I A , the projection map P J : A → A J = k∈J A k is deﬁned by the map a = {a k : k ∈ I A } → a J = {a k : k ∈ J }. The projection C |J of a linear code C deﬁned on I A on J is then deﬁned as the image of P J : C → A J , a subspace of A J . The cross-section of C on J is deﬁned as C :J = {a J ∈ C J | (a J , 0 I A −J ) ∈ C}, a subspace of C |J . Then we have:\nProjection/cross-section duality. If C and C ⊥ are orthogonal linear codes deﬁned on I A , and J ⊆ I A , then C :J and (C ⊥ ) |J are orthogonal linear codes deﬁned on J .\nIn this paper, our main tool will be normal realization duality , which follows directly from projection/cross-section duality [1]. Given a normal linear realization, its dual realiza- tion is deﬁned as the normal linear realization with the same graph topology in which the variable alphabets A k , S j are replaced by their dual spaces ˆ A k , ˆ S j , the constraint codes C i are replaced by their orthogonal codes C ⊥ i , and the sign of each dual state variable is inverted in one of the two constraints in which it is involved. Then we have:\nNormal realization duality. If a normal realization realizes a linear code C, then its dual realization realizes the orthogonal linear code C ⊥ .\nTo repeat, a linear constraint code C i is trim if the projection of C i onto every state space S j that is involved in C i is S j , and proper if there are no nonzero codewords of C i whose support is a single state space S j .\nTheorem 1. A linear constraint code C i is trim if and only if the orthogonal constraint code C ⊥ i is proper.\nProof : C i is not trim if the projection (C i ) |S j of C i on any state space S j involved in C i is a proper subspace of S j . C ⊥ i is not proper if the cross-section (C ⊥ i ) : ˆ S\nis nontrivial. By projection/cross-section duality, (C ⊥ i ) : ˆ S\nis the orthogonal code to the projection (C i ) |S j . Thus (C ⊥ i ) : ˆ S\nis nontrivial if and only if (C i ) |S j is a proper subspace of S j .\nThis leads immediately to conditions for local reducibility: Theorem 2. A realization containing a constraint code C i that is not both trim and proper is locally reducible.\nProof : A constraint code C i that is not trim may obviously be locally reduced by restricting S j to S j = (C i ) |S j , without changing the code C realized by the realization.\nDually, a linear constraint code C i that is not proper (i.e., involves a state space S j such that T j = (C i ) :S j is nontrivial) may be locally reduced by mapping S j → S j /T j via the natural map s j → s j + T j , with corresponding maps in all constraint codes that involve S j , without changing the code C realized by the realization.\nSince taking quotients as above preserves linearity, it is the appropriate notion of \u201cmerging\u201d for linear realizations.\n3) The state space associated with any edge S j is isomor- phic to C |P j /C :P j , where P j is the \u201cpast\u201d of S j .\n(1 ⇒ 2) By Theorem 2, if any constraint code is not both trim and proper, then the realization is locally reducible.\n(2 ⇒ 3) In a cycle-free graph, every edge S j is a cut set, whose removal partitions the graph into two disconnected subgraphs, P j and F j . If the graph is ﬁnite, then each edge has a ﬁnite past depth d j (maximum distance to any leaf in P j ). By induction on d j , we can show that trimness implies that every state s j ∈ S j is reached by some symbol conﬁguration a P ∈ C |P j , and properness implies that every a P ∈ C |P j reaches a unique state s j ∈ S j . This implies that the set of sequences in P j that reach the zero state in S j is precisely the cross-section C :P j . Moreover, by linearity, if a P (s j ) ∈ C |P j is any sequence that reaches another state s j ∈ S j , then the set of all sequences that reach that state is C :P j + a P (s j ), a coset of C :P j in C |P j . Thus the realization induces a one-to-one map between S j and the quotient space C |P j /C :P j , which by linearity is an isomorphism.\n(3 ⇒ 1) Since S j ∼ = C |P j /C :P j , and by the same argu- ment S j ∼ = C |F j /C :F j , we have that C is the union of the cosets {C :P j × C :F j + (a P (s j ), a F (s j )) : s j ∈ S j }, where {a P (s j ) : s j ∈ S j } and {a F (s j ) : s j ∈ S j } are sets of coset representatives for C |P /C :P and C |F /C :F , respectively. This implies that no further merging of states is possible, so the realization is minimal.\nAlthough the result \u201dtrim + proper = minimal\u201d has long been known for conventional trellis realizations [8], it seems to be new for realizations on more general cycle-free graphs.\nThe proof of Theorem 3 shows constructively that a ﬁnite linear cycle-free realization is minimal if and only if every state space S j is isomorphic to C |P j /C :P j ∼ = C |F j /C :F j which is the essence of the State Space Theorem [1].\nThis result immediately suggests straightforward iterative minimization algorithms, involving a ﬁnite series of local reductions.\nFinally, we observe that the \u201cshortest basis\u201d approach to minimality that is used for conventional linear trellis real- izations (see [2] and references therein) cannot be extended to general cycle-free realizations, because it relies on the \u201cproduct construction\u201d for trellis realizations, which generally does not exist for more general cycle-free graphs. In this respect, the \u201ctrim + proper\u201d approach to minimality may be regarded as more basic than the \u201cshortest basis\u201d approach.\nThe behavior B ⊆ A × S of a linear realization is deﬁned by a system of i dim C ⊥ i linear homogeneous constraint equations. The constraint system is independent if and only if the dimension of the solution space B is equal to the number of variables minus the number of equations; i.e., iff dim B = dim A + dim S − i dim C ⊥ i .\nWe now show that a linear realization has independent constraints if and only if its dual realization is observable. Because of the classical duality between observability and controllability, we will subsequently call a realization with independent constraints controllable.\nTheorem 4. A normal linear realization is controllable (has independent constraints) if and only if its dual realization is observable. Moreover, it is controllable if and only if dim B =\nProof : In view of the normal degree restrictions, the only way that a nontrivial sum of constraints (ˆ a (i) , ˆ s (i) ) ∈ C ⊥ i can equal zero is if all symbol values ˆ a k equal zero, and for each pair of dual state values ˆ s j , ˆ s j ∈ ˆ S j , we have ˆ s j = −ˆ s j . But these are precisely the conditions such that (ˆ 0, ˆ s) is a valid nonzero trajectory in the dual realization; i.e., for the dual realization to be unobservable.\ndim C ⊥ i , substitute dim C ⊥ i = dim A (i) +dim S (i) −dim C i , and note that i dim A (i) = dim A and i dim S (i) = 2 dim S, by the normal degree restrictions.\nWe use the term \u201ccontrollable\u201d even though: (a) this term was introduced at a time when linear system theory was embedded in control theory, which is not our context here; (b) although the behavior of uncontrollable tail-biting trellis realizations is similar to that of uncontrollable conventional trellis realizations, as we will see below in Theorem 7, such uncontrollability properties do not necessarily extend to realizations on general graphs, as we will see in Example 2. The reader who is not so interested in continuity with classical linear system theory might therefore prefer terms like \u201cone- to-one\u201d and \u201cindependent\u201d to \u201cobservable\u201d and \u201ccontrollable.\u201d Example 1 (cf. [7, Fig. 5]). The binary linear (3, 2, 2) block code C = {000, 110, 101, 011} may be realized by the linear tail-biting trellis realization shown in Fig. 1(a), with three binary symbol alphabets, three binary state spaces S 0 = S 1 = S 2 = {0, 1}, and three constraint codes C 0 = C 1 = C 2 = {000, 110, 101, 011}, where C 2 involves S 2 and S 0 . This is a product realization generated by 110, 011, 101 , with the indicated circular spans. Because the all-zero symbol sequence is realized by two trajectories, this realization is unobservable.\nt t\n0 1\nt t\n0 1\nt t\n0 1\nt t\n(a) t t\n    d\nd 0 0\nt t\n  0 0\nt t\n    d\nd 0 0\nt t\nThe dual linear tail-biting trellis realization is shown in Fig. 1(b). (No sign inverters are needed because the ﬁeld is F 2 .) The dual realization realizes the orthogonal (3, 1, 3) code C ⊥ = {000, 111}; however, by Theorem 4 it is uncontrollable, since it is the dual to an unobservable realization. Explicitly, the three constraints corresponding to the branches 101 in the three primal constraint codes (i.e., the components of the nonzero trajectory (0, 1) in the primal behavior) are dependent.\nWe shall see in Theorem 7 that the fact that the dual behavior B ◦ comprises two disjoint paths is another proof that the dual realization is uncontrollable. Alternatively, it is uncontrollable because dim B ◦ = 1, i dim C ⊥ i = 3 and dim ˆ S = i dim ˆ S i = 3.\nWe next consider the familiar classes of generator and parity-check realizations, and determine their observability and controllability properties.\nA generator realization of a linear code C ⊆ F n is speciﬁed by a set of generator n-tuples g i ∈ F n such that C is the set of all linear combinations a = i α i g i . The generators are linearly independent if dim C = . The realization has n symbol variables A k , equality constraints that generate up to n replicas α ik = α i of each of the coefﬁcients α i , and n linear constraint codes that enforce the constraints a k = i α ik g ik . (If g ik = 0, then the replica α ik may be omitted.)\nA parity-check realization of a linear code C is the dual to a generator realization of C ⊥ . Parity-check realizations are used for low-density parity-check (LDPC) codes, for example.\nExample 2. The ﬁve binary 8-tuples 11110000, 00111100, 00001111, 11000011, 01011010 form a set of ﬁve linearly dependent generators for the (8, 4, 4) ﬁrst-order Reed-Muller (RM) code. Since C is self-dual (i.e., C ⊥ = C), the same ﬁve binary 8-tuples form a set of linearly dependent checks for C. The parity-check realization based on these ﬁve check 8-tuples is shown in Fig. 2.\n= = = = = = = =\n+ + + + + \n   \n  \n\u0080 \u0080 \u0080 \u0080\n\u0080 \u0080 \u0080 \u0080\n\u0081 \u0081\n\u0081 \u0081\n\u0081 \u0081\n\u0080 \u0080 \u0080 \u0080\n\u0080 \u0080 \u0080 \u0080\n   \n   \n \n \n \n   \n   \n \n \n \n   \n   \n   \n   \n \n \n \n   \n   \n\u0084 \u0084\n\u0084 \u0084\n\u0084 \u0084\n\u0084 \u0084\n\u0084 \u0084\n\u0084 \u0084\n\u0083 \u0083\n\u0083 \u0083\n\u0083 \u0083\n\u0083 \u0083\n\u0083 \u0083\n\u0081 \u0081\n\u0081 \u0081\n\u0081 \u0081\nd d\nd d\nd d\nd d\n\u0084 \u0084\n\u0084 \u0084\n\u0084 \u0084\n\u0084 \u0084\n\u0084 \u0084\n\u0084 \u0084\nTheorem 5. A generator realization is controllable, and a parity-check realization is observable. A generator realization is observable if and only if its generators are linearly indepen- dent, and a parity-check realization is controllable if and only if its checks are linearly independent.\nProof : A parity-check realization is obviously observable, since all state variables are (multiples of) replicas of symbol variables (see, e.g., Fig. 2). By observability/controllability duality, a generator realization must therefore be controllable.\nIn a generator realization, there is a nonzero conﬁguration (0, s) if and only if there is some nontrivial linear com- bination of the generators that equals the zero codeword 0 ∈ C, which happens if and only if the generators are\nlinearly dependent. Thus a generator realization is observable if and only if its generators are linearly independent. By observability/controllability duality, a parity-check realization is controllable iff its checks are linearly independent.\nFor example, the parity-check realization of Fig. 2 is ob- servable but uncontrollable. So is the realization of Fig. 1(b), which may be viewed as a parity-check realization with the three redundant check 3-tuples 110, 011, 101.\nWe now show how to locally reduce any unobservable or uncontrollable realization.\nTheorem 6. An unobservable linear realization with a nonzero trajectory (0, s) ∈ B may be locally reduced by trimming any single state space in the support of s. The dual uncontrollable realization may be correspondingly locally reduced by the dual merging operation.\nProof : Select any state space S j such that s j = 0 in some unobservable trajectory (0, s) ∈ B. Choose a basis {g j } for S j with g j1 = s j . The coordinates of s j are thus 10 . . . 0. Deﬁne the subspace T j ⊂ S j as the set of all s j ∈ S j such that s j1 = 0, and trim the realization by restricting B to the subbehavior B consisting of those trajectories that pass through a state s j ∈ T j . We may then replace S j by T j , reducing the state space dimension by one. The trajectory (0, s) is then not in the trimmed behavior B , since s j1 = 1. However, given any (a, s ) ∈ B, the entire coset {(a, s +αs) : α ∈ F} is in B and thus realizes a. In this coset, the value of S j1 runs through {s j1 + αs j1 : α ∈ F} = F, so precisely one trajectory (a, s + αs) has ﬁrst state coordinate s j1 + αs j1 = 0. Thus the trimmed realization still realizes every a ∈ C.\nIn the dual realization, the corresponding local reduction is the merging of the states in ˆ S j to their cosets in ˆ S j /(T j ) ⊥ via the natural map. In other words, the ﬁrst coordinate of ˆ S j is simply deleted. Since the trimmed primal realization generates C, the merged dual realization must still generate C ⊥ .\nNext, we consider linear tail-biting trellis realizations, which form the simplest class of realizations on a graph with a cycle. We will see that the effects of uncontrollability in this case are similar to those seen in classical state-space (conventional trellis) realizations, namely:\nTheorem 7. A reduced linear tail-biting trellis realization is uncontrollable if and only if its behavior consists of discon- nected subbehaviors.\nProof : The dual unobservable tail-biting trellis realization has a nonzero trajectory (0, s) ∈ B. Moreover, s i = 0 for all i, since otherwise some constraint code C i would not be proper. We again choose a basis for each state space S i with g i1 = s i , so the coordinates of each s i are 10 . . . 0. If we choose a dual basis for each state space ˆ S i in the dual uncontrollable realization, then the inner product of elements of S i and ˆ S i is\ngiven by the dot product of their coordinate vectors. Thus the set s ⊥ i ⊆ ˆ S i of dual states orthogonal to s i is the subspace ˆ T i of ˆ S i consisting of states whose ﬁrst coordinate is zero. The |F| cosets of ˆ T i in ˆ S i are the subsets of ˆ S i whose ﬁrst coordinates equal a certain value of F.\nEach constraint code C i thus contains an element (s i , a i , s i+1 ) with a i = 0 and s i and s i+1 having coordinates 10 . . . 0. It follows that if (ˆ s i , ˆ a i , −ˆ s i+1 ) is any element of the orthogonal code C ⊥ i (using the convention that the sign inversion is always applied to ˆ s i+1 ), then\n= s i , ˆ s i + a i , ˆ a i − s i+1 , ˆ s i+1 = ˆ s i1 − ˆ s i+1,1 .\nIt follows that in any dual trajectory (ˆ a, ˆ s), the ﬁrst coordinates of the dual state variables must be equal: ˆ s i1 = ˆ s i+1,1 . Thus the state spaces ˆ S i are partitioned by their ﬁrst coordinates into |F| cosets of ˆ T i , such that state transitions are possible only within cosets. The trajectories in the dual behavior B ◦ thus partition into disconnected cosets, each consisting of the trajectories that go through states with a particular value of the ﬁrst coordinate.\nExample 3. The tail-biting trellis realization of Fig. 3 realizes the binary linear (5, 3) block code C = 01110, 10010, 01101 . Since it has a nonzero trajectory (0, s), this realization is unobservable. Its ﬁve state spaces have been coordinatized so that the state values along the nonzero trajectory (0, s) are either 10 or 1.\nt 00 01 10 11\nt t t\nd 0 1\nd 0 1\nt t\ne e ¡\n0 0\nt t\n   \n0 1 0 1\nt t\n  ¡\n0 1\n1 0 f\nf f\n    e\ne 0\nt t\nt t\n0 0 0 0\n    d\nd  \n    d\n1 1 1 1\nt t\nt t\n00 01 10 11\nt t t t\nd 0 1\nd 0 1\nt t\n0 1\nt t\n   \n0 1 0 1\nt t\nt t\nd d  \nt t\nt t\n0 0 1\nt t\nt t\nThe dual realization of Fig. 4 realizes the orthogonal (5, 2) code C ⊥ = 10111, 01100 . This is a product realization with generators 10111, 01100 , where the span of the second generator is degenerate (i.e., all states are nonzero). It has two disjoint subbehaviors, as predicted by Theorem 7.\nThe fundamental structure theorem of Koetter and Vardy [7] states that every linear reduced tail-biting (or conventional) trellis realization is a product realization. In this light, it is easy to see that a tail-biting trellis is controllable if and only if none of the spans of its generators is degenerate.\nWe have seen that for trellis realizations, the effects of uncontrollability for conventional and tail-biting trellises are similar. However, for more general realizations, we do not necessarily have the same phenomenon of disconnected sub- behaviors. For example, in the uncontrollable parity-check realization of Fig. 2, every state variable is a replica of a symbol variable, and thus (from the properties of C) every pair of state variables that do not both correspond to the same symbol variable can take on all possible pairs of values.\nUnobservable realizations would appear to be clearly un- desirable for use with iterative decoding: because every code sequence has multiple representations, it seems that an iterative decoding algorithm would never converge to any one of them. However, we have seen that any unobservable realization may be locally reduced, so without loss of generality we can always assume an observable realization for any given code.\nOn the other hand, uncontrollable parity-check realizations can be and have been used successfully with iterative de- coding. Moreover, it is known that redundant parity checks tend to reduce the number of pseudocodewords with iterative decoding of LDPC codes, so in this respect uncontrollability may actually be helpful. Thus it would be useful to have a better understanding of the properties of uncontrollable realizations."},"refs":[{"authors":[{"name":"G. D. Forney"}],"title":{"text":"Codes on graphs: Normal realizations"}},{"authors":[{"name":"G. D. Forney"}],"title":{"text":"Minimal realizations of linear systems: The \u2018shortest basis\u2019 approach"}},{"authors":[{"name":"G. D. Forney"},{"name":"H. Gluesing-Luerssen"}],"title":{"text":"Codes on graphs: Observ- ability, controllability and local reducibility"}},{"authors":[{"name":"G. D. Forney"},{"name":"M. D. Trott"}],"title":{"text":"The dynamics of group codes: Dual abelian group codes and systems"}},{"authors":[{"name":"H. Gluesing-Luerssen"},{"name":"G. D. Forney"}],"title":{"text":"Local irreducibility of tail- biting trellises"}},{"authors":[{"name":"H. Gluesing-Luerssen"},{"name":"E. A. Weaver"}],"title":{"text":"Characteristic generators and dualization for tail-biting trellises"}},{"authors":[{"name":"R. Koetter"},{"name":"A. Vardy"}],"title":{"text":"The structure of tail-biting trellises: Minimality and basic principles"}},{"authors":[{"name":"A. Vardy"}],"title":{"text":"Trellis structure of codes"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569565241.pdf"},"links":[{"id":"1569565867","weight":11},{"id":"1569566697","weight":11},{"id":"1569564805","weight":11},{"id":"1569565355","weight":11},{"id":"1569558325","weight":11},{"id":"1569565837","weight":11},{"id":"1569560427","weight":22},{"id":"1569565317","weight":11},{"id":"1569566739","weight":11},{"id":"1569566999","weight":11},{"id":"1569564249","weight":11},{"id":"1569566795","weight":11},{"id":"1569561679","weight":11},{"id":"1569566895","weight":11},{"id":"1569566749","weight":11},{"id":"1569566985","weight":11},{"id":"1569565321","weight":11},{"id":"1569566369","weight":11},{"id":"1569565535","weight":11},{"id":"1569566423","weight":11},{"id":"1569565257","weight":66},{"id":"1569567015","weight":11},{"id":"1569559805","weight":11},{"id":"1569558901","weight":11},{"id":"1569559111","weight":11},{"id":"1569566445","weight":11},{"id":"1569566809","weight":22},{"id":"1569566447","weight":11},{"id":"1569565817","weight":11},{"id":"1569566003","weight":11},{"id":"1569565185","weight":11},{"id":"1569556671","weight":11},{"id":"1569565469","weight":11},{"id":"1569566297","weight":11},{"id":"1569566383","weight":11},{"id":"1569565493","weight":11},{"id":"1569559199","weight":11},{"id":"1569566293","weight":11},{"id":"1569565665","weight":11},{"id":"1569566779","weight":11},{"id":"1569565765","weight":11},{"id":"1569564595","weight":11},{"id":"1569565177","weight":11},{"id":"1569566529","weight":11},{"id":"1569565597","weight":11},{"id":"1569563975","weight":11},{"id":"1569566075","weight":11},{"id":"1569564923","weight":11},{"id":"1569564281","weight":11},{"id":"1569566601","weight":11},{"id":"1569557851","weight":11},{"id":"1569566147","weight":11},{"id":"1569567013","weight":11},{"id":"1569565853","weight":11},{"id":"1569566273","weight":11},{"id":"1569565731","weight":11},{"id":"1569566797","weight":22},{"id":"1569565143","weight":11},{"id":"1569566973","weight":11},{"id":"1569565031","weight":11},{"id":"1569565139","weight":11},{"id":"1569566113","weight":11},{"id":"1569566727","weight":11}],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S4.T5.1","endtime":"17:00","authors":"David Forney, Heide Gluesing-Luerssen","date":"1341247200000","papertitle":"Observability, Controllability and Local Reducibility of Linear Codes on Graphs","starttime":"16:40","session":"S4.T5: Codes on Graphs","room":"Kresge Little Theatre (035)","paperid":"1569565241"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
