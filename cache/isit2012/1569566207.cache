{"id":"1569566207","paper":{"title":{"text":"Multiplicative secret sharing schemes from Reed-Muller type codes"},"authors":[{"name":"Iwan Duursma"},{"name":"Jiashun Shen"}],"abstr":{"text":"Abstract\u2014Multiplicative linear secret sharing schemes are the building blocks for multiparty computation protocols. Such schemes can be deﬁned in terms of linear codes with an additional algebraic structure. We show that Reed-Muller codes have the required additional structure and we introduce a more general class of Reed-Muller type codes suitable for linear secret sharing and multiparty computation. The codes have highly structured generator and parity check matrices that can be used for very efﬁcient implementations over the binary ﬁeld."},"body":{"text":"In the Shamir secret sharing scheme [1], a polynomial f of degree at most t over a ﬁnite ﬁeld K is evaluated in n + 1 distinct ﬁeld elements x 0 , x 1 , . . . , x n . Through interpolation, the value of f in x 0 can be obtained from the values in any t + 1 of the points x 1 , . . . , x n . At the same time, no information can be obtained from the values in t or fewer points. Given a second polynomial g of degree at most t, the product f (x 0 )g(x 0 ) can be obtained through interpolation from 2t + 1 of the values f (x 1 )g(x 1 ), . . . , f (x n )g(x n ).\nThe notion of a general linear secret sharing scheme (LSSS) is deﬁned in [2]. Of special interest for multiparty computation (MPC) are linear secret sharing schemes with a multiplicative structure. Such schemes are called arithmetic secret sharing schemes in [3]. Recently this notion was generalized into the notion of an arithmetic codex [4]. An arithmetic codex can be described as a K-vector space C ⊂ S × K n such that the projection of C on S is surjective and the projection of C on K n is injective. Here S is a K-algebra of ﬁnite dimension as a vector space over K. If we endow K n with coordinate-wise addition and multiplication then S × K n becomes a K-algebra and we can deﬁne the set C (d) ⊂ S × K n as the set of all d−fold products c 1 · · · c d of elements in C. The codex C is called (d, r)−reconstructing if the projection π(C (d) ) ⊂ S × K r on any r coordinates is again a codex. For S = K, the Shamir secret sharing scheme can be considered as a (2, 2t + 1)−reconstructing codex.\nThe construction of good codices involves at least two difﬁculties. If a linear code C is chosen as the starting point\nfor the construction of a codex then the code needs to have some extra underlying structure in order for the codex to be nontrivial. The second difﬁculty arises when one insists on long codices deﬁned over a small ﬁeld. In that case the Shamir secret sharing scheme, for which the ﬁeld size increases with n, can no longer be used. In [5], a construction based on algebraic geometry codes is presented for linear secret sharing schemes deﬁned over a small ﬁeld with good asymptotic properties for multiparty computation.\nIn this paper we investigate the multiplicative properties of binary Reed-Muller type codes. This leads to a class of low complexity codes over the binary ﬁeld with a rich combinatoial structure and with good properties for short to moderate length.\nWe ﬁrst describe the codex structure of Reed-Muller codes. The binary Reed-Muller code RM (1, m) of length N = 2 m and dimension m + 1 is deﬁned with a generator matrix G with 2 m distinct columns (1, x 1 , . . . , x m ). Let (1, 0, . . . , 0) be the ﬁrst column and let n = N − 1 = 2 m − 1 be the number of remaining columns. For C = RM (1, m), C ⊂ K × K n and C (d) = RM (d, m). Using the well-known relation RM (d, m) ⊥ = RM (m − 1 − d, m), we see that the code C (m−1) ⊥ 1 and it follows that the codex C = RM (1, m) is (m − 1, n)-reconstructing. In particular the code RM (1, 4) is (3, n)-reconstructing. Using similar reasoning we see that RM (1, 7) is (6, n)-reconstructing, RM (2, 7) is (3, n)- reconstructing, and RM (3, 7) is (2, n)-reconstructing.\nNote that if a code C ⊂ K × K n is self- orthogonal then C (2) ⊥ 1 and thus it is (2, n)- reconstructing. Namely, for (f 0 g 0 , f 1 g 1 , . . . , f n g n ) ∈ C (2) with (f 0 , f 1 , . . . , f n ), (g 0 , g 1 , . . . , g n ) ∈ C, the coordinate f 0 g 0 is uniquely determined as the opposite of the sum f 1 g 1 + · · · + f n g n of the remaining coordinates. (2, n)-reconstructing linear secret sharing schemes are called multiplicative and are important for multiparty computation with a passive adversary. Multiparty computation with an active adversary makes use of strongly multiplicative linear secret sharing schemes. In that case it is required that a product f 0 g 0 can be expressed as a\nlinear combination of the subset of coordinates not controlled by the adversary. For the deﬁnition of strongly multiplicative we refer to [2]. For this paper we use that a sufﬁcient condition for C ⊂ K ×K n to be strongly multiplicative is that C (3) ⊥ 1. This last condition implies in particular that C is (3, n)- reconstructing.\nCodes C ⊂ K N with C (3) ⊥ 1 are called strongly self-orthogonal. Write K N = K × K n . For C ⊂ K × K n , the ﬁrst coordinate of a word corresponds to the secret and the remaining n coordinates are shares of the secret. The access structure of the LSSS C ⊂ K × K n is the collection Γ of all those coordinate subsets A ⊂ {1, . . . , n} that can reconstruct the secret. The adversary structure of the LSSS C ⊂ K × K n is the collection ∆ of all those coordinate subsets B ⊂ {1, . . . , n} that can not reconstruct the secret. Because of the linearity of C, reconstruction of the secret from the coordinates in B is not unique if and only if there exists a word in C that is zero on B for a nonzero secret.\nFor a strongly self-orthogonal code, the secret can be reconstructed by any qualiﬁed subset A ∈ Γ in the presence of an unknown active adversary B ∈ ∆. An active adversary can change the values on his coordinates. We explain the reconstruction procedure [2], [9]. On input n shares, possibly corrupted on the subset B ∈ ∆, the procedure yields as output the correct value s of the secret but in general without information about the adversary B or about which shares were corrupted.\nLet C be a code of length N = n + 1. Let C 0 ⊂ C be the subset of vectors in C with 0 in the secret position. Let C 1 ⊂ C be the coset with 1 in the secret position. For a possibly corrupted list of shares ˆ c 1 , . . . , ˆ c n , let c 1 ∈ C 1 be such that for all c 0 ∈ C 0 , ˆ c i c 1 i c 0 i = 0. Then s = − ˆ c i c 1 i c 1 i .\nFor the proof we ﬁrst show that such a c 1 ∈ C 1 exists. Since B ∈ ∆, there exists c ∗ ∈ C 1 that is zero on B. Since c 0 ∈ C 0 ,\nwhere the last equality uses C (3) ⊥ 1. Finally, for any c 1 ∈ C 1 with the given property,\nOver the vector ﬁeld F n 2 , besides the usual addition, we deﬁne another operator \u201c·\u201d called \u201ccoordinatewise multiplication\u201d. It is deﬁned as follows: for (a 1 , a 2 , ..., a n ), (b 1 , b 2 , ..., b n ) ∈ F n 2 ,(a 1 , a 2 , ..., a n ) · (b 1 , b 2 , ..., b n ) = (a 1 b 1 , a 2 b 2 , ..., a n b n ). Based on this deﬁnition, we will construct codes that can be used for multiplicative secret sharing. First of all, we deﬁne a code C (1) generated by matrix G\nA i is a k by k i matrix such that the columns of A i consist of all different vectors of weight i and length k. Notice that the weight of each row of A i is k i · i k = k−1 i−1 . Under the above construction, we have the result below:\nLemma 1. For a single matrix A i , let t 1, if we take t different rows from A i and multiply them together, we will always get a vector of weight k−t i−t .\nProof: For the weight of the product of rows, assume it is the multiplication of rows r 1 , r 2 , ..., r t . To count the weight, for a certain column j, we have to make sure that all r 1 , r 2 , ...r t have 1 in column j. Since we have listed all weight i columns in the matrix A i , we know that the total number of choices for such kind of columns is k−t i−t (this is beacuse for the rest k − t positions, we can freely chose i − t 1s.)\n    \n1 1 1 1 1 1 0 0 0 0 1 1 1 0 0 0 1 1 1 0 1 0 0 1 1 0 1 1 0 1 0 1 0 1 0 1 1 0 1 1 0 0 1 0 1 1 0 1 1 1\n    \nIf we multiply any 2 different rows in A 3 , we will always get a vector of weight 5−2 3−2 = 3.\nNext, we deﬁne the t-th generation of C, denoted by C (t) , as follows: C (t) =< S 1 , S 2 , .., S t >, where S i = {c 1 · c 2 ... · c i |where c 1 , c 2 ..., c i are different rows in G}. Thus, if j 1 +j 2 + ...+j m t, for e j s ∈ C (j s ) , 1 s m, then e j 1 ·e j 2 ...·e j m ∈ C (t) . For example, if t = 6, then for any e 1 , e 2 , e 3 ∈ C (2) , we have that e 1 · e 2 · e 3 ∈ C (6) .\nOur task is to choose k, i 1 , i 2 , ..., i m such that every vector in C (t) has even weight for some t.\nNext, we take any different t(t i) rows c 1 , c 2 , ..., c t from A i , and we get the following vector c 1 ·c 2 ...·c t . There are k t\nsuch vectors. Then we deﬁne A (t) i to be the matrix consisting of all these vectors. So A (t) i is a k t by k i matrix. Indeed we have the following lemma:\nLemma 3. For 1 t i, A (t) i is a k t × k i matrix, the weight of each column is i t and the weight of each row is\nProof: First, we need to show that each row is dif- ferent. To show this, we consider two different sets of rows. If r 1 ·r 2 ... · r t = r 1 · r 2 ...·r t , and by multiplying i − t rows s 1 , s 2 , ..., s i−t on both sides, we will get the same answer. However, since {r 1 , r 2 , ...r t , s 1 , s 2 , ..., s i−t } = {r 1 , r 2 , ..., r t , s 1 , s 2 , ..., s i−t }, we see that for any i rows production, we would get a weight 1 vector of length k i . In addtion, for any i rows, there is only one unique column such that all rows contain 1 at that column. So different i rows will give different products. So it is a contradiction. So the matrix A (t) i is a k t × k i matrix with different rows.\nNext, we need to show the weight of the column is i t . This is obvious, because we take all the possible products of t rows of the original matrix and so the weight of each column is i t . If two columns in A (t) i are the same, then we would see that the corresponding two columns in A i are the same, contradiction. So the columns of the matrix A (t) i are different. For the weight of the row, if the row is the product of rows r 1 , r 2 , ..., r t , to count the weight, for a certain column j, we have to make sure that all r 1 , r 2 , ...r t have 1 in column j and since we have put all weight i columns in the matrix. We know that the total choice for such kind of columns is k−t i−t (this is beacuse for the rest k − t positions, we can freely chose i − t 1s). Thus, we could check that the total number of 1s in the matrix A i is k t k−t i−t = k i i t , and this equation is indeed the subcommittee identity.\nLet D (t) i be the linear code generated by the rows in A (t) i . It is easy to see that D (1) i = C (1) i , which are the linear code generated by the rows of A i . In addition, C (t) i = D (1) i +D (2) i + ... + D (t) i and C (1) ⊆ C (2) ⊆ ... ⊆ C (k) .\nLet G (t) = (A i 1 A i 2 ...A i m ) (t) , where (A i 1 A i 2 ...A i m ) (t) is deﬁned in a similar way as A (t) i . Let D (t) be the linear code generated by the rows of G (t) . We consider a vector v = (v 1 , v 2 , ..., v k ) ∈ F k 2 , and let A s be in G if and only if v s = 1. Vector v gives us information whether some block A i is chosen or not. For example, if k = 10 and v = (1, 0, 1, 0, 0, 1, 1, 0, 1, 1), then G = [A 1 A 3 A 6 A 7 A 9 A 10 ] .\nFor ﬁxed k and t, we want to ﬁnd all the possible vectors v ∈ F k 2 such that the weight of each row of G (t) is even.\nProposition 4. The set of v ∈ F k 2 such that each row of G (t) has even weight is a subspace of F k 2 with dimension k − 1.\nProof: It is easy to show that the set is a vector space. We know from the above theorem that the weight of each row of A (t) i is k−t i−t , consider the binomial coefﬁ-\nare even, then we deﬁne the set of vectors E = {e k i+t−1 = (0, 0, ..0, 1, 0..0) ∈ F k 2 |t ∈ {s 1 , s 2 , ..., s j }, and 1 occurs at position i + t − 1 in e k i+t−1 }. So E has cardinality j. Suppose in position t 1 , t 2 , ..., t l, (t < t 1 \t t 2 \t ...\nare odd numbers, then we de- ﬁne the following set of vectors: F = {f k u+t−1,v+t−1 = (0, 0, .., 1, 0..0, 1, 0..0) ∈ F k 2 |u \t v are consecutive pairs of numbers in {t 1 , t 2 , ..., t l }, the two 1 s occur at position\nu + t − 1, v + t − 1} , and this set has cardinality l − 1. It is also obvious that j + l = k − t + 1. We also deﬁne a set of vectors G = {e k r ∈ F k 2 |1 r t − 1} .So it is obvious that E ∪ F ∪ G gives us a basis for our desired vector space. Since |E| = j, |F | = l − 1, |G| = t − 1 and E, F, G are mutually disjoint, we have that |E ∪ F ∪ G| = j + l − 1 + t − 1 = k − 1. So our proposition holds.\nRemark 5. The above theorem not only tells us that half of the vectors in F k 2 give even weight vectors, but also tells us how to ﬁnd a basis of such vector space. Thus, we have characterized all the possible cases of vectors in F k 2 such that for ﬁxed k, t, any row in G (t) has even weight.\nNext, for ﬁxed value k, we wish to ﬁnd some vectors in F k 2 such that those vectors would make the rows of G (t) to be even for several choices of t at the same time. For example, if k = 10, we may consider this problem: for what choice of vectors in F 10 2 , the rows of G (t) are all even for t = 1, 2, 3, 4? Indeed, we could use an extension method to work this out. Furthermore, we may believe that the cardinality of S ∈ {1, 2, 3, ..., k} may determine the number of choices of v ∈ F k 2 . Indeed, we have the following result:\nTheorem 6. If |S| = m, the vectors which makes any matrix in G S := G (t) |t ∈ S have all even weight rows form a vector space of dimension k−m, and so the number of choices for v ∈ F k 2 is 2 k−m .\nProof: The fact that vectors which make G S is a vector space can be proved easily. Consider a set S = {a 1 , a 2 , ..., a m } ⊆ {1, 2, 3, ..., k}, with a 1 > a 2 > a 3 > ... > a m . From what we did above, for G (a 1 ) to have all even weight rows, we know that for the last k − a 1 + 1 positions, we have that the dimension is k − a 1 . So the dimension of vector space which make G (a 1 ) to have all even weight rows is a 1 + k − a 1 + 1 = k − 1. Now consider the a 2 , a 2 +1, ..., a 1 −1 positions, if a vector makes G (a 1 ) , G (a 2 ) to have all even weight rows, when the last k − a 1 + 1 positions are ﬁxed, the positions a 2 , a 3 , ..., a 1 − 1 should rise to di- mension a 1 − a 2 − 1(because half of the vectors with length a 1 − a 2 − 1 give even weight and half odd weight). So for G (a 1 ) , G (a 2 ) to all have even weight rows, the dimension is k −a 1 +(a 1 −a 2 −1)+a 2 −1 = k −2. Similarly, we can repeat this argument, for ﬁxed a 2 , a 2 + 1, ..., a 1 , a 1 + 1..., k positions, consider the positions a 3 , a 3 + 1, ..., a 2 − 1, half of them make that G (a 1 ) , G (a 2 ) , G (a 3 ) all have even weight rows. So the dimension is k −a 1 +(a 1 −a 2 −1)+(a 2 −a 3 −1)−(a 3 −1) = k − 3. Therefore, we can repeat this argument to see that the dimension of the vector space is k − a 1 + (a 1 − a 2 − 1) + (a 2 − a 3 − 1) − ... − (a m−1 − a m − 1) + (a m − 1) = k − m. So the number of choices for v ∈ F k 2 is 2 k−m .\nIn our construction, we are more interested in [n] = {1, 2..., n} for n k. If each row in G (t) has even weight for every t n, then for every t n, every vector in D (t) has even weight and thus every vector in C (n) has even weight. As is shown in the above results, for ﬁxed n k, since [n] has cardinality n, the vector space U which makes C (n) have\nall even weight vectors has dimension k − n. Let us give a way to ﬁnd a basis for the vector space U.\nFirst, we need to construct a matrix M k , where the s − t entry of M k is m st = s−1 t−1 for s t, for s < t, m st = 0. Here, we denote 0 0 = 1.We want to have a matrix N k such that M k N k = I k , where I k is the k by k identity matrix. The ﬁrst column in matrix N k denotes the choice for which C (k−1) have all even weight codes but C (k) has some odd weight vector. Similarly, the j th column in matrix N k denotes the choice for which C (k−j) have all even weight codes but C (k−j+1) have some odd weights vectors.\nProof: We just consider M 2 k , when u < v, the u−v entry for M 2 k is 0 because M k is an upper triangular matrix. When u v, the u − v entry for M 2 k is\nu − 1 i − 1\ni − 1 v − 1\nu − v i − v\nWhen u > v, we see that m uv is even, which is 0 modulo 2. When u = v, we see that m uv = 1. So M 2 k = I kk.\nTheorem 8. Let U be the subspace of F k 2 which makes C (t) have all even weight codewords. Then for 1 i k − 1, the ﬁrst k − t columns of M k form a basis of the vector space U .\nSince the basis of U is clearly described by the above theorem, we will need to study the behavior of M k for certain k. The ﬁrst column of M k has period 1, the second and the third columns have period 2. By Lucas\u2019 Theorem, for n 1, from the 2 n−1 + 1 th column to 2 n th column, the period is 2 n . Then we have the following result:\nTheorem 9. For a ﬁxed k 2 l , for any vector v ∈ F 2 l 2 , deﬁne u ∈ F k 2 in the following way: u = (v, v, ..., v, v ), where v is a punctured of v with the last several digits deleted to make the length of u be k. Then u is a vector which makes the vectors in C (k−2 l ) be all even weight. Conversely, If for some choice u ∈ F k 2 , every vector in C (t) has even weight. Assume 2 l−1 k − t 2 l , then this vector u is of the following form: u = (v, v, ..., v, v ), where v ∈ F 2 l 2 and v is a punctured of v with the last several digits deleted to make the length of u be k.\nLet R(r, m) be the Reed Muller code deﬁned in a normal way. Let S r be the set which generates R(r, m). Thus, the all one vector 1 ∈ S r . Let R r be the subcode of R(r, m) which is generated by S r \\1. Therefore, no matter how we choose blocks A 1 , A 2 , ..., A k , we would always see that C (r) is a punctured code of R r . This is the reason why we call the code we constructed as Reed-Muller type code.\n    \n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1 0 0 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0\n    \nIf we delete the ﬁrst row of this matrix, we get G = [A 1 A 2 A 3 A 4 ] for which k = 4. If we just choose blocks A 1 and A 3 . Our code is a punctured code of the linear code generated by G.\nSince A i is the most elementary matrix in our construction. C (1) i is the linear code generated by the rows of A i . The dimension of C (1) i is k if i is odd and k − 1 if i is even.\nLemma 10. Let w u be the weight of a codeword obtained by adding u rows from A i . Then w u depends only on u and not on the u rows.\nProof: Let us add u rows of A (1) i and get a vector, say v = r 1 + r 2 + ... + r u = (v 1 , v 2 , ..., v( k\n)). If v m = 1, then {r 1m , r 2m , ..., r um } has odd number of 1s.\nIf {r 1m , r 2m , ..., r um } contains only one 1 and the rest are 0. There are u 1 k−1 i−1 possible choices. So by this combi- nation, u 1 k−1 i−1 1s will appear in the vector v. Similarly, if {r 1m , r 2m , ..., r um } contains three 1s and the rest are 0. There are u 3 k−1 i−3 such choices. Therefore, we could follow this argument so that the weight of any sum of u rows of A (1) i\nHowever, there are 4 boundary conditions: 0 2j − 1 u and 0 i − 2j + 1 k − u. So the range of j is max(1, u + 1 + i − k) 2j min(i + 1, u + 1).\nSince adding all rows in A (1) i will give either zero vector or all 1 vector, thus, we have the following result:\nTheorem 11. If C (1) is generated by one single block A i , the minimum distance of C (1) is min {w u |1 u k − 1}, where w u is the weight of the codeword added by u rows.\nSo the minimum distance is 4 here and the weight distribution of our linear code is very clear. In addition, assume we add one more block i = 2 here. For i = 2, if we sum one, two ,three, four and ﬁve rows, we would get the weights of the resultant vectors to be 4, 6, 6, 4, 0 resp. Therefore, if we combine A 2 and A 3 together, we would get the weights of the vectors to be 10, 12, 10, 8, 10 resp.\nFor a ﬁxed k, suppose we want C (t) to have all even weight codes. In matrix M k , the ﬁrst k − t columns give us a basis of the subspace U of F k 2 which makes C (t) have all even weight codes. Our task is to pick up a vector u ∈ U such that the length of the corresponding C (t) is as short as possible.\nBy using the above result, we could ﬁnd the minimum distance of any C (1) very quickly. For example, for k = 7, consider the sum of column 2 and column 3 in matrix M 7 , we get a generator matrix G = [A 1 A 2 A 5 A 6 ], and C (1) , C (2) , C (3) , C (4) have all even weight codewords. The length of the code is 7 1 + 7 2 + 7 5 + 7 6 = 56. To calculate the minimum distance of C (1) , we list the sum of n rows for 1 n k. Let the weight of the sum of n rows be w.\nHence, the minimum distance of C (1) is 24. By this method, we have constructed a [56, 7, 24] code C (1) which satisﬁes the property that C (1) , C (2) , C (3) , C (4) all have even weight.\nExample 12. For k = 10, and for i 1 = 3, i 2 = 7, the code C = C (1) has length 240. The generator matrix for C is the 10 × 240 matrix with 10 3 = 120 columns of weight 3 and 10 7 = 120 columns of weight 7. The code C (i) is of dimension 10, 45, 120, 195, 230, resp., for i = 1, 2, 3, 4, 5. The codes C (i) and C (5−i) are dual codes for i = 1, 2, 3, 4, 5.\nThe following table gives the shortest possible codes ob- tained with our construction for which C (t) is an even weight code.\nWe have given a construction of codes of Reed-Muller type suitable for use in multiplicative secret sharing schemes and multiparty computation."},"refs":[{"authors":[{"name":"A. Shamir"}],"title":{"text":"How to share a secret"}},{"authors":[{"name":"R. Cramer"},{"name":"V. Daza"},{"name":"I. Gracia"},{"name":"J. Jim´enez Urroz"},{"name":"G. Leander"},{"name":"J. Mart´ı- Farr´e"},{"name":"C. Padr´o"}],"title":{"text":"On codes, matroids, and secure multiparty compu- tation from linear secret-sharing schemes"}},{"authors":[{"name":"I. Cascudo"},{"name":"H. Chen"},{"name":"R. Cramer"},{"name":"C. Xing"}],"title":{"text":"Asymptotically good ideal linear secret sharing with strong multiplication over any ﬁxed ﬁnite ﬁeld"}},{"authors":[{"name":"R. Cramer"}],"title":{"text":"The arithmetic codex: Theory and applications"}},{"authors":[{"name":"H. Chen"},{"name":"R. Cramer"}],"title":{"text":"Algebraic geometric secret sharing schemes and secure multi-party computations over small ﬁelds"}},{"authors":[{"name":"I. M. Duursma"},{"name":"R. Pellikaan"}],"title":{"text":"A symmetric Roos bound for linear codes"}},{"authors":[{"name":"E. Arıkan"}],"title":{"text":"Channel polarization: a method for constructing capacity- achieving codes for symmetric binary-input memoryless channels"}},{"authors":[{"name":"S. B. Korada"},{"name":"E. S¸as¸o˘glu"},{"name":"R. Urbanke"}],"title":{"text":"Polar codes: characterization of exponent, bounds, and constructions"}},{"authors":[{"name":"I. M. Duursma"}],"title":{"text":"Algebraic geometry codes: general theory"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569566207.pdf"},"links":[],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S2.T5.3","endtime":"12:30","authors":"Iwan Duursma, Jiashun Shen","date":"1341231000000","papertitle":"Multiplicative secret sharing schemes from Reed-Muller type codes","starttime":"12:10","session":"S2.T5: Reed-Muller Codes","room":"Kresge Little Theatre (035)","paperid":"1569566207"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
