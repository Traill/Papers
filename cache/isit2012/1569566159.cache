{"id":"1569566159","paper":{"title":{"text":"Partial Permutation Decoding for Abelian Codes"},"authors":[{"name":"Jos´e Joaqu´ın Bernal-Buitrago"},{"name":"Juan Jacobo Sim´on"}],"abstr":{"text":"Abstract\u2014We show some sufﬁcient conditions for a semisimple abelian code to be permutation decodable. We ﬁnd non trivial partial PD-sets with respect to the information set introduced red by the authors in a previous paper. By using these results we present examples of permutation decodable abelian codes improving the bounds about the dimension given by S. G. S. Shiva, K. C. Fung and H. S. Y. Tan."},"body":{"text":"Permutation decoding was introduced by F. J. MacWilliams in [10] and it is described in [4]. Fixing an information set for a given linear code, this technique uses a special set of permutation automorphisms of the code called PD-set.\nThe idea of permutation decoding is to apply the elements of the PD-set to the received vector until the errors are moved out of the ﬁxed information set. Finding adecuate PD-sets and information sets is not trivial. Moreover, the existence of PD- sets relies on the information set previously ﬁxed as reference. In fact, it may happens that for an error correcting code the election of the information set causes the existence or not of a PD-set. Many authors ([5], [7] and [6], among others) have studied families of codes for which it is possible to develop methods to ﬁnd PD-sets for certain types of information sets. It has been seen that all methods rely heavily on those families chosen. Our interest is the family of abelian codes. Some relevant families of codes are abelian, for instance: cyclic codes, Reed-Muller codes, extended Reed-Solomon codes and others.\nIn [3] we presented a method for constructing information sets valid for every semisimple abelian code. It is based on the structure of the deﬁning set of the code. This technique has the advantage that it allows us to design codes with suitable information sets to make permutation decoding.\nIn this note we ﬁnd sufﬁcient conditions for an abelian code, viewed as elements of a multivariate polynomial quotient ring, to have a PD-set contained in the translations associated to each variable, with respect to the ﬁxed information sets described in [3]. Moreover, the goal of this note is that such conditions may be written solely in terms of the q-orbit structure of the deﬁning set of abelian codes (see below for all deﬁnitions).\nAll throughout F denotes the ﬁeld with q elements where q is a power of a prime p. Let C be a linear code of dimension k,\nand length l over the ﬁeld F. An information set for C is a set of positions {i 1 , . . . , i k } ⊆ {1, . . . , l} such that restricting the codewords to these positions we get the whole space F k . For every codeword the symbols in the positions corresponding to an information set are called information symbols and the other l−k positions are called check positions [8]. A generator matrix for C is a k ×l matrix G whose rows form a basis for C. We say that G is in standard form if it is of the form [I k | A], where I k is the identity matrix of order k. We denote by C ⊥ the dual code of C under the ordinary inner product, that is, C ⊥ = {v ∈ F l | u·v = 0 for all u ∈ C}. A parity check matrix for C is a generator matrix for C ⊥ . If G is a generator matrix in standard form, it is easy to check that H = [−A T | I l−k ] is a parity check matrix. In this case we say that H is also in standard form.\nAs usual, for any codeword c ∈ C we denote its support by supp(c) and its Hamming weight by wt(c). We consider the parameter t = d−1 2 , where d is the minimum distance of C, that measures the error-correction capability of C. Then we say that C is an [l, k] t-error-correcting code.\nWe see the group of permutations on l symbols, S l , acting on F l via σ(c 1 , . . . , c l ) = c σ −1 (1) , . . . , c σ −1 (l) with σ ∈ S l . Then the permutation automorphism group of C is\nNow, we recall some basic facts about the family of abelian codes and their permutation automorphisms (the reader may see [1] for details).\nAn abelian code is an ideal of a group algebra FG, where G is an abelian group. It is well-known that a decomposition G C r 1 × · · · × C r n , with C r i the cyclic group of order r i , induces a canonical isomorphism of F-algebras from FG to\nFixing α = {α 1 , . . . , α n } where α i is a primitive r i -th root of unity in some extension of F, for each i = 1, . . . , n, every abelian code C of A(r 1 , . . . , r n ) is totally determined by its deﬁning set,\nGiven an element a = (a 1 , . . . , a n ) ∈ Z r 1 × · · · × Z r n , we deﬁne its q-orbit modulo (r 1 , . . . , r n ) as\nIt is easy to see that, in the semisimple case, for every abelian code C in A(r 1 , . . . , r n ), D α (C) is a disjoint union of q-orbits modulo (r 1 , . . . , r n ). Conversely, every union of q-orbits modulo (r 1 , . . . , r n ) deﬁnes an abelian code in A(r 1 , . . . , r n ).\nFixing an information set for a given linear code C, the algo- rithm of permutation decoding uses certain sets of permutation automorphisms of the code called PD-sets.\nDeﬁnition 1. Let C be an [l, k] t-error-correcting code. Let I be an information set for C. For s ≤ t a s-PD-set for C and I is a subset P ⊆ PAut(C) such that every set of s coordinate positions is moved out of I by at least one element of P . In case s = t, we say that P is a PD-set.\nGiven a t-error-correcting code with a PD-set with respect to certain information set, the idea of permutation decoding is to apply the elements of the PD-set to the received vector until the errors are moved out of the ﬁxed information set.\nIn general to ﬁnd t-PD-sets for a given t-error correcting code is not at all an easy problem. Moreover, the algorithm will be more efﬁcient if the size of the PD-set is small.\nWe denote the permutation group on Z r 1 × · · · × Z r n by S r 1 ×···×r n and we consider it acting on A(r 1 , . . . , r n ) via τ \t j a j X j = j a j X τ (j) . Under this point of view the permutation automorphism group of an abelian code C in A(r 1 , . . . , r n ) may be described as\nLet T j be the transformation from A(r 1 , . . . , r n ) into itself, given by T j (P ) = X j · P , for j = 1, . . . , n. Then it is clear that T j induces a permutation in S r 1 ×···×r n , which we also denote by T j , via T j (i 1 , . . . , i n ) = (i 1 , . . . , i j + 1, . . . , i n ). Then {T j } n j=1 may be viewed as a subgroup of permutation automorphisms for every abelian code in A(r 1 , . . . , r n ). We shall look for PD-sets contained in the subgroup {T j } n j=1 .\nIn this section we consider some sets of check positions that may be constructed for a given abelian code. All throughout, we denote by C a semisimple abelian code in A(r 1 , . . . , r n ).\nIn [3, Section III] it is constructed a set of check posi- tions, called Γ(C). The construction is based on the recursive\ncomputation of n-families of sequences of natural numbers obtained from a special set of representatives of the q-orbits of the deﬁning set of C, denoted by D(C) [3, p. 7991].\nIn the general case, the algorithm is too large and compli- cated to be included here. Then, we shall see the case n = 2, which allows us to understand how we can obtain some of the codes exhibited in Section V.\nSo, let C be an abelian code in A(r 1 , r 2 ), with deﬁning set D(C) = D α (C). For each e = (e 1 , e 2 ) ∈ D(C), we deﬁne\nwhere C (q γ ,r) (a) denotes the q γ -cyclotomic coset, modulo r, for any a ∈ Z r .\nFollowing the algorithm in [3, p. 7993] we choose D(C), a restricted set of representatives of the q-orbits of D(C). We recall that D 1 (C) is the projection of D(C) onto de ﬁrst coordinate.\nR(e) = {a ∈ Z r 2 | (e, a) ∈ D(C)}, M (e) =\n. Then we denote the different values of the M (e)\u2019s as follows,\nIf there are s 2 distinct nonzero values for the f [−] we obtain r 2 ≥ f [1] > · · · > f [s 2 ] > 0 = f [s 2 + 1] ,\nFinally, we deﬁne the last sequence as follows: for every 1 ≤ u 2 ≤ s 2 we set\nΓ(C) = {(i 1 , i 2 ) ∈ Z r 1 × Z r 2 | ∃u ∈ {1, . . . , s} with\nIt is proved in [3, Theorem 9] that Γ(C) is a set of check positions for C.\nExample 2. Let q = 2, n = 2, r 1 = 3, r 2 = 17, and consider the abelian code F with the following deﬁning set with respect to certain roots of unity:\nWe choose D 1 (F ) = {0, 1}, and D(F ) = {(0, 1), (1, 0), (1, 1), (1, 2), (1, 3)}. Now we compute\nSo, a set of check positions for F is Γ(F ) = {(0, 0), . . . , (0, 12), (1, 0), . . . , (1, 12), (2, 0), . . . , (2, 7)}\nRemark 3. In the general case [3, pp. 7991-7992], for j ∈ {2, . . . , n}, sequences of lists of numbers (u n , . . . , u j ) are constructed; as well as numbers s (u n , . . . , u j ) (except the ﬁrst one, s n ). They verify 1 ≤ u k ≤ s(u n , . . . , u k+1 ), where 1 ≤ k ≤ j. For each list, there is a value f [u n , . . . , u j ] , and for any list (u n , . . . , u 2 ) there is also a parameter g [u n , . . . , u 2 ] . Then\n1 ≤ u n ≤ s n , and 1 ≤ u l ≤ s(u n , . . . , u l+1 ), for l = 2, . . . , n − 1, such that\nNow we deal with other codes associated to a given code C. All of them will be useful for our purposes. Let C be an abelian code in A(r 1 , . . . , r n ) with deﬁning set D(C) with respect to certain choice of roots of unity. We know that the complementary set Γ(C) c ⊆ n i=1 Z r i and Γ C ⊥ are information sets for C. The following theorem (see [2, p. 130]) gives us the relationship between Γ(C) and Γ(C ⊥ ).\nTheorem 4. Let C be an abelian code in A(r 1 , . . . , r n ). Let κ : n i=1 Z r i → n i=1 Z r i be the bijection given by κ(i 1 , . . . , i n ) = (r 1 − i 1 − 1, . . . , r n − i n − 1). Then\nNow we denote by C the abelian code with deﬁning set D(C ) = (Z r 1 × · · · × Z r n ) \\ D(C) with respect to the same choice of roots of unity. It is easy to see that Γ(C ⊥ ) = Γ(C ).\nIn our results on permutation decoding we will use Γ(C ) as information set for C. The advantage of using the code C\ninstead of C ⊥ relies on the fact that we can transform the deﬁning set of C into the deﬁning set of C directly and this allows us to easily relate the respective sets of check positions. In addition, we think that by using Γ(C ) examples may be constructed in an easier way, as the reader may check in Section V.\nNote that the bijection κ may be extended to a bijec- tion from A(r 1 , . . . , r n ) into itself via κ(P (X 1 , . . . , X n )) =\na κ −1 (j) X j . We also denote by κ this extension. It is clear that κ is exactly the composition T r 1 −1 1 \t ◦ · · · ◦ T r n −1 n \t (see Section II for notation) and so it belongs to the permutation automorphism group of every abelian code. Then, Theorem 4 implies that Γ(C) c and Γ(C ) may be identiﬁed in order to apply the algorithm of permutation decoding in the sense that P ⊆ T i | i = 1, . . . , n is a partial PD-set for C and the information set Γ(C) c if and only if κ ◦ P ◦ κ −1 is a partial PD-set for C and the information set Γ(C ) = Γ(C ⊥ ).\nIn this section we apply the permutation decoding algorithm to abelian codes by using the information sets given in the previous section. Moreover, these information sets only depend on their deﬁning sets, so we may design deﬁning sets in order to get codes having information sets with good properties related to permutation decoding algorithm (see Section V). We shall show sufﬁcient conditions to ﬁnd (partial) PD-sets contained in the subgroup of the permutation automorphism of a code in A(r 1 , . . . , r n ) generated by the translations T j (i 1 , . . . , i n ) = (i 1 , . . . , i j + 1, . . . , i n ), for j = 1, . . . , n, which were introduced in Section II. As we have said, for a given code C in A(r 1 , . . . , r n ) we take as reference the information set Γ (C ).\nLet C in A(r 1 , . . . , r n ) be a t-error-correcting abelian code with deﬁning set D(C) and information set Γ(C ). Let b ≤ t a natural number and let e ∈ A(r 1 , . . . , r n ) an error vector with supp(e) = {p 1 , . . . , p b } ⊆ Z r 1 × · · · × Z r n . We set p j = (p 1 j , . . . , p n j ) for j = 1, . . . , b. We want to use the sub- group {T j } n j=1 to move supp(e) outside Γ(C ). Following the notation in Remark 3, we denote by f [·] , g [·] , s and s (·) the parameters used in the construction of Γ(C ). If p j ∈ Γ(C ), for some 1 ≤ j ≤ b, then there exist (u n , . . . , u 2 ) ∈ Υ n (C )\ni = 2, . . . , n, and g [u n , . . . , u 2 ] > p 1 j ≥ 0. Therefore in order to move p j outside Γ(C ) we look for a suitable T ∈ {T j } n j=1\nsuch that T (p j ) / ∈ Γ(C ), that is, such that for T (p j ) there no exist (u n , . . . , u 2 ) satisfying the required conditions. For instance, if there exist i ∈ {1, . . . , n} and α ∈ N such that f [u n , . . . , u i ] ≤ p i j + α mod r i then T α i (p j ) / ∈ Γ(C ).\nFirst, we need some deﬁnitions and some additional no- tation. Let v = (v n , . . . , v j ) ∈ Υ n−j+2 (C ), with j ∈ {2, . . . , n}. Then we deﬁne\nFinally we deﬁne S −1 (v) = (v n , . . . , v j+1 ), in case j < n, and S −1 (v n ) = ∅.\nΛ(v) = Λ(v) \t if g [S n−2 (v)] = r 1 , Λ(v) ∪ {1} otherwise.\nNow, we present our ﬁrst sufﬁcient condition to have a (partial) PD-set contained in the group T i | i = 1, . . . , n .\nTheorem 6. Let C be a t-error-correcting abelian code in A(r 1 , . . . , r n ). Let b a positive integer such that b ≤ t. If there exists a subset I ⊆ Λ(s ) verifying\nthen the group T i | i ∈ I is a b-PD-set for C with respect to the information set Γ(C ).\nThe previous theorem is based on the existence of certain subsets of Λ(s ). The following result talks about subsets of Λ(u), for some u ∈ {1, . . . , s }. So, in that sense it improves Theorem 6 (see (1)). Although, the following theorem needs that the group generated by T n is contained inside the obtained PD-set. This means that in some cases we can obtain PD-sets bigger (and so, worse) than that given by the Theorem 6.\nTheorem 7. Let C be a t-error-correcting abelian code in A(r 1 , . . . , r n ). Let b be a positive integer such that b ≤ t. We deﬁne\n \n1 if \t r n /b ≤ f [1] < r n , b if f [1] < r n /b .\nLet u = min x ∈ {2, . . . , s + 1} | f [x] < r n b . If there exists a subset I ⊆ Λ(u − 1) \\ {n} such that\nthen the group generated by T n and {T i } i∈I is a b-PD-set for C with respect to the information set Γ(C ).\nThe next result gives us a sufﬁcient condition under the assumptions n ≥ 3 and f [1] = r n . This new condition can hold even when Theorem 7 does not do.\nTheorem 8. Let C be a t-error-correcting abelian code in A(r 1 , . . . , r n ). Let b a positive integer such that b ≤ t. Suppose that n ≥ 3, f [1] = r n and assume that there exists v = (v n , . . . , v τ +1 , 1) ∈ Υ n−τ +2 (C ) (with 1 < τ < n) such that f [v n , . . . , v τ +1 , 1] < r τ . Then, we deﬁne\n\u2022 u = min {{1 ≤ x ≤ s | f [v n ] − f [x] > r n − r n /b } ∪{s + 1}} otherwise.\nIf there exists a subset I of Λ(u − 1) \\ {τ, . . . , n} verifying that\nthen the group generated by {T τ , . . . , T n } and {T i } i∈I is a b-PD-set for C with respect to Γ(C ).\nTo ﬁnish this section, we are going to study the case of correcting errors with weight less or equal than 3. In this situation, we will present a result for the existence of (partial) PD-sets which improves the condition given by Theorem 7.\nTheorem 9. Let C be a t-error-correcting abelian code in A(r 1 , . . . , r n ), with t ≥ 3. Let χ 1 = r n 3 − 1 and χ 2 = r n − − r n 3 , where = 1 if r n 3 ∈ N and = 0 otherwise. We deﬁne\n   \n  \nLet u i = min{x ∈ {2, . . . , s + 1} | f [x] ≤ χ i }, for i = 1, 2. If λ 0 = 3 or there exist subsets I ⊆ Λ(u 2 − 1) \\ {n} and ∅ = J ⊆ I ∩ Λ(u 1 − 1) such that\nthen the group generated by T n and {T i } i∈I is a 3-PD-set for C with respect to the information set Γ(C ).\nIn this section, we shall show some applications of the results exposed in the previous section, used as criteria to design abelian codes having determined properties in order to apply the permutation decoding algorithm. Moreover, we may determine upper bounds on the dimension of codes of certain lengths satisfying such properties.\nWe present two examples of codes that we have chosen having in mind the tables in [11] and [12], together with the updates in [3]. In the ﬁrst two papers, the authors obtained up- per bounds on the dimension of 2 and 3 error correcting cyclic codes on certain lengths which are permutation decodable with respect to the usual information set (consecutive positions).\nWe begin by updating 2-error correcting cyclic codes of length 51. In [11, p. 642] Shiva et al., assert that, for dimension k > 33 permutation decoding is not possible with respect to the usual information set.\nExample 10. We shall study the construction of binary codes C of length 51, with PD-set T 1 , T 2 , with respect to the in- formation set Γ(C ), as sums of minimal codes. The following table describe all minimal abelian codes in A(3, 17) and their corresponding (in C ) 2-orbits. We denote by M (−), f [−] , s\nFirst we look for codes satisfying the condition given in Theorem 6. So it must exist a subset I ⊆ Λ(s ) ⊆ {1, 2} such that i∈I λ i (s ) ≥ 2. One choice is |I| = 1. In this case, it must happen that f [1] < 9 or g [s ] < 2. By [3, Section III] one may check that any sum of minimal codes having f [1] < 9 has dimension at most 24 (for example, C = C 2 + C 5 + C 6 ), while any sum of minimal codes giving g [1] < 2 must have dimension at most 17 (the only one is C 1 + C 2 + C 3 ). The other choice is |I| = 2. Then we must have that f [1] < 17 and g [s ] < 3. Again [3, Section III] shows us that any sum of minimal codes satisfying the values above has dimension at most 32. This values and dimension is reached only by C = C 5 +C 6 +C 7 +C 8 ; however its minimum distance is 4, so it is not a 2-error correcting. There are 2-error correcting codes satisfying the values above, as C = C 4 + C 5 + C 6 + C 7 , which has dimension 26.\nNow we are looking for codes satisfying the conditions in Theorem 7. To do this, we separate in two cases, depending on the values of λ 0 . If λ 0 = 2 one has that f [1] < 9, which refers us to the prior paragraph. The case λ 0 = 0 drives us to g [u − 1] = g [1] < 2, which, again, refers us to the prior paragraph. Now, the case λ 0 = 1 gives us 9 ≤ f [1] < 17 and it must happen that g [u − 1] < 3 (this is because Λ(u−1)\\{2} ⊆ {1}). Once again, [3, Section III] gives us two posibilities. the ﬁrst one is u = 3. then s = 2 and g [2] = 3, which is a non desired value. So, to get g [u − 1] < 3 we must take u = 2. If s = 1 we get the f [1] < 17 and g [s ] < 3, the values in paragraph above. So we need that s = 2. This yields the sequences\nBy the table above, one may see that any sum of minimal codes satisfying (3) has dimension at most 40. We computed the minimum distance of each of these codes obtaining all of them less or equal to 4. The greatest dimension of codes satis- fying (3) with minimum distance greater than 4 is dimension 34; for example C = C 2 + C 4 + C 5 + C 6 + C 7 . One may see that C = F , the code in Example 2\nExample 11. Now we present a sketch of the study of codes with length 63. The ﬁrst thing is to determine the ambient algebra. It can be A(63) for cyclic codes, A(9, 7) for TDC codes (see [9]) or A(3, 3, 7). We consider this last case to illustrate that it is possible to obtain very good codes in the multidimensional case (n ≥ 3). The minimal codes associated with the 2-orbits are in the following table.\nThe application of Theorem 6 and 7 is completely analogous to Example 3 above, giving bounds of dimension 24 and 31, respectively. In this case, we may also apply Theorem 8, obtaining a bound of dimension 15, which is not so interesting.\nBy applying Proposition 9 we obtain codes of dimension 35; however all these codes are not 3-error correcting. The greatest dimension for a 3-error correcting code is 33; for example, C = C 1 + C 4 + C 10 + C 11 + C 12 + C 13 + C 14 which has minimum distance 8. The bound given in [12, Table IX] for the dimension of 3-error correcting cyclic codes of length 63, with a PD set contained in {T i } n i=1 with respect to the usual information set is 21.\nPermutation decoding depends heavily on the information set taken as reference. By using the properties of the informa- tion set given in [3] we have showed sufﬁcient conditions for a semisimple abelian code to have a partial PD-set contained in the group geneated by {T i } n i=1 These conditions are stated only in terms of the deﬁning set of the code. This allows us to design codes satisfying them. Concretely, we have exhibit two codes, of length 51 and 63 respectively, improving the bounds on the dimension given in [11], [12]."},"refs":[{"authors":[{"name":"S. D. Berma"}],"title":{"text":"Semisimple cyclic and Abelian codes, Cybernetics, vol"}},{"authors":[{"name":"J. J. Berna"}],"title":{"text":"C´odigos de grupo"}},{"authors":[{"name":"J. Berna"},{"name":"J. Sim´o"}],"title":{"text":"J"}},{"authors":[{"name":"W. C. Huffma"},{"name":"V. S. Ples"},{"name":"W. C. Huffma"},{"name":"R. A. Brualdi (editors"},{"name":"I. North-Hollan"}],"title":{"text":"Codes and groups, in    Handbook of Coding Theory vol"}},{"authors":[{"name":"P. McDonoug"}],"title":{"text":"J"}},{"authors":[{"name":"J. D. Ke"},{"name":"T. P. McDonoug"},{"name":"V. C. Mavro"}],"title":{"text":"Reed Muller codes and permutation decoding, Discrete Mathematics, vol"}},{"authors":[{"name":"H. J. Krol"},{"name":"R. Vincent"}],"title":{"text":"PD-sets for the codes realted to some classical varieties, Discrete Mathematics, vol"}},{"authors":[{"name":"V. S. Ples"},{"name":"W. C. Huffma"},{"name":"R. A. Brualdi (editors"}],"title":{"text":"Handbook of Coding Theory , vol"}},{"authors":[{"name":"H. Ima"}],"title":{"text":"A theory of two-dimesional cyclic codes, Information and Control, no"}},{"authors":[{"name":"F. J. MacWilliams Permutation decoding of systematic code"}],"title":{"text":"Bell System Tech"}},{"authors":[{"name":"S. G. S. Shiv"},{"name":"K. C. Fun"},{"name":"H. S. Y. Ta"}],"title":{"text":"On permutation decoding of binary cyclic double-error-correcting codes of certain lengths (Corresp"}},{"authors":[{"name":"S. G. S. Shiv"},{"name":"K. C. Fun"}],"title":{"text":"Permutation decoding on certain triple- error-correcting binary codes, IEEE Trans"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569566159.pdf"},"links":[{"id":"1569564805","weight":4},{"id":"1569566217","weight":4},{"id":"1569565257","weight":9},{"id":"1569554689","weight":4},{"id":"1569558401","weight":4},{"id":"1569566631","weight":4},{"id":"1569556361","weight":4},{"id":"1569565263","weight":4},{"id":"1569565715","weight":9}],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S2.T5.4","endtime":"12:50","authors":"José Bernal-Buitrago, Juan Simón","date":"1341232200000","papertitle":"Partial Permutation Decoding for Abelian Codes","starttime":"12:30","session":"S2.T5: Reed-Muller Codes","room":"Kresge Little Theatre (035)","paperid":"1569566159"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
