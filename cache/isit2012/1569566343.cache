{"id":"1569566343","paper":{"title":{"text":"A Coloring Approach to Constructing Deletion Correcting Codes from Constant Weight Subgraphs"},"authors":[{"name":"Daniel Cullina"},{"name":"Ankur A. Kulkarni"},{"name":"Negar Kiyavash"}],"abstr":{"text":"Abstract\u2014We take a graph theoretic view of deletion correcting codes. The problem of ﬁnding an n-bit s-deletion correcting code is equivalent to ﬁnding an independent set in a particular graph. We discuss the relationship between codes and colorings and demonstrate that the VT codes are optimal in a coloring sense. We describe a method of partitioning the set of bit strings by Hamming weight and ﬁnding codes within each partition. In the single deletion case, we ﬁnd an optimal coloring of the constant Hamming weight induced subgraphs. We show that the resulting code is asymptotically optimal. We also prove a lower bound on size of codes constructed using these partitions for any number of deletions."},"body":{"text":"Deletion channels output only a subsequence of their input while preserving the order of the transmitted symbols. They have applications in synchronization problems, communication of information over packet networks and biology. This paper concerns deletion channels for strings of bits, with ﬁxed input bit string length and a ﬁxed number of deletions. Despite signiﬁcant effort on this case, there still are many fundamental open problems, pertaining speciﬁcally to the design of codes and the size of the largest codebook.\nLevenshtein approached the design of codes from a com- binatorial and number theoretic perspective [4]. He showed that the Varshamov Tenengolts (VT) codes, which had been designed for a different channel [8], functioned as codes for the single deletion channel. In fact, the VT codes are conjectured to optimal for the single deletion channel [7]. Levenshtein also derived an upper bound and a nonconstructive lower bound on the sizes of codes for any number of deletions. Much less is known for channels with larger number of deletions. Helberg generalized the VT construction for any number of deletions, but the sizes of resulting codes grow very slowly, far below Levenshtein\u2019s bound [2].\nAnother direction for the construction of codes is compu- tational. It is well known that the problem of ﬁnding deletion correcting codes is equivalent to ﬁnding an independent set in a particular graph. But since, for general graphs, ﬁnding the maximum independent set is NP-hard, exact algorithms rapidly become intractable with increasing input string length (n). For the case of the single deletion, the computational approach has established that VT codes are optimal for n ≤ 11 (graph with 2 11 vertices) [6]. For multiple deletions, the best known codes have all been found through search algorithms. Butenko et al. found two-deletion correcting codes of maximum size for\nn ≤ 11 [1]. Khajouei et al. used a heuristic algorithm to ﬁnd the largest known two deletion correcting codes for n ≤ 25 [3].\nThis paper takes a graph theoretic perspective on this problem and contributes to both the combinatorial and compu- tational approaches. Our ﬁrst contribution is on the theoretical understanding VT codes: we show that VT codes optimally solve the coloring problem in the single deletion graph (while they have been conjectured to solve the independent set problem ). Second, we present a new method of construct- ing codes by solving several problems on smaller graphs, a computationally less intensive task. The method decomposes the graph of 2 n possible bit strings into subgraphs based on their Hamming weight, ﬁnds codes in selected subgraphs, and takes the union of these codes. In the single deletion case, this construction is asymptotically optimal; we show this by constructing an optimal coloring of the subgraphs. For larger number of deletions, we prove a lower bound on the size of codes constructed using these subgraphs.\nThe paper is organized as follows. In Section II, we give some notation and deﬁnitions related to the deletion channel and review the graph theoretic terminology and results. We also discuss the VT codes in graph theoretic terms. In Sec- tion III, we present our construction of codes for single and multiple deletions. Section IV contains some computational results on the sizes of some two deletion codes found by computer search using our partitioning strategy. In Section V, we discuss future work.\nLet [n] be the set of nonnegative integers less that n, {0, 1..n − 1}. Let [2] n be the set of bit strings of length n. Let H(x) be the Hamming weight of a string x. By [n] k\nwe denote the set of bit strings of length n with k ones. We will need the following asymptotic notation: let a(n) b(n) denote that lim n→∞ a(n) b(n) ≤ 1.\nWe will formalize the problem of correcting deletions by deﬁning the deletion channel. The deletion channel takes a bit string of length n and outputs a substring of length n − s. For bit strings x and y, write x < y if x is a substring of y and deﬁne the following sets.\nDeﬁnition 1. For x ∈ [2] n , deﬁne D s (x) = {z ∈ [2] n−s : z < x}, the set of substrings of x that can be produced by s deletions. Deﬁne I s (x) = {w ∈ [2] n+s : w > x}, the set of superstrings of x that can be produced by s insertions.\nIf x is the input to an n bit s deletion channel, D s (x) is the set of possible outputs. If x is the output from the channel, I s (x) is the set of possible inputs.\nWe are interested in zero error codes for the deletion channel. Consequently, a code is a set C of bit strings of length n such that for any two distinct bit strings x and y in C, the intersection D s (x) ∩ D s (y) is empty. We can restate this in another way by deﬁning a distance measure between bit strings.\nDeﬁnition 2. Let x, y ∈ [2] n . Let l be the largest integer for which there exists some z ∈ [2] l such that z < x and z < y. Deﬁne the deletion distance between x and y to be d L (x, y) = n − l.\nAn s-deletion correcting code is a set where the deletion distance between any two codewords is at least s + 1. Two codewords cannot both appear in a code if their deletion distance is s or less. We can capture this condition by deﬁning the following graph.\nDeﬁnition 3. For every distance s and length n, both positive integers, let L s,n be a graph with [2] n as its vertices. Vertices x and y are adjacent if and only if d L (x, y) ≤ s.\nA code that can correct s deletions is a set of vertices in L s,n that have no edges between them.\nNow we will brieﬂy deﬁne some graph notation and review a few concepts that will be useful later. All of these are sourced from West [9]. Given a graph G, let V (G) denote its vertex set and let E(G) denote its edge set. Given S ⊆ V (G), the subgraph induced by S contains the vertices in S and the edges in E(G) that have both endpoints in S.\nAn independent set in a graph is a set of vertices that are all nonadjacent. The size of a largest independent set in a graph G is denoted by α(G). The degree of a vertex is the number of adjacent vertices. The maximum degree of any vertex in G is denoted by ∆(G). It is easy to argue that α(G) ≥ |V (G)|/(∆(G) + 1).\nA coloring of a graph assigns a color (a number) to each vertex. The coloring is proper if it never assigns the same color to both endpoints of an edge. Thus a proper coloring of a graph partitions its vertices into independent sets; each independent set is assigned a single color and called a color class. The chromatic number of a graph G, denoted χ(G), is the smallest k for which a proper k-coloring of G exists. An argument based on greedy coloring of G shows that χ(G) ≤ ∆(G) + 1.\nA coloring gives us several independent sets to choose from. At least one of these color classes must be at least as large as the average size of a color class. Consequently, α(G) ≥ |V (G)|/χ(G). However, properly coloring a graph\nusing the minimum number of colors is not equivalent to ﬁnding the largest independent set. In general there is no guarantee that the largest color class in a particular coloring is a maximum independent set or that any minimal coloring has a maximum independent set as a color class.\nA clique in a graph is a set of vertices that are all adjacent. The size of a largest clique in a graph G is denoted by ω(G). In a proper coloring, each vertex in a clique must be assigned a different color, so for any graph G, χ(G) ≥ ω(G).\nFor each string length n, the Varshamov-Tenengolts con- struction provides n + 1 distinct single deletion correcting codes. The largest of these codes is conjectured to be optimal, i.e., it is conjectured to solve the independent set problem on L 1,n . We show that together they optimally solve the coloring problem.\nDeﬁnition 4. For any x ∈ [2] n , let w(x) = n−1 i=0 (i + 1)x i . Call w(x) mod n + 1 the VT weight of x.\nThe VT contruction partitions [2] n into n+1 sets, each with a particular VT weight. Each of these sets is a code (cf. [4]) and an independent set in L 1,n . This makes the VT weight a coloring of L 1,n that uses n + 1 colors, although it has not usually been described in this language. To demonstrate that one cannot use fewer colors in any coloring of L 1,n , we will ﬁnd cliques of size n + 1 in L 1,n and use ω(G) ≤ χ(G).\nLemma 1. For each x ∈ [2] n−s , I s (x) induces a clique in L s,n . Furthermore |I s (x)| = s i=0 n i .\nProof: Any two vertices in I s (x) have a common sub- string of length n − s, x, so their deletion distance is at most s and they are adjacent in L s,n . The size of I s (x) is sourced from Levenshtein [5].\nThis gives us the result that an optimal coloring of L 1,n uses n + 1 colors.\nProof: The VT coloring uses n + 1 colors, and by taking s = 1 in Lemma 1, we see that there are cliques of n + 1 vertices in L 1,n . So n + 1 ≤ ω(L 1,n ) ≤ χ(L 1,n ) ≤ n + 1.\nThe largest color class (corresponding to VT weight zero) in the VT coloring of L 1,n always contains at least 2 n n+1 code- words. This sequence of independent sets is asymptotically maximum [4].\nWe now describe a new strategy for code construction for any number of deletions. For single deletion channels, the codes we construct are asymptotically optimal (Section III-A). In Section III-B we prove lower bounds on the sizes of our codes for any number of deletion. This strategy is inspired by a simple bound on deletion distance.\nProof: If z < x and z < y, then z must have fewer ones than either x or y as well as fewer zeros.\nLet L s,n,k be the subgraph of L s,n induced by the vertices with exactly k ones. The endpoints of any edge in L s,n differ in Hamming weight by at most s. Suppose we ﬁnd an independent set composed entirely of vertices of Hamming weight k, i.e. an independent set in L s,n,k , and another independent set entirely of vertices of weight k + s + 1, we can guarantee that their union is an independent set in L s,n . Then we can add another independent set in L s,n,k+2(s+1) and continue until we have exhausted the weights that are equal to k mod s + 1. This procedure gives us an independent set in L s,n . Figure 1 illustrates this for L 1,4 .\nAnother way to describe this process is that we start by throwing out all the vertices whose Hamming weights do not equal a mod s + 1. We keep only about 1 s+1 of the vertices, The remaining graph is disconnected. It has broken up into a component for each weight.\nThe strategy outlined above reduces the problem of ﬁnding an independent set in L s,n to the problem of ﬁnding indepen- dent sets in each of L s,n,k , k = 0, . . . , n. In the single deletion case (s = 1), we show an explicit construction of independent sets in the graphs L 1,n,k . We construct these independent sets by ﬁnding an optimal coloring of L 1,n,k . This coloring is closely related to the optimal VT coloring of L 1,n . The code that results is asymptotically optimal.\nLemma 4. The modiﬁed VT weight f (x) = w(x) mod (max(k, n − k) + 1) gives a proper coloring of L 1,n,k .\nProof: Let x and y be adjacent vertices in L 1,n,k . To show f (x) = f (y), we will show that 0 < |w(y) − w(x)| ≤ max(k, n − k). Let i be the smallest index where x i = y i and let j be the largest such index. Because d L (x, y) = 1, either x [n]\\i = y [n]\\j or x [n]\\j = y [n]\\i . Without loss of generality assume the latter. Because H(x) = H(y) = k, x j = y i . The\ninterval x {i..j−1} shifts right by one space to become y {i+1..j} so the contribution to the weight of each one in the interval increases by one. The bit x j moves j − i spaces to the left, so its contribution decreases by that amount. If l is the number of ones in x {i..j−1} , then w(y) − w(x) = l − x j (j − i).\nIf x i = 0. then w(y) − w(x) = l ≤ k. Since x = y, l > 0. On the other hand, if x i = 1, then w(y) − w(x) = l + i − j. There are j − i − l zeros in x [i,j) and only n − k zeros in all of x, so w(y) − w(x) ≥ k − n. Because x = y, l < j − i − 1 and w(y) − w(x) < 0.\nTo prove optimality, we need ω(L 1,n,k ). As in L 1,n we will look at cliques whose vertices have a single common substring. Let us introduce some notation.\nDeﬁnition 5. For x ∈ [n] k , let I s,r (x) = I s (x) ∩ [n+s] k+r . This is the number of superstrings of x of length n + s with exactly k + r ones.\nJust as the size of I s (x) only depends on the length of x, the size of the set I s,r (x) only depends on the length and weight of x. To prove this we will need the following lemma. Due to space limitations, we only sketch the proof.\nSketch of proof: For any x ∈ [2] n−s , there is a bijection between I s (x) and s i=0 [n+i−1] i \t × [2] s−i . Each superstring in I s (x) is produced by two types of operations: insertions of some number of negated bits before a bit of x and insertion of bits at the end of x. The sets [n+i−1] i \t encode the former operation and [2] s−i encode the latter. For any superstring in I s,r (x), let p be the number of ones and q be the number of zeros in the appended bit string, so there are p+q p such bit strings. There are r − p remaining new ones to insert before the n − k existing zeros, which can be done in n−k+r−p−1 r−p\nways. The remaining s − r − q zeros can be inserted before the k existing ones, in k+s−r−q−1 s−r−q \t ways. Summing over all possible values of p and q gives the size of I s,r (x) as\nThis sum can be simpliﬁed using the Vandermonde identity and a variation of it for multisets to give the result.\nProof: In Lemma 5, we ﬁx the length and weight of the substring to be n and k. Here we would like the length and weight of the superstrings to be n and k, so we substitute n−s for n and k − r for k in the previous result.\nProof: By Lemma 6, L 1,n,k contains cliques of sizes k+1 and n − k + 1. Lemma 4 gives the coloring.\nWe now show that this strategy produces independent sets in L 1,n that are asymptotically of optimal size. Let C n,k be\na largest color class of L 1,n,k using the coloring described above. Our code is the set D n,a ,\nLemma 7. |D n,a | ≥ 1 n+1 2 n − n k ∗ where k ∗ is (n − 1)/2 if n is odd, (n − 2)/2 if n is even and a ≡ n/2 mod 2 and n/2 otherwise.\nProof: We only consider the case where n is odd; the other case follows similarly. In each graph L 1,n,k , some color class must be at least as large as the average.\nThere are n k vertices in L 1,n,k and χ(L 1,n,k ) = max(k, n − k) + 1. Without loss of generality suppose (n − 1)/2 ≡ a mod 2. Thus |D n,a | is at least\nn k\nn k\nNote that max k χ(L 1,n,k ) = n, which is barely better than χ(L 1,n ) = n + 1. However, most of the vertices are in the subgraphs with Hamming weight ≈ n/2, and χ(L 1,n,n/2 ) = n/2 + 1. Thus, half the vertices have been thrown out, but the middle layers are colored about twice as efﬁciently as they were in the original graph. This explains the asymptotic optimality.\nFor s > 1, we do not have optimal explicit colorings of L s,n,k . However, we can use the maximum degrees of L s,n,k to lower bound the sizes of their maximum indepen- dent sets. Recall the relation from Section II-C, α(G) ≥ |V (G)|/(∆(G) + 1). This is equivalent to considering the performance of greedy colorings on these graphs.\nFirst we will obtain an asymptotic expression for the number of superstrings of a particular weight. We will use that to bound the degree of a vertex in L s,n,k . This will translate into a bound on independent set size.\nLemma 8. Let k = pn and x ∈ [n] k . For ﬁxed p, s, and r, |I s,r (x)| ∼ n s s! s r (1 − p) r p s−r\n∼ n c c! , this term becomes (n−pn) r (pn) s−r r!(s−r)! \t which we can rearrange into n s s! s r (1 − p) r p s−r .\nAs n becomes large, the weight distribution of vertices in L s,n concentrates around n/2, so we need to bound the number of insertions in that region only.\nLemma 9. Let k = pn, s 2s+2 ≤ p ≤ s+2 2s+2 , and x ∈ [n] k . Fix s and r ∈ [s + 1]. If s is even, then |I s,r (x)| 1 2 s s s/2 n s . If\nProof: Due to space limitations, we prove this only for the case where s is even. For each r ∈ [s + 1], let f r (p) =\n(1 − p) r p s−r . In the interval 1 − r+1 s+1 ≤ p ≤ 1 − r s+1 , f r (p) is the largest of the s + 1 polynomials. The maximum of f r (p) occurs at p = 1 − r s and the value achieved there is\nProof: For x ∈ [n] k , let d(x) be the degree of x in L s,n,k . Each vertex adjacent to x shares at least one substring of length n − s with it. We bound degree by considering the superstrings of the substrings of x. i.e.,\nSince each vertex has at most n s substrings of length n − s, there are at most n s terms in the sum. We can use Lemma 9 to bound |I s,r (y)|, which results in the desired bound.\nFinally, we can use the upper bound on degree to get a lower bound on code size.\nTheorem 4. For ﬁxed even s, codes produced by the constant weight strategy contain asymptotically at least \t 2 n+s\ncodewords. For even s this size is a factor of (s + 1) s s/2 less than Levenstein\u2019s asymptotic lower bound and for odd s it is\nWe drop the values of k that are outside the interval in the condition for Lemma 10.\nn k\nThe bound in the previous lemma does not depend on k. In the case where s is even, we get\nThe sum is asymptotic to 2 n . The factor is found by compar- ison with Levenshtein\u2019s lower bound, 2 n+s / n s 2 [4].\nTo demonstrate how well our construction performs, we applied this strategy to the cases of one and two deletions. We used a greedy algorithm to ﬁnd maximal independent sets in L 2,n,k for n ≤ 20. One advantage of working with the constant weight subgraphs L s,n,k is that they are much smaller than L s,n , which makes experiments more tractable. For each n, there is a set of layers for each remainder modulo three. We computed code sizes for each set and took the largest. The sizes of the codes that we found and the best known are given in Table I and their ratio is plotted in Figure 2.\nFor comparison, we computed the exact sizes of the codes given by our construction for s = 1. To do this, we determined which color class in L 1,n,k was largest for each n and k. The sizes of these codes are shown in Figure 3. For very small n, the codes are signiﬁcantly larger than the lower bound. This is because the gap between the size of largest color class and the average size is proportionally largest for small n. The effect is large enough that the ratio between these codes and the VT codes is fairly ﬂat across the plot even though the codes are asymptotically optimal.\nConsequently, it is difﬁcult to conclude much from the plot for s = 2. As in the s = 1 plot, the ratio is about 0.8 throughout. There might be a constant factor gap between the performance of the two strategies, convergence that is too slow to observe, or perhaps something else.\nWe translated the problem of ﬁnding deletion correcting codes into one of ﬁnding independent sets in L s,n . We dis- cussed coloring as means of constructing independent sets and demonstrated the the VT codes are optimal in a coloring sense. We described a strategy of decomposing the problem of ﬁnding\ncodes into a set of smaller problems by partitioning L s,n by Hamming weight and ﬁnding codes within each partition. In the single deletion case, we found an optimal coloring of L 1,n,k and showed that the code is asymptotically optimal. We proved a lower bound on size of codes constructed using these partitions that applies to any number of deletions. In the two deletion case, we compared the performance of the best known codes, which were found by searching all of L 2,n , and codes found using our strategy of searching each of L 2,n,k separately.\nThis work was supported in part by AFOSR under grants FA 9550-11-1-0016 and FA 9550-10-1-0573; and by NSF grant CCF 10-54937 CAR."},"refs":[{"authors":[{"name":"S. Butenko"},{"name":"P. Pardalos"},{"name":"I. Sergienko"},{"name":"V. Shylo"},{"name":"P. Stetsyuk."}],"title":{"text":"Find- ing maximum independent sets in graphs arising from coding theory"}},{"authors":[{"name":"A. S. J. Helberg"},{"name":"H. C. Ferreira"}],"title":{"text":"On multiple insertion/deletion correcting codes"}},{"authors":[{"name":"F. Khajouei"},{"name":"M. Zolghadr"},{"name":"N. Kiyavash"}],"title":{"text":"An algorithmic approach for ﬁnding deletion correcting codes"}},{"authors":[{"name":"V. I. Levenshtein"}],"title":{"text":"Binary codes capable of correcting deletions, inser- tions and reversals"}},{"authors":[],"title":{"text":"Efﬁcient reconstruction of sequences from their subsequences or supersequences"}},{"authors":[{"name":"N. Sloane"}],"title":{"text":"Challenge problems: Independent sets in graphs http://www2.research.att.com/ njas/doc/graphs.html"}},{"authors":[],"title":{"text":"On single-deletion-correcting codes"}},{"authors":[{"name":"R. R. Varshamov"}],"title":{"text":"On an arithmetic function with an application in the theory of coding"}},{"authors":[{"name":"D. B. Wes"}],"title":{"text":"Introduction to graph theory"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569566343.pdf"},"links":[],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S3.T7.3","endtime":"15:40","authors":"Daniel F Cullina, Ankur Kulkarni, Negar Kiyavash","date":"1341242400000","papertitle":"A Coloring Approach to Constructing Deletion Correcting Codes from Constant Weight Subgraphs","starttime":"15:20","session":"S3.T7: Deletion Channels","room":"Stratton (407)","paperid":"1569566343"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
