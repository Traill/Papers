{"id":"1569563763","paper":{"title":{"text":"On q -ary Antipodal Matchings and Applications"},"authors":[{"name":"Erik Ordentlich"},{"name":"Ron M. Roth"},{"name":"Gadiel Seroussi"}],"abstr":{"text":"Abstract\u2014We deﬁne a q-ary antipodal matching to be a perfect matching in the bipartite graph with vertices corresponding to words of length ℓ over the integer alphabet Q = {0, 1, . . . , q−1}, wherein the left and right vertices are those with respective component sums greater and smaller than ℓ(q −1)/2, and wherein two vertices are connected by an edge if one of the corresponding words dominates the other. We present two different construc- tions of efﬁciently computable q-ary antipodal matchings. We then show how such matchings can be used for encoding arbitrary data into n × n arrays over the alphabet Q all of whose row and column sums are at most n(q −1)/2. Such encoders might be useful for mitigating parasitic currents in a next generation memory technology based on crossbar arrays of resistive devices."},"body":{"text":"For any positive real r, let [r] denote the integer set {i ∈ Z : 0 ≤ i < r}. Hereafter, we ﬁx Q to be the integer alphabet [q], for some integer q ≥ 2. For a symbol x ∈ Q, we deﬁne its cost by c(x) = 2x − (q−1) (which may be negative) and its complement (over Q) by x = q−1−x; thus, c(x) = −c(x). We extend these deﬁnitions to words x = (x i ) i ∈[ℓ] over Q by deﬁning c(x) =\nConsider the bipartite graph (cf. [3]) G ℓ,q = ( L : R, E) with left and right vertex sets L and R and edges E given by\nL = L ℓ,q = { x ∈ Q ℓ : c(x) > 0 } R = R ℓ,q = { x ∈ Q ℓ : c(x) < 0 }\nAntipodal matchings for the special case of q = 2 were studied recently in [10]. As noted therein, for this case, the constituent bipartite graphs obtained by decomposing the graph G ℓ,q according to the cost of left and right vertices, are regular graphs, and hence it follows from Hall\u2019s theorem [3, pp. 217\u2013218] that perfect matchings exist. An explicit con- struction of a perfect matching for the case of q = 2 was also presented. In the case of q > 2, there does not seem to be an analogous regular decomposition of G ℓ,q , or at least one\nthat we are aware of, and thus, in the general case, it is not immediately evident that a perfect matching even exists.\nIt turns out that perfect matchings do in fact exist for all q and our ﬁrst set of results pertains to the constructions of two efﬁciently computable q-ary antipodal matchings, by which we mean that the bijection φ and its inverse are efﬁciently computable. For reasons related to the speciﬁcs of the con- structions, we shall refer to the two constructions, respectively, as the unary and complementary (q-ary antipodal) matchings. The complementary matching will satisfy, in addition, the following complementary property: if an edge (x, y) belongs to the matching, then y i ∈ {x i , x i } for each i ∈ [ℓ]. Though we lack the space to explain this here, complementary antipodal matchings exist in more general bipartite graphs than G ℓ,q and these graphs may have some potential advantages in the context of our main application for these matchings, which, as explained further below, is the construction of codes that might be useful for mitigating parasitic currents in a next generation memory technology. On the negative side, although we will show that matchings satisfying the complementary property exist for all q, we presently have explicit descriptions of such matchings only for limited q (still, when q is ﬁxed, the matching can be computed in time complexity that is linear in ℓ). Unary matchings, on the other hand, are speciﬁc to the graph G ℓ,q , but can be explicitly speciﬁed for all q, and can be computed requiring only O(ℓ) arithmetic operations on integers with absolute value at most ℓ(q −1).\nConsider the set A n ×n of all n ×n arrays A = (A i,j ) i,j ∈[n] over Q such that the cost of each row and column is nonpos- itive, namely, for every i, j ∈ [n],\nwhere the notation A i,[ℓ] (respectively, A [ℓ],j ) stands for the row (respectively, column) word formed by the ﬁrst ℓ entries of row i (respectively, column j) of an array A. Our principal application of q-ary antipodal matchings is to the problem of efﬁciently encoding and decoding arbitrary data to and from (a subset of) A n ×n . Following the usual formal deﬁnitions, a code for this problem (referred to as a row\u2013column cost limiting code) consists of a subset C ⊆ A n ×n , an encoder (bijection) from [ |C|] to C, and a respective decoder (inverse mapping). Of interest are codes for which the encoder and decoder can be computed with low complexity and C is as large as possible. Obviously, |C| ≤ |A n ×n | < q n 2 , and we shall refer to the gap n 2 log 2 q − log 2 |C| as the redundancy\nOur second set of results addresses this coding problem, by generalizing the row\u2013column cost limiting codes of [10] to the q-ary case, for q > 2. For the q-ary iterative ﬂipping code (generalizing the iterative ﬂipping code from [10]), the upper bound on the number of row\u2013column ﬂips during encoding increases by a factor of q −1. This provides even stronger motivation for the q-ary antipodal matching codes based on the above q-ary antipodal matchings, which avoid iterations. Both the q-ary iterative ﬂipping and q-ary antipodal matching codes constructed continue to have a redundancy of roughly 2n bits, as in the binary case. Thus, one new aspect of the q > 2 setting, as will be seen, is that the q-ary array positions that carry the redundancy also carry non-redundant information.\nThe motivation for encoding data into the constrained arrays A n ×n is, as in [10], to reduce parasitic current in a next generation memory technology based on crossbar arrays of resistive memory devices [9], [11]. The codes presented here extend this paradigm to devices which can be programmed into q > 2 resistance states. The rough idea is as follows. In the q-ary setting, the states of the devices in an n ×n crossbar can be represented by an n ×n array over Q. For a certain writing biasing scheme and overwriting protocol, the parasitic current magnitude passing through any device can be expressed as a non-decreasing function ϱ : Q → R + of the device state, and the maximum parasitic current magnitude passing through any wire of the crossbar can be bounded by the maximum sum of ϱ(A i,j ) over all rows and columns of the array. The parasitic current is thus data-dependent and, by encoding data using the above codes to limit row and column costs of the resulting arrays, the worst case current can be reduced. In the case that ϱ is an afﬁne function of the state, the constraint (1) is well matched to ϱ. As alluded to, in the general case, codes based on complementary matchings adapted to a different ϱ- dependent bipartite graph may have better current limiting properties than the above. For conciseness, here we will target only the above simpler scenario with afﬁne ϱ.\nBoth of our q-ary antipodal matching constructions are based on reductions to the binary case and, at least conceptu- ally, invoke the binary antipodal matching of [10] as a subrou- tine. The constructions differ in the nature of the reduction.\nLet B denote the binary (integer) alphabet {0, 1}. We include here a brief review of the binary antipodal matching from [10], whose bijection we shall denote by φ B . In this subsection, the deﬁnitions of cost and complementation cor- respond to q = 2, i.e., c(0) = −1, c(1) = 1, 0 = 1, and 1 = 0.\nGiven a word a = (a i ) i ∈[m] in B m with c(a) > 0, the image φ B (a) is deﬁned as follows. A position i ∈ [m] in a is called minimal (with respect to a) if and only if ∑\nc(a j ) > 0 for every natural h, where indices are wrapped around modulo m. Let P a denote the set of minimal\npositions. Note that P a is nonempty whenever c(a) > 0 and that a i = 1 for every i ∈ P a . For a ∈ B m with c(a) > 0, the mapping a → φ B (a) is then deﬁned by\nIn order to compute this mapping, the set P a must be deter- mined. There is an algorithm for ﬁnding the minimal positions that runs in time that is linear in ℓ and is described in Figure 4 of [10] (see also [5] and [6]). It follows from the results of [10] that φ B is a bijection from {a ∈ B m : c(a) > 0 } to {a ∈ B m : c(a) < 0 } and, so, it induces a perfect matching in the graph G m,2 .\nThe bijection underlying the unary matching will be denoted by φ U . It is based on the following unary coding of Q into words in B q −1 :\nNamely, a symbol x ∈ Q is mapped to a binary word of length q −1 with x = q−1−x initial 0\u2019s followed by x trailing 1\u2019s. It is obvious that u is invertible. The mapping u can be extended to words x = (x i ) i ∈[ℓ] in Q ℓ via u(x) = u(x 0 ) u(x 1 ) . . . u(x ℓ −1 ) (the concatenation of the symbol- wise mappings). This word extension, u : Q ℓ → u(Q ℓ ), is also readily seen to be invertible. The following lemma can be easily shown to follow from the properties of u and φ B .\nLemma 2.1: For every x ∈ L ℓ,q (the left vertex set in G ℓ,q ), φ B (u(x)) ∈ u(R ℓ,q ) ,\nwhere φ B is the bijection (2) deﬁned for binary words of length m = ℓ(q −1).\nLemma 2.1, in turn, allows us to deﬁne the following mapping φ U : L ℓ,q → R ℓ,q :\nφ U (x) = u −1 (φ B (u(x))) , x ∈ L ℓ,q . \t (3) In the next proposition, x ∗ stands for the word obtained by\nreversing the order of entries in the word complement x of x. Proposition 2.2: The mapping φ U : L ℓ,q → R ℓ,q is a bijec-\ntion, and, so, {(x, φ U (x)) : x ∈ L ℓ,q } is a perfect matching in G ℓ,q . Moreover, φ −1 U (y) = (φ U (y ∗ )) ∗ for every y ∈ R ℓ,q .\nWe point out that this construction can also be inferred from known explicit minimal partitions of Q ℓ into symmetric chains [2], [4], [7].\nComputing φ U via φ B as in (3) has complexity proportional to qℓ operations if the linear time algorithm from [10] is used for computing φ B . By exploiting constraints on the binary words in the range of u and properties of φ B , it is possible to carry out the computation more efﬁciently, with only a constant (independent of q) times ℓ operations on integers with absolute value at most ℓ(q −1). The algorithm is given in Figure 1. Roughly speaking, the ﬁrst loop \u201cidentiﬁes\u201d an element of P u(x) and the next loop identiﬁes the remaining elements and implements the bijection directly in the Q- domain. The following proposition can be proved.\nFor a word z = (z i ) i ∈[ℓ] in [q/2] ℓ , denote by M q (z) the subset {z 0 , z 0 } × {z 1 , z 1 } × . . . × {z ℓ −1 , z ℓ −1 } (of size 2 ℓ ) of Q ℓ , and deﬁne L q (z) = L ℓ,q ∩ M q (z) and R q (z) = R ℓ,q ∩ M q (z). Clearly, for z ranging over [q/2] ℓ , the sets L q (z) (respectively, R q (z)) form a partition of L ℓ,q (respectively, R ℓ,q ). For any z as above, let G q (z) be the bipartite subgraph of G ℓ,q that is induced by the vertices in L q (z) ∪ R q (z). An example of a graph G q (z) is shown in Figure 2.\ns s s s\ns s s s\nt t ¨¨ ¨ d\n   ¨¨ ¨  \n       ¨¨ ¨\nBy the complementary property of complementary matchings in G ℓ,q (deﬁned in Section I), to show their existence, it sufﬁces to show that a perfect matching exists in G q (z) for all q, ℓ, and all z ∈ [q/2] ℓ . This will follow from the next slightly more general matching result, which we prove below.\nProposition 2.4: Given a vector w ∈ R m with nonnegative entries, let σ be the sum of entries of w and let the bipartite graph G = G(w) = (L : R, E) be deﬁned by\nL = L(w) = {a ∈ B m : ⟨a, w⟩ > σ/2} R = R(w) = {a ∈ B m : ⟨a, w⟩ < σ/2} E = E(w) = {(a, b) ∈ L × R : a ≥ b}\nwhere ⟨·, ·⟩ denotes inner product. Then G exhibits a perfect matching.\nThe existence of the desired perfect matching in G q (z) then follows since this graph is isomorphic to the graph G(w) of Proposition 2.4 with w = −\n. The graph G(w) corresponding to the example G q (z) of Figure 2 is also shown in the ﬁgure, where, for better readability, the binary values 0, 1 are represented, respectively, as −, +.\nObserve that for the case where all the entries of w are equal, Proposition 2.4 follows from the binary antipodal matching results. In the general case, we prove Proposition 2.4\nby verifying the condition for the existence of a perfect matching in Hall\u2019s theorem, which is that all subsets of left vertices have at least as many right neighbors. Unlike the case where all entries of w are equal, generally, we are not able to partition the graph G(w) into a collection of regular induced subgraphs and, thus, checking Hall\u2019s condition is somewhat more involved. Key to our proof is the following classical com- binatorial lemma concerning set differences. Given two sets α and β, denote by α \\ β their set difference {s ∈ α : s ̸∈ β}. For a ﬁnite collection of sets X, let ∆X = {α\\β : α, β ∈ X} denote the collection of distinct differences of members of X.\nLemma 2.5 (Marica\u2013Sch¨onheim inequality [8]): |∆X| ≥ |X| .\nProof of Proposition 2.4: We verify that G(w) satisﬁes Hall\u2019s condition. Let X ⊆ L(w) and let N (X) ⊆ R(w) denote the set of neighbors of X. Consider the set\nwhere b denotes the (Boolean) word complement of b over B and \u201c∧\u201d denotes componentwise conjunction (\u201cAND\u201d). By regarding the words of L(w) as characteristic vectors of subsets of [m], it follows from Lemma 2.5 that |Y | ≥ |X|. We next argue that Y ⊆ N (X). To see this, consider a word v in Y . By (4), we can write v = a ∧ b for some a, b ∈ X, implying that v ≤ a and v ≥ b. From the latter inequality, we have ⟨w, v⟩ ≥ ⟨w, b⟩ > σ/2 so that ⟨w, v⟩ < σ/2, and this, together with v ≤ a, implies that v ∈ N (X) (since a ∈ X) or that Y ⊆ N (X). Putting everything together, we have |N (X)| ≥ |Y | ≥ |X|, thus verifying Hall\u2019s condition and completing the proof.\nUsing essentially the above technique (but with a novel variation of Lemma 2.5) we can also prove the following more general matching result, which may be of independent interest.\nProposition 2.6: Let G = (L : R, E) be a bipartite graph where L and R form any partition of B m with the property that a ∈ L if and only if a ∈ R, and where the edge set is\nE = {(a, b) ∈ L × R : a ≤ b or b ≤ a} . Then G exhibits a perfect matching.\nThe existence result derived from Proposition 2.4 does not provide, in general, an efﬁcient way for constructing the claimed perfect matching for G q (z) for arbitrary values of q and ℓ. In this subsection, we apply Proposition 2.4 in a slightly different way, resulting in an explicit construction of complementary matchings for arbitrary ℓ and limited values of q. The case of q = 2 is simply the binary antipodal matching of Subsection II-A, since it inherently has the complementary property. For q > 2, the idea of the construction is as follows.\nAssume for now that q is even. 1 Deﬁne the mapping p : Q → B by p(x) = 0 if x ∈ [q/2] and p(x) = 1 otherwise and, for z ∈ [q/2], let p z be the restriction of p\ns s s s\ns s s\n¨¨ ¨       \n       ¨¨ ¨\ns s s\ns s\nrrr rrr ¨¨ ¨ rrr rrr           ¨¨ ¨\ns s s s\ns s s\nt t ¨¨ ¨ d\n       ¨¨ ¨\nto the domain {z, z} (thus p −1 z is well deﬁned). Extend p z to map words over {z, z} to binary words by applying the mapping componentwise. Also, for x = (x i ) i ∈[ℓ] ∈ Q ℓ and z ∈ [q/2], let I z = I z (x) =\n∈ {z, z} } . The notation x |z will indicate the subword of x that is indexed by I z .\nFor q > 2, the value of the bijection φ C (x) underlying the complementary matching will be obtained by selectively applying the bijection f z = p −1 z ◦ φ B ◦ p z to the various subwords x |z . The decision to apply f z to any subword x |z will depend on the sign of c(x |z ) and on the result of yet another bijection h = h w , namely the one underlying a perfect matching guaranteed in Proposition 2.4 for the bipartite graph G(w) therein, with w equal to the vector w(x) deﬁned by\nSpeciﬁcally, for this w, ﬁx such a perfect matching of G(w) and let a(x) = (a z ) z ∈[q/2] be a binary vector with a z = 0 if c(x |z ) ≤ 0 and a z = 1 otherwise. It is not hard to see that x ∈ L ℓ,q if and only if a(x) ∈ L(w) in the graph G(w). Writing b(x) = h w(x) (a(x)), we now deﬁne the mapping φ C : L ℓ,q → R ℓ,q as follows: for every x ∈ L ℓ,q , the image y = φ C (x) satisﬁes I z (y) = I z (x) for every z ∈ [q/2], and the subword y |z is given by\nProposition 2.7: For the mapping φ C so deﬁned, the set {(x, φ C (x)) : x ∈ L ℓ,q } is a complementary matching in G ℓ,q .\nThe proof is straightforward and relies on the fact that w(x) and b(x) can be recovered from φ C (x) and, hence, so can a(x) by the bijectivity of h w(x) . To complete the above construction of φ C , we must explicitly specify the bijection h w for each possible w. In principle, the variety of mappings is bounded for any ﬁxed q (i.e., is independent of ℓ for ℓ sufﬁciently large), since there are ﬁnitely many distinct graphs G(w) that can be induced by different w. For one thing, given a w, the graphs induced by all ˜ w which are permutations of w are isomorphic (through a permutation of indices of the words representing the vertices). It thus sufﬁces to consider w satisfying w 0 ≥ w 1 ≥ . . . ≥ w q/2 −1 . Even so, the number of the induced graphs grows rather quickly with q. The vertex sets of such graphs are closely related to the self-dual equivalence classes of Boolean threshold functions of q/2 or fewer variables (see, e.g., [1]; here, we distinguish cases when the threshold can be met with equality). For limited q (the sequence in [1] is given up to q/2 = 10), these graphs, along with the corresponding perfect matching/bijection h, can be computed explicitly. For example, in the case of q = 6, there\nare three different graphs that can arise depending on relations between the entries of w = (w 0 w 1 w 2 ). The relations, the graphs, and the corresponding matchings for this case are shown in Figure 3.\nRemark 2.1: The above construction essentially solves the matching problem for G ℓ,q , with small q and arbitrary ℓ, by reducing it to one for G ℓ \u2032 ,q \u2032 with small ℓ \u2032 (namely, q/2) and large q \u2032 (proportional to ℓ). For example, the rightmost graph of Figure 3, which arises when solving for G ℓ,6 , is the same as the graph in Figure 2, which arose when solving for G 3,4 . Thus, there appears to be a duality between these regimes.\nIn this section, we apply the q-ary antipodal matchings of Section II to the problem of encoding data into A n ×n , as described in Section I. We begin with a generalization of the iterative ﬂipping code presented in [10] to the case of q > 2. As in [10], complexity considerations of this scheme will motivate alternatives based on q-ary antipodal matchings. In this section, for simplicity, we will assume that q = 2 k , k > 1.\nThe q-ary iterative ﬂipping code for q = 2 k encodes kn 2 −2n+1 information bits into n×n arrays belonging to A n ×n . Encoding proceeds as in Figure 4. The ﬂip oper- ation in the algorithm corresponds to applying the word- complementation mapping x → x to the respective rows and/or columns.\nThe encoding procedure is guaranteed to terminate since each row or column ﬂip strictly reduces the sum of all array entries. Since the procedure terminates only when no row or column has positive cost, the ﬁnal array must belong to A n ×n .\nLet U = (U i,j ) i,j ∈[n] denote the array formed after Steps 1\u2013 2 in Figure 4. The array U consists of the input bits u interpreted as elements of Q = [q] and [q/2], and we shall refer to it as the input array. In a manner similar to the binary case in [10], the input array U can be decoded as follows from the encoded array A.\nProposition 3.1: If U and A are respectively the input array and the encoded array from the algorithm of Figure 4, then\n⊕ p(A n −1,j ) ⊕ p(A n −1,n−1 ) = 0 U i,j otherwise\nwhere p( ·) is as deﬁned in Subsection II-D and \u201c⊕\u201d denotes addition modulo 2 (\u201cexclusive-OR\u201d).\nThus, as in the binary case, the number of operations required for decoding is linear in the number of array entries. The true complexity of encoding, on the other hand, is less clear. The best guarantee we have presently is an upper bound of O(qn 2 ) row\u2013column ﬂips (equivalently, O(qn 3 ) symbol ﬂips) and iterations between rows and columns, which follows readily from the above-noted fact that each row\u2013column ﬂip strictly reduces the sum of array entries by at least 1. The complexity guarantee thus grows linearly with q, which could be problematic in practical applications.\nIn this subsection, we generalize the two-dimensional an- tipodal matching code from [10] to the case of q > 2, making use of the q-ary antipodal matching constructions of Section II. The key idea is that the underlying q-ary antipodal matching (unary or complementary) permits iteration-free encoding by not creating new constraint violations, unlike the row\u2013column ﬂips of the iterative ﬂipping encoder.\nThe unary and complementary matchings of Section II give rise to slightly different antipodal matching code constructions, with the difference being primarily in how redundancy is incorporated to allow for decodability. We shall provide the details only for the unary matching. Also, we shall conﬁne our description to even n and (again) q = 2 k , though the basic idea applies generally.\nFor these choices, a key property of the unary q-ary antipo- dal matching is that the bijection φ U (x) preserves the parity of the sum\nx i ; equivalently, it preserves the remainder of the cost c(x) modulo 4. This will be the means for incorporating the aforementioned redundancy. Figures 5 and 6 depict the encoding and decoding algorithms for the antipodal matching code that is based on unary matching. In these ﬁgures, the\noperation \u201c%\u201d stands for remaindering, and the ﬂip operation is the same as in Subsection III-A.\nProposition 3.2: The output array A of the encoder of Figure 5 belongs to A n ×n .\nProposition 3.3: Provided that the input to Figure 6 is an array A that was generated as output in Figure 5, the kn 2 −2n−4 bits in the output u \u2032 in Figure 6 coincide with the corresponding input bits u in Figure 5.\nReferring to the encoding algorithm of Figure 5, we see that the unary q-ary antipodal matching bijection φ U may be applied to cost constraint violating (partial) columns and rows (e.g., Step 5a). By the domination property of the matching, namely, φ U (x) ≤ x, no new (row) constraint violations are induced by these steps. Whether φ U has been applied to a particular column is encoded, in some cases (e.g., Step 5b), in the parity of the sums of the corresponding columns, exploiting the aforementioned parity preserving property of φ U ."},"refs":[{"authors":[],"title":{"text":"The On-Line Encyclopedia of Integer Sequences, published electroni- cally at http://oeis"}},{"authors":[{"name":"L. Bigg"}],"title":{"text":"N"}},{"authors":[{"name":"N. de Bruij"},{"name":"C. Tengberge"},{"name":"D. Kruyswij"}],"title":{"text":"On the set of divisors of a number, Nieuw Arch"}},{"authors":[{"name":"A. Dvoretzk"}],"title":{"text":"Th"}},{"authors":[{"name":"C. Green"},{"name":"J. Kleitma"}],"title":{"text":"D"}},{"authors":[{"name":"E. Ordentlic"},{"name":"M. Ribeir"},{"name":"M. Rot"},{"name":"G. Serouss"},{"name":"O. Vontobe"}],"title":{"text":"G"}},{"authors":[{"name":"E. Ordentlic"},{"name":"M. Rot"}],"title":{"text":"R"}},{"authors":[{"name":"B. Struko"},{"name":"S. William"}],"title":{"text":"D"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569563763.pdf"},"links":[{"id":"1569560427","weight":5},{"id":"1569566579","weight":5},{"id":"1569565589","weight":5},{"id":"1569565493","weight":5}],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S1.T6.3","endtime":"10:50","authors":"Erik  Ordentlich, Ron M. Roth, Gadiel Seroussi","date":"1341225000000","papertitle":"On q-ary antipodal matchings and applications","starttime":"10:30","session":"S1.T6: Combinatorial Problems in Coding","room":"Kresge Rehearsal A (033)","paperid":"1569563763"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
