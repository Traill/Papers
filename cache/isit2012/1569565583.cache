{"id":"1569565583","paper":{"title":{"text":"Erasure Coding for Real-Time Streaming"},"authors":[{"name":"Derek Leong"},{"name":"Tracey Ho"}],"abstr":{"text":"Abstract\u2014We consider a real-time streaming system where messages are created sequentially at the source, and are encoded for transmission over a packet erasure channel. Each message must subsequently be decoded at the receiver within a given delay from its creation time. We consider code design and maximum message rates when all messages must be decodable by their respective deadlines under a speciﬁed set of erasure patterns (erasure model). Speciﬁcally, we provide a code construction that achieves the optimal rate for an asymptotic number of messages, under erasure models containing a limited number of erasures per coding window, per sliding window, and containing erasure bursts of a limited length."},"body":{"text":"We consider packet erasure correction coding for a real-time streaming system where messages are created sequentially at the source, and each message must be decoded at the receiver within a given delay from its creation time. The coding scheme is designed to ensure recovery of messages under a given set of possible erasure patterns (erasure model).\nIn particular, we consider three erasure models: the ﬁrst model considers a limited number of erasures in each coding window, the second considers a limited number of erasures in each sliding window, while the third considers erasure bursts of a limited length. For each erasure model, the objective is to ﬁnd an optimal code that achieves the maximum message size among all codes that allow all messages to be decoded by their respective deadlines under all admissible erasure patterns.\nWe present an explicit intrasession code construction which speciﬁes an allocation of each packet\u2019s capacity among the different messages; coding occurs within each message but not across messages. Intrasession coding is attractive due to its relative simplicity, but it is not known in general when intrasession coding sufﬁces or when intersession coding is needed. We show that for an asymptotic number of messages, our code construction achieves the optimal rate among all codes (intrasession or intersession) for the ﬁrst and second erasure models with any given number of erasures per window, and for the third erasure model with sufﬁciently short or long erasure bursts.\nIn related work, Martinian et al. [1], [2] provided construc- tions of streaming codes that minimize the delay required to\ncorrect erasure bursts of a given length. Tekin et al. [3] consid- ered erasure correction coding for a non-real-time streaming system where all messages are initially present at the encoder.\nWe begin with a formal deﬁnition of the problem in Section II, and proceed to describe the construction of our intrasession code in Section III. We then demonstrate the optimality of this code under each erasure model in the subsequent sections. Proofs of some theorems can be found in Appendix B; complete proofs are deferred to the extended paper [4].\nConsider a discrete-time data streaming system comprising a source and a receiver, with a directed link of normalized unit capacity from the source to the receiver. The source creates independent messages of uniform size s > 0 at regular intervals of c ∈ Z + time steps, and is allowed to transmit at most a unit amount of coded data over the link at each time step. The receiver attempts to decode each message within d ∈ Z + time steps of its creation.\nMore precisely, each message k ∈ Z + is created at time step (k − 1)c + 1, and is to be decoded by time step (k − 1)c + d. The coded data transmitted at each time step t ∈ Z + must be a function of messages created at time step t or earlier. Let coding window W k be the interval of d time steps between the creation time and the decoding deadline of message k, i.e.,\nWe shall assume that d > c so as to avoid the degenerate case of nonoverlapping coding windows for which it is sufﬁcient to code individual messages separately.\nConsider the ﬁrst n messages {1, . . . , n}, and the union of their (overlapping) coding windows T n , given by\nAn erasure pattern E ⊆ T n speciﬁes the set of erased or lost data transmissions over the link. More precisely, if t ∈ E, then none of the data transmitted at time step t is received by the receiver; if t ∈ T n \\E, then all of the data transmitted at time step t is received by the receiver at time step t. An erasure model essentially describes a distribution of erasure patterns.\nFor a given pair of positive integers a and b, we deﬁne the offset quotient q a,b and remainder r a,b to be the unique\nNote that our deﬁnition departs from the usual deﬁnition of quotient and remainder in that r a,b can be equal to b but not 0.\nWe present an intrasession code which codes only within each message and not across different messages. We begin by specifying the amount of link capacity allocated for the encoding of each message at each time step. An appropriate code (e.g., random linear coding, MDS code) is then applied to the allocation so that each message can be decoded whenever the total amount of received data that encodes that message is at least the message size s.\nThe allocation of link capacity follows a simple rule: the link capacity at each time step is divided evenly among all active messages. We say that message k is active at time step t if and only if t falls within its coding window, i.e., t ∈ W k . Fig. 1 shows how much link capacity at each time step is allocated to each message, for two instances of (c, d).\nFor a given choice of c and d, the messages that are encoded at a given time step t ∈ Z + can be stated explicitly as follows: First, we deﬁne A t to be the set of active messages at time step t, i.e.,\n− d c\n− 1 c\nTreating nonpositive messages 0, −1, −2, . . . as dummy mes- sages, we can write\nIt follows that the number of active messages |A t | varies over time depending on the value of r t,c ; speciﬁcally, two cases are possible:\nThe q d,c + 1 messages of A t are therefore encoded at time step t, with each message allocated 1 q\namount of link capacity.\nThe q d,c messages of A t are therefore encoded at time step t, with each message allocated 1 q\nNote that when d is a multiple of c, we have r t,c ≤ r d,c = c for any t, which implies that q d,c + 1 messages are encoded at every time step.\nIn our subsequent performance analysis of this code, we make repeated use of two key code properties; these are presented as technical lemmas in Appendix A.\nFor the ﬁrst erasure model, we look at erasure patterns that have a limited number of erasures per coding window. Consider the ﬁrst n messages {1, . . . , n}, and the union of their (overlapping) coding windows T n . Let E CW n be the set of erasure patterns that have z or fewer erasures in each coding window W k , i.e.,\nThe objective is to construct a code that allows all n mes- sages {1, . . . , n} to be decoded by their respective deadlines under any erasure pattern E ∈ E CW n . Let s CW n be the maximum message size that can be achieved by such a code, for a given choice of n, c, d, and z.\nWe observe that over a ﬁnite time horizon (i.e., when the number of messages n is ﬁnite), intrasession coding can be suboptimal. For example, given (n, c, d, z) = (3, 1, 3, 1), the optimal intrasession code (which can be found by solving a linear program) achieves a message size of 6 7 , which is strictly smaller than the maximum achievable message size s CW n of 1 obtained by intersession coding, e.g., transmitting messages (1, 2, 1 ⊕2, 3, 3) at time steps (1, 2, 3, 4, 5), respectively.\nHowever, it turns out that the intrasession code constructed in Section III is asymptotically optimal; the gap between the maximum achievable message size s CW n and the message size achieved by the code vanishes as the number of messages n goes to inﬁnity:\nTheorem 1. The code constructed in Section III is asymp- totically optimal in the following sense: the code achieves a message size of\nwhich is equal to the asymptotic maximum achievable message size lim n →∞ s CW n , where y = (y 1 , . . . , y d ) is deﬁned as\nWe prove the above theorem by considering a cut-set bound corresponding to a speciﬁc \u201cworst-case\u201d erasure pattern in which exactly z erasures occur in every coding window. This erasure pattern is chosen with the help of Lemma 2; speciﬁcally, the erased time steps are chosen to coincide with the larger blocks allocated to each message in the constructed code.\nFor the second erasure model, we look at erasure patterns that have a limited number of erasures per sliding window of d time steps. Consider the ﬁrst n messages {1, . . . , n}, and the union of their (overlapping) coding windows T n . Let sliding window L t denote the interval of d time steps beginning at time step t, i.e.,\nLet E SW n be the set of erasure patterns that have z or fewer erasures in each sliding window L t , i.e.,\nThe objective is to construct a code that allows all n mes- sages {1, . . . , n} to be decoded by their respective deadlines under any erasure pattern E ∈ E SW n . Let s SW n be the maximum message size that can be achieved by such a code, for a given choice of n, c, d, and z.\nWe note that since E SW n ⊆ E CW n , we therefore have s SW n ≥ s CW n . For the special case of c = 1, each sliding win- dow is also a coding window, and so this sliding window erasure model reduces to the coding window erasure model of Section IV, i.e., E SW n = E CW n . Over a ﬁnite time horizon, intrasession coding can also be suboptimal for this erasure model; the illustrating example from Section IV applies here as well.\nSurprisingly, the constructed intrasession code also turns out to be asymptotically optimal over all codes; the omission of erasure patterns in E SW n compared to E CW n has not led to an increase in the maximum achievable message size (cf. Theorem 1):\nTheorem 2. The code constructed in Section III is asymp- totically optimal in the following sense: the code achieves a message size of\nwhich is equal to the asymptotic maximum achievable message size lim n →∞ s SW n .\nProving the above theorem requires a different approach from that of Theorem 1. When d is a multiple of c, we need only consider a cut-set bound corresponding to an obvious \u201cworst-case\u201d erasure pattern in which exactly z erasures occur in every sliding window, speciﬁcally, a periodic erasure pattern with alternating intervals of z erasures and d − z nonerasures. When d is not a multiple of c, we consider a \u201cbase\u201d erasure pattern E \u2032 chosen with the help of Lemma 2, and inductively compute an upper bound for the conditional entropy\nby using erasure patterns derived from the base, where X t is a random variable representing the coded data transmitted at time step t, M k is a random variable representing message k, X[A] (X t ) t ∈A , and M [A] (M k ) k ∈A . The nonnegativity of this expression leads us to a bound for s SW n that matches the message size achieved by the constructed code in the limit n → ∞.\nFor the third erasure model, we look at erasure patterns that contain erasure bursts of a limited number of time steps. Consider the ﬁrst n messages {1, . . . , n}, and the union of their (overlapping) coding windows T n . Let E B n be the set of erasure patterns in which each erasure burst is z or fewer time steps in duration, and consecutive bursts are separated by a gap of d − z or more time steps, i.e.,\nThe objective is to construct a code that allows all n messages {1, . . . , n} to be decoded by their respective deadlines under any erasure pattern E ∈ E B n . Let s B n be the maximum message size that can be achieved by such a code, for a given choice of n, c, d, and z.\nUsing the proof technique of Theorem 2, we can show that the constructed intrasession code is asymptotically optimal when the erasure bursts are sufﬁciently short or long:\nthen the code constructed in Section III is asymptotically optimal in the following sense: the code achieves a message size of\nwhich is equal to the asymptotic maximum achievable message size lim n →∞ s B n .\nThe ﬁrst property describes when it is possible to decode each message:\nLemma 1 (Message Decodability). Consider the code con- structed in Section III for a given choice of c and d. If message size s satisﬁes the inequality\nwhere y = (y 1 , . . . , y d ) is as deﬁned in Theorem 1, then each message k ∈ Z + can be decoded from the data at any ℓ time steps in its coding window W k .\nThe second property describes a way of partitioning time steps into sets with certain speciﬁc properties, which are used in our speciﬁcation of the worst-case erasure patterns:\nLemma 2 (Partition of Coding Windows). Consider the code constructed in Section III for a given choice of c and d. Consider the ﬁrst n messages {1, . . . , n}, and the union of their (overlapping) coding windows T n . The set of time steps T n can be partitioned into d sets T (1) n , . . . , T (d) n , given by\n              \nif r i,c ≤ r d,c , {( j q\n(i) Over the time steps in the set T (i) n , each message k ∈ {1, . . . , n} is allocated 1 q\namount of link ca- pacity if r i,c ≤ r d,c , and 1 q\n(ii) The allocated link capacity in T (i) n for each message k ∈ {1, . . . , n} is contained within a single time step (as opposed to being spread over multiple time steps).\n(iii) The total amount of link capacity over all time steps in T (i) n , i.e., T (i) n , has the following upper bound:\n      \nFig. 2 shows how the set of time steps T n is partitioned into the d sets T (1) n , . . . , T (d) n , for two instances of (c, d).\nProof of Lemma 1: Consider a given message k ∈ Z + and its coding window\namount of link capacity; at all other time steps t / ∈ W k , message k is allocated zero link capacity.\nLet x i be the amount of link capacity at time step t = (k − 1)c + i that is allocated to message k. Writing t in terms of q i,c and r i,c produces\nIt follows from the code construction that the value of x i depends on r i,c ; speciﬁcally, two cases are possible:\n. Since i ∈ {1, . . . , d}, this condition corresponds to the case where q i,c ∈ {0, . . . , q d,c } and r i,c ∈ {1, . . . , r d,c }. Therefore, message k is allocated 1 q\namount of link capacity per time step for a total of (q d,c + 1)r d,c time steps in the coding window W k .\n. Since i ∈ {1, . . . , d}, this condition corresponds to the case where q i,c ∈ {0, . . . , q d,c − 1} and r i,c ∈ {r d,c + 1, . . . , c }. Therefore, message k is allocated 1 q\namount of link capacity per time step for a total of q d,c (c − r d,c ) time steps in the coding window W k .\nObserve that y is simply a vector containing the elements of {x i } d i=1 sorted in ascending order. Since\nit follows that over any ℓ time steps in the coding window W k , the total amount of link capacity allocated to message k is at least\ny j . Therefore, as long as the message size s does not exceed\ny j , message k can always be decoded from the data at any ℓ time steps in W k .\nProof of Theorem 1: Consider the code constructed in Section III for a given choice of c and d. According to Lemma 1, if message size s satisﬁes the inequality\nthen any message k ∈ {1, . . . , n} can be decoded from the data at any d − z time steps in its coding window W k . Therefore, the code achieves a message size of\ny j , by allowing all n messages {1, . . . , n} to be decoded as long as there are z or fewer erasures in each coding window W k , or equivalently, under any erasure pattern E ∈ E CW n . We will proceed to show that this message size matches the maximum achievable message size s CW n in the limit, i.e.,\nTo obtain an upper bound for s CW n , we consider the cut- set bound corresponding to a speciﬁc erasure pattern E \u2032 from E CW n . Let {1, . . . , d} be partitioned into two sets V (1) and V (2) , where\nv (1) is the vector containing the (q d,c + 1)r d,c elements of V (1) sorted in ascending order, and v (2) is the vector contain- ing the q d,c (c − r d,c ) elements of V (2) sorted in ascending order. Deﬁne the erasure pattern E \u2032 ⊆ T n as follows:\nwhere T (i) n is as deﬁned in Lemma 2. Since the code al- locates a positive amount of link capacity to each message k ∈ {1, . . . , n} only within its coding window W k , it follows from Property (ii) of Lemma 2 that for each set T (i) n , we have\nbecause T (1) n , . . . , T (d) n are disjoint sets. Therefore, E \u2032 is an admissible erasure pattern, i.e., E \u2032 ∈ E CW n .\nNow, consider a code that achieves the maximum message size s CW n . Such a code must allow all n messages {1, . . . , n} to be decoded under the speciﬁc erasure pattern E \u2032 . We therefore have the following cut-set bound for s CW n :\nApplying the upper bounds in Property (iii) of Lemma 2, and writing the resulting expression in terms of y j produces\ny j is known to be achievable (by the code constructed in Section III), we have the following upper and lower bounds for s CW n :\n1 n"},"refs":[{"authors":[{"name":"E. Martinian"},{"name":"C.-E. W. Sundberg"}],"title":{"text":"Low delay burst erasure correction codes"}},{"authors":[{"name":"E. Martinian"},{"name":"M. Trott"}],"title":{"text":"Delay-optimal burst erasure code construc- tion"}},{"authors":[{"name":"F. Tekin"},{"name":"S. Vyetrenko"},{"name":"T. Ho"},{"name":"H. Yao"}],"title":{"text":"Erasure correction for nested receivers"}},{"authors":[{"name":"D. Leong"},{"name":"T. Ho"}],"title":{"text":"Erasure coding for real-time streaming."}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569565583.pdf"},"links":[{"id":"1569565867","weight":10},{"id":"1569566981","weight":10},{"id":"1569566683","weight":10},{"id":"1569558325","weight":10},{"id":"1569566795","weight":10},{"id":"1569561679","weight":20},{"id":"1569566895","weight":10},{"id":"1569565535","weight":10},{"id":"1569565735","weight":10},{"id":"1569566445","weight":10},{"id":"1569564333","weight":10},{"id":"1569566003","weight":10},{"id":"1569565185","weight":10},{"id":"1569555787","weight":10},{"id":"1569566857","weight":10},{"id":"1569566779","weight":10},{"id":"1569565661","weight":10},{"id":"1569561221","weight":10},{"id":"1569566601","weight":10},{"id":"1569557851","weight":10},{"id":"1569565561","weight":10},{"id":"1569566583","weight":10},{"id":"1569565853","weight":10},{"id":"1569566797","weight":10},{"id":"1569566973","weight":10},{"id":"1569565031","weight":10},{"id":"1569565139","weight":10}],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S2.T6.4","endtime":"12:50","authors":"Derek Leong, Tracey Ho","date":"1341232200000","papertitle":"Erasure Coding for Real-Time Streaming","starttime":"12:30","session":"S2.T6: Constrained Coding","room":"Kresge Rehearsal A (033)","paperid":"1569565583"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
