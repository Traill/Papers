{"id":"1569560427","paper":{"title":{"text":"Burst List Decoding of Interleaved Reed\u2013Solomon Codes"},"authors":[{"name":"Tom Kolan"},{"name":"Ron M. Roth"}],"abstr":{"text":"Abstract\u2014It is shown that interleaved Reed\u2013Solomon codes can be list-decoded for burst errors while attaining the generalized Reiger bound for list decoding."},"body":{"text":"Coding schemes for list decoding of isolated (random) errors\u2014especially schemes that are based on Reed\u2013Solomon codes and derivatives thereof\u2014have been studied quite exten- sively [2]\u2013[6]. Less, however, has been published about list decoding of burst errors. In a recent paper [7], several bounds were obtained on the parameters of list decodable codes for single bursts. It was also shown there that Reed\u2013Solomon codes attain these bounds. We will review some of the results of [7] below, after introducing some deﬁnitions and notation.\nThroughout this work, we let F denote the ﬁnite ﬁeld GF(q). The order of an element γ in the multiplicative group F ∗ will be denoted by O(γ). For integers i < j, the notation [i, j ⟩ stands for the integer interval {k ∈ Z : i ≤ k < j}.\nWe say that a word e ∈ F n is a τ -burst if either e = 0 (the all-zero word) or the indexes i and j (in [0, n ⟩) of the ﬁrst and last nonzero entries in e satisfy j −i < τ. For a nonzero word e, the notation λ(e) will stand for the value of i above, and the value j − i + 1 will be referred to as the (actual) length of the τ -burst and will be denoted by L(e) (where L(0) = 0). The set of all τ -bursts in F n will be denoted by B(n, τ).\nFor a code C of length n over F and a word y ∈ F n , we denote by y − C the set {y − c : c ∈ C} (when C is linear, this set is a coset of C within F n ). The minimum (Hamming) distance of C will be denoted by d(C).\nLet C be a code of length n over F . A (list) decoder for C is a mapping D from F n to the set of subsets of F n , such that D(y) ⊆ y − C for every y ∈ F n (we knowingly deviate here from the standard deﬁnition of a decoder in that D returns a list of error words rather than codewords). The list size of a decoder D is the largest size of D(y) over all y ∈ F n .\nWe say that D detects any single τ-burst error if for every c ∈ C and e ∈ B(n, τ),\nSuch a decoder for C exists if and only if (c − C) ∩ B(n, τ) = {0} for every c ∈ C. In particular, such a decoder exists if d( C) > τ.\n(y − C) ∩ B(n, τ) ⊆ D(y) . \t (1) An (ℓ, τ )-burst list decoder for C is a decoder for C of list\nsize at most ℓ that corrects any single τ -burst error. From (1), it readily follows that such a decoder exists if and only if for every y ∈ F n ,\nThe following generalization of the Reiger bound (special- ized to linear codes) was recently proved in [7].\nTheorem 1.1 ([7, Thms. 2.2\u20132.3]): Let C be a linear code of length n over F and let τ and ℓ be positive integers that satisfy the following three conditions:\n2) There is a decoder for C that detects any single τ-burst error.\nThen the redundancy r of C satisﬁes the lower bound r ≥ τ + ⌈τ/ℓ⌉ .\nConversely, it was also shown in [7] that shortened Reed\u2013 Solomon codes (in short, RS codes) attain this bound.\nTheorem 1.2 ([7, Thm. 4.1]): For 0 ≤ r < n < q, let C RS (n, r) denote the RS code of length n and redundancy r over F with a parity-check matrix\nwhere α ∈ F ∗ with O(α) ≥ n. There is an (ℓ, τ)-burst list decoder for C RS (n, r), whenever ℓ and τ are positive integers that satisfy\n(Note that condition 2 in Theorem 1.1 is also satisﬁed in this case, since d( C RS ) = r + 1 > τ .)\nOne drawback of RS codes is that their length is limited to at most q − 1. In this work, we show that for the case where ℓ divides τ , the bound of Theorem 1.1 is attained also by a (τ /ℓ)-level interleaving of C RS (n, ℓ+1), thereby introducing optimal codes that are τ /ℓ times longer (for ℓ = 1, this result is straightforward and well known). Furthermore, we demonstrate that interleaved RS codes can be list-decoded for\nbursts using an algorithm that is (signiﬁcantly) more efﬁcient than a burst list decoder for a non-interleaved RS code with comparable parameters. To show that the interleaving indeed works, we prove a reﬁnement of Theorem 1.2 for the case τ = ℓ. Finally, we show through an example that, unlike the special case of RS codes, interleaving does not always preserve the list-decoding properties of the constituent code.\nIn this section, we consider the case τ = ℓ and prove that the (ℓ, ℓ)-burst list decoder D guaranteed in Theorem 1.2 can be assumed to satisfy a certain relationship between the size of each list D(y) and the lengths of the bursts in D(y). This relationship will then be used in Section III to show that interleaved RS codes attain the bound of Theorem 1.1. We recall the next theorem from [7], which will be used in the sequel; hereafter, F δ [x] denotes the set of all univariate polynomials of degree less than δ over F in the indeterminate x.\nTheorem 2.1 ([7, Thm. 3.1]): For integers 1 < m ≤ r < q, let β 0 , β 1 , . . . , β m −1 be elements in F ∗ and let γ ∈ F ∗ be such that O(γ) ≥ r. Also, let µ 0 , µ 1 , . . . , µ m −1 be positive integers such that\n(which is regarded as a univariate polynomial in the indeter- minate x, with β i and γ serving as parameters). The following two conditions are equivalent:\nu i (x) ∈ F µ i [x], i ∈ [0, m⟩ , not all zero, such that\n(ii) For some distinct h, k ∈ [0, m⟩ and some integer b in the range −µ h < b < µ k ,\nNext, we state a reﬁnement of Theorem 1.2 for the case τ = ℓ: we provide a stronger property of the guaranteed list decoder D therein, in terms of the lengths of the decoded bursts. Namely, if one or more of the decoded bursts turns out to have actual length that is (strictly) smaller than ℓ, then such \u201cdeﬁciency\u201d in the burst length implies that the size of the decoded list size must, in fact, be (strictly) smaller than ℓ.\nTheorem 2.2: For integers 0 < ℓ < r < n < q, let C RS (n, r) be as in Theorem 1.2, and let the decoder D for C RS (n, r) be deﬁned for every y ∈ F n by\nThen D is an (ℓ, ℓ)-burst list decoder for C RS (n, r), and the following inequality is satisﬁed for every y ∈ F n \\ C RS (n, r):\nLemma 2.3: For integers 0 < ℓ < n < q, let C RS = C RS (n, ℓ+1) be as deﬁned in Theorem 1.2 and let\nbe words in B(n, ℓ), all belonging to the same nontrivial coset y − C RS (where y ̸∈ C RS ). Then\nProof: The proof builds upon the one given in [7] for Theorem 1.2 but requires additional arguments in order to get to the ﬁner result. We will assume in the proof that n = O(α) (otherwise, append O(α) − n zeroes to each e i and apply the proof to C RS ( O(α), ℓ+1)).\nµ i ≤ ℓ. Suppose to the contrary that\nµ i ≥ ℓ + 1. Without real loss of generality, we will assume hereafter in the proof that the latter inequality holds with equality; otherwise, we can increase some of the τ i \u2019s (effectively replacing some of the actual burst lengths by upper bounds on these lengths) and decrease the respective values of µ i (= ℓ+1 −τ i ) accordingly, to achieve the equality\nbe the specialization of (3) to γ = α, β i = α λ i , r = ℓ + 1, and µ i as in (5). The next steps in our proof are very similar to the proof of Theorem 1.2 in [7], with r and ℓ therein replaced by ℓ + 1 and m − 1, respectively. It follows from the analysis in [7, p. 4189] (details omitted) that there exist polynomials\nCombining (7)\u2013(10) with Theorem 2.1, we conclude that there exist distinct h, k ∈ [0, m⟩ and some integer b in the range −µ h < b < µ k such that\nλ k − λ h ≡ b (mod n) , \t (11) where we have used our assumption that n = O(α). Without loss of generality we can assume further that 0 ≤ b (< µ k ), or else simply switch between the roles of h and k. Also, since C RS is cyclic when n = O(α), we can rotate the e i \u2019s, all by the same number ρ of positions, and the resulting new words will all belong to the same coset of C RS . We should then add, modulo n, the integer ρ to each λ i (and, respectively, to each index in each set J i in (6)), to obtain the correct index values for the rotated words. Thus, (11) still holds (for the same b) regardless of the value of ρ; in particular, we can select ρ so that (0 ≤) λ h ≤ λ k (< n).\nOn the other hand, since e h and e k are distinct yet belong to the same coset of C RS , the difference e h − e k is a nonzero codeword of C RS and, as such, its Hamming weight is at least ℓ + 2. Hence,\nRemark 2.1: It can be shown (by counterexamples) that Lemma 2.3 would no longer hold if we attempted to generalize it to arbitrary linear codes that attain the bound of Theorem 1.1 for τ = ℓ, not even when the codes are MDS.\nProof of Theorem 2.2: First, D is a decoder that corrects any single ℓ-burst, since it satisﬁes the containment (1) (with equality) for τ = ℓ. Now, since r ≥ ℓ+1, we have C RS (n, r) ⊆ C RS (n, ℓ+1) and, so, for every y ∈ F n ,\nFor y ̸∈ C RS (n, ℓ+1), we get the result from Lemma 2.3, while for y ∈ C RS (n, ℓ+1) \\ C RS (n, r), we have\n( y − C RS (n, r)) ⊆ C RS (n, ℓ+1) ) \\ {0}, which, in turn, implies that the set D(y) is empty.\nIn this section, we show that when ℓ divides τ , a (τ /ℓ)- level interleaving of C RS (n, ℓ+1) yields a code C that has an (ℓ, τ )-burst list decoder. Speciﬁcally, the code C is deﬁned by\n6 ?\nCodeword of C RS (n, ℓ+1) \nnamely, it consists of all n × (τ/ℓ) arrays over F whose columns are codewords c j of C RS = C RS (n, ℓ+1). When transmitted over a noisy channel, the array is sent row by row, in which case a τ -burst error is seen as ℓ-burst errors in the columns of the array, as shown in Figure 1. The shaded area in the ﬁgure represents a largest possible set of entries that can be affected by a single τ -burst: generally, entries in that area (including leading or trailing entries) can still be error-free, in which case some columns in the array may incur bursts of length less than ℓ. While this observation is straightforward, it is those lightly corrupted\u2014yet still corrupted\u2014columns that could potentially fail the decoding of the array by requiring the list size to be greater than ℓ. Indeed, this could happen if C RS were replaced by an arbitrary constituent code C, even when C is (ℓ, ℓ)-burst list decodable and d(C) ≥ ℓ + 2 (see Example 4.1 below). However, as we show, Theorem 2.2 will guarantee decoding success for C when C = C RS .\nTheorem 3.1: Given positive integers ℓ ≤ τ < n < q such that ℓ | τ, let C be the (τ/ℓ)-level interleaving of C RS = C RS (n, ℓ+1). Then C has an (ℓ, τ)-burst list decoder. In particular, C attains the bound of Theorem 1.1 when 2ℓ ≤ n.\nWe will prove Theorem 3.1 by introducing an (ℓ, τ )-burst list decoding algorithm for C. The algorithm is presented in Figure 2, and the remaining part of this section is devoted to analyzing that algorithm.\nThe input to the algorithm is an n × (τ/ℓ) array Y over F , which is assumed to be a copy of a code array of C, possibly corrupted by a τ -burst error. The algorithm consists of three main loops: (A), (B), and (C). Loop (A) iterates over the columns of Y , as long as the columns are codewords of C RS . If Y is found to be error-free, then loops (B) and (C) are skipped, and the algorithm returns a list of size 1, containing the all-zero n × (τ/ℓ) array.\nWhen Y is ﬂagged with errors, Loop (B) is entered with the index j pointing at the ﬁrst column, y j , in Y that is corrupted. The (ℓ, ℓ)-burst list decoder D of Theorem 2.2 is applied to that column, resulting in the list\nfollowing collection of up to ℓ + 1 − τ i integer intervals V i,b is added to the interval set S that is computed in Loop (B):\nLemma 3.2: Suppose that E is an n × (τ/ℓ) array over F that forms a τ -burst when unfolded (as in Figure 1). Assume in addition that E is in the coset Y − C and that column j in E equals one of the words in D(y j ). Then the nonzero entries in E are all conﬁned to rows that are indexed by one of the intervals V ∈ S.\nProof: Suppose that column j in E equals e i ∈ D(y j ). We show that the nonzero entries in E are conﬁned to rows that are indexed by one of the intervals V i,b ∈ S i in (14).\nThe projection of the τ -burst to column j forms an ℓ-burst that is indexed by an interval [b \u2032 , b \u2032 +ℓ ⟩, where\nbeyond the array boundaries). Yet, we need to take into account that row b \u2032 − 1 might also be part of the τ-burst at columns k > j, due to the \u201cstep\u201d shown in Figure 1 (which may occur if the τ -burst does not start right at the beginning of a row). Letting b = b \u2032 − 1, the result follows.\nProof: Using the notation (14), we have |S| ≤ m −1 ∑\nTurning to Loop (C), this loop iterates over the remaining columns in the array, and to each column, an erasure decoder y → D J (y) for C RS is applied: given any subset J ⊆ [0, n⟩ and word y ∈ F n , the set D J (y) consists of all words in the coset y −C RS whose support is contained in J . The subsets J are taken as the intervals V ∈ S, and Lemma 3.2 guarantees that the arrays E V that are formed in Loop (C) range over all the τ -bursts in the coset Y −C. Furthermore, since |V | ≤ ℓ+1 for every V ∈ S, we get from the distance properties of C RS that |D V (y k ) | ≤ 1 for every k and V ; i.e., there is at most one possible column e ∈ D V (y k ) that can be appended to each E V while still forming (the ﬁrst k + 1 columns of) a τ -burst. Hence, by Lemma 3.3, the output list, {E V : V ∈ S}, has size at most ℓ. This completes the proof that the algorithm in Figure 1 is an (ℓ, τ )-burst list decoder for C; namely, C satisﬁes condition 3 in Theorem 1.1.\nIt is easy to see that C also satisﬁes condition 2; in fact, Loop (A) can serve as a single (τ + (τ /ℓ))-burst error detector for C, where an early \u201cbreak\u201d from the loop means that at least one of the columns in Y has been subject to an (ℓ+1)-burst error. Our requirement that 2ℓ ≤ n implies that C satisﬁes condition 1 in Theorem 1.1, and a simple calculation shows that the redundancy of C is τ + (τ/ℓ), thereby attaining the bound of that theorem. This completes the proof of Theorem 3.1.\nRemark 3.1: The two \u201cif\u201ds in Loop (C) guarantee that the returned list in Figure 2 contains only τ -bursts. Speciﬁcally, the outer \u201cif\u201d will disqualify an interval V if the (unique) burst error that is returned by the erasure decoder (at any column) for that V has length ℓ + 1. And the inner \u201cif\u201d guarantees that once we incur the \u201cstep\u201d in Figure 1, there will be no \u201cstep back\u201d in subsequent columns.\nWe start by computing the complexity of the decoding algorithm in Figure 2.\nLoop (A) can be carried out by computing the syndrome, with respect to the parity-check matrix H RS = H RS (n, ℓ+1) in (2), of each column in the array Y (these syndromes will be used also for columns j through τ /ℓ −1 in Loops (B) and (C)). This computation requires less than 2(τ /ℓ) · (ℓ+1)n = O(τn) arithmetic operations in F .\nLoop (B) applies an (ℓ, ℓ)-burst list decoder for C RS (n, ℓ+1) to column j in Y . Such a decoder, in turn, can be implemented by applying iteratively an erasure decoder D J ( ·) to that column, where J ranges over the intervals\nGiven y j ∈ F n , let S(x) be the syndrome polynomial in F ℓ+1 [x] that is associated with y j , namely, the coefﬁcients of S(x) are given by the syndrome H RS y j . Also, for b ∈ [0, n −ℓ⟩, let Λ b (x) be the erasure-locator polynomial\nIt follows from the known properties of RS decoding (see, for example, [1]) that D [b,b+ℓ ⟩ (y j ) ̸= ∅ if and only if the coefﬁcient of x ℓ in the erasure evaluator polynomial,\nis zero (where MOD denotes remaindering). And when that happens, the erasure values can be found by Forney\u2019s algo- rithm, namely, by evaluating the ratio −Γ b (x)/(xΛ \u2032 b (x)) at x = α −b , α −b−1 , . . . , α −b−ℓ+1 . The polynomials Γ b (x), in turn, satisfy the relationship\nas such, they can be all computed using O(ℓn) arithmetic operations in F . Recalling that |(y j − C RS ) ∩ B(n, ℓ)| ≤ ℓ, we will need to apply Forney\u2019s algorithm at most ℓ times; therefore, the overall time complexity of Loop (B) is O(ℓn + ℓ 3 ) operations in F .\nLoop (C) amounts to applying the RS erasure decoder D V ( ·) at most |S| times to each of the remaining columns of Y . This, in turn, can be carried out using O\noperations in F . Hence, the overall time complexity of the algorithm in Figure 2 is O(τ n + τ ℓ 2 ) = O\noperations in F , where N = (τ /ℓ)n stands for the effective length of C as a linear code over F .\nOur strategy for implementing an (ℓ, ℓ)-burst list decoder for C RS (n, ℓ+1) (in the analysis of Loop (B)) can be applied more generally to obtain an (ℓ, τ )-burst list decoder for C RS (N, τ + (τ /ℓ)). The resulting time complexity will then be O\nthan the decoding complexity of an interleaved RS code of the same length.\nWe conclude with the next example, where we present a code C with d(C) = ℓ + 2 that has an (ℓ, ℓ)-burst list decoder, yet the (τ /ℓ)-level interleaving of C is (ℓ \u2032 , τ )-burst list decodable only for ℓ \u2032 that grows quadratically with ℓ.\nExample 4.1: Let ℓ ≤ 2q be a positive even integer, let τ ≥ ℓ 2 /2 be a positive integer multiple of ℓ, and let n be an integer greater than (ℓ+2) 2 /2. For each i ∈ [0, ℓ⟩ and j ∈ [0, ℓ/2⟩, set e i,j to be a word in F n with support [i(ℓ/2+1) + j, (i+1)(ℓ/2+1) + j ⟩ (of size ℓ/2 + 1). Also, let a 0 , a 1 , . . . , a ℓ/2 −1 be ℓ/2 distinct elements of F . Denoting by\na j the word in F n whose entries are all equal to a j , deﬁne the following ℓ/2 subsets of F n (each of size ℓ):\nThe code C is deﬁned as the union ∪ ℓ/2 −1 j=0 C j . It can be readily veriﬁed that d( C) = ℓ + 2: the distance between any two distinct words within each subset C j is ℓ+2, while the distance between any two words from distinct subsets is at least n − (ℓ + 2) > 2ℓ ≥ ℓ + 2. In addition, C has an (ℓ, ℓ)-burst list decoder: indeed, if the intersection (y −C)∩B(n, ℓ) contained more than ℓ words, then at least two of them, say y − c j and y −c k , had to correspond to codewords c j and c k that belong to distinct subsets C j and C k . However, this is impossible, since c j and c k , and hence y − c j and y − c k , differ on more than 2ℓ positions and, therefore, cannot be both in B(n, ℓ).\nLet C be the code over F obtained by a (τ/ℓ)-level interleaving of C, and consider the following n × (τ/ℓ) array over F :\n(for the remaining columns we get D(0) = {0}). Next, for every (i, k) ∈ {(0, ℓ/2−1)} ∪\nClearly, E i,k ∈ Y −C. In addition, it can be veriﬁed that each E i,k is a τ -burst. Thus, we have shown that the number of τ -bursts in Y − C is at least ℓ(ℓ−1)/2 + 1 (which is greater than ℓ when ℓ ≥ 4).\nThe authors wish to thank Pascal Vontobel for his help- ful comments. This work was supported in part by Grant No. 1280/08 from the Israel Science Foundation."},"refs":[{"authors":[{"name":"E. Blahu"}],"title":{"text":"R"}},{"authors":[{"name":"P. Elias"}],"title":{"text":"Error-correcting codes for list decoding"}},{"authors":[{"name":"V. Guruswami"},{"name":"A. Rudra"}],"title":{"text":"Explicit codes achieving list decoding ca- pacity: error-correcting with optimal redundancy"}},{"authors":[{"name":"V. Guruswami"},{"name":"M. Sudan"}],"title":{"text":"Improved decoding of Reed\u2013Solomon and algebraic\u2013geometry codes"}},{"authors":[{"name":"R. Koetter"},{"name":"A. Vardy"}],"title":{"text":"Algebraic soft-decision decoding of Reed\u2013Solomon codes"}},{"authors":[{"name":"F. Parvaresh"},{"name":"A. Vardy"}],"title":{"text":"Correcting errors beyond the Guruswami\u2013Sudan radius in polynomial time"}},{"authors":[{"name":"M. Roth"},{"name":"O. Vontobel"}],"title":{"text":"List decoding of burst errors"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569560427.pdf"},"links":[],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S1.T5.1","endtime":"10:10","authors":"Tom Kolan, Ron M. Roth","date":"1341222600000","papertitle":"Burst list decoding of interleaved Reed-Solomon codes","starttime":"09:50","session":"S1.T5: List Decoding and Reed-Solomon Codes","room":"Kresge Little Theatre (035)","paperid":"1569560427"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
