{"id":"1569565535","paper":{"title":{"text":"Network Coding Aware Resource Allocation to Improve Throughput"},"authors":[{"name":"Dan Zhang"},{"name":"Kai Su"},{"name":"Narayan B. Mandayam"}],"abstr":{"text":"Abstract\u2014In the past decade, remarkable progress has been made in the area of network coding in terms of theory, code design, and applications. However, from a cross-layer perspective, the understanding of resource allocation for random network coding (RNC) and its impact on network throughput has been limited. In this article we address the problem of resource allocation for RNC in a general wireless network, using the recent framework that models the dynamics of RNC using a system of differential equations. Based on this framework, we design a gradient algorithm that can be used to improve a variety of throughput objectives.\nIndex Terms\u2014Random network coding, resource allocation, differential equation, dynamical system, power control"},"body":{"text":"Resource allocation for random network coding (RNC) aims to ﬁnd an optimal allocation of communication resource, such as power, bandwidth, time slots and codes, in support of RNC based transport of information. The methodologies used in the previous studies (e.g., [1], [2]) have a commonality that, in one way or another the problem of coding at the network level is reduced to the traditional commodity-ﬂow [3] problem. For example, in a network where nodes perform RNC, imposing a routing strategy may compromise valuable beneﬁts of RNC because fundamentally RNC is different from routing in exploiting various diversities the network offers. Speciﬁcally, a routing strategy ﬁxes a set of routes over which information is transported and this inevitably incurs loss on the so called multicast advantage [1] of wireless. There are a good number of other resource allocation methods tailored for particular topologies or particular applications [4], [5]. These approaches lack generality and most of them only superﬁcially make use of the advantages that RNC provides. In our earlier work [6], a dynamical system model for RNC has been proposed to completely characterize the average behavior of rank evolution \u2013 a crucial concept of RNC \u2013 that contains all information of interest regarding RNC, such as throughput and decoding delay. While this makes plausible an optimal control theoretic strategy, a simpler resource allocation based on gradient methods also works well, as will be discussed in this article. In general, due to the memory of a dynamical system, gradient methods are often not available. The case of RNC comes off as an exception because of two remarkable properties that have been revealed in previous works [6]\u2013[8]. Speciﬁcally, we know with ﬁxed MAC and PHY layer, i.e., ﬁxed resource allocation, the rank of any node (or set)\n2) linearly depends on the link rates, until it reaches full rank.\nThe implications are, because of property 1, ﬁxed allocation corresponds to a ﬁxed throughput, thus memory of the system becomes irrelevant. Because of property 2, the system scales in time (doubling the rates doubles the throughput), thus we can put systems of different rates in a common time frame through proper scaling. These implications are so useful that, for the above mentioned dynamical system, they enable the effective use of the gradient method to construct a state feedback to continuously steer the network towards a better allocation of resource.\nIn what follows we ﬁrst brieﬂy recap the dynamical system view of RNC that has been elaborated in [6]. The resource allocation problem is then cast in this framework and a gradient based resource allocation is proposed. We analyze its optimality, convergence and discuss its practical design consid- erations. In the end we illustrate the use of the methodology by designing an optimal power control algorithm for the wireless network where nodes perform RNC.\nConsider a wireless network modeled as a hypergraph [6] G = ( N , E) where N is the set of transceiver nodes and E are a collection of hyperarcs in the form of (i, K) pairs where i ∈ N and K ⊂ N . The broadcasting phenomenon from node i to an arbitrary set of nodes K is thus modeled with the hyperarc K. We assume every node in the network performs RNC on the ﬁnite ﬁeld GF(q) where q is the size of the underlying ﬁnite ﬁeld. Whenever a node gets to transmit, it transmits a coded packet that is a random linear combination of all the packets available to it, including the packets it originates and the coded packets it has received. Because RNC takes packets as the atomic object to process, it represents a transport strategy that is decoupled from the underlying MAC or PHY technologies, whose operations are considered independent of RNC. Take an arbitrary node i for example, typically the MAC layer of node i determines the transmission (broadcast) rate measured in packets per second. The PHY layer of node i determines the error probability that a transmitted packet can be correctly decoded at any receiver node j. In fact, according\nto [6], the respective effect of MAC and PHY in a wireless network can be shown through two variables:\n\u2022 P i,K : the probability that a packet sent from node i can be correctly decoded by at least one node in K.\nIt is possible to summarize the overall effect of MAC and PHY by deﬁning z i,K = λ i P i,K , which can be conceived as the capacity of the hyperarc (i, K). Given i ∈ K c , we further deﬁne the min cut capacity for (i, K) as\nAs decodability of RNC entirely depends on the number of linearly independent coding vectors, i.e., the rank, and as there is no explicit routing, it is important to keep track of the rank at any node. We use V i to denote the rank at any node i. It turns out to be useful that we also deﬁne the rank at any set K, denoted by V K , as the number of linearly independent coding vectors that the nodes in K collectively possess. Apparently V i and V K are random processes. Suppose the number of source packets is m. Since every coded packet is a random linear combination of m source packets, i can start decoding as soon as V i = m. In [6] the authors discussed a concentration phenomenon of RNC, that when m is sufﬁciently large, V i and V K behave in a very predictable way, much like deterministic functions of time. Such a concentration phenomenon has also been observed and discussed even earlier in [8]. Its implication triggers the conjecture that V i and V K may be modeled as a system of differential equations. This is indeed true and, when MAC and PHY are ﬁxed such that z i,K are known parameters, these equations are explicitly written down in [6] as\nIf we stack V K into a column vector V and stack all z i,K in z, we may write (2) in a more compact form\nwhere f is the stacking of the right-hand sides of (2). Note the instantaneous throughput of set K is given by ˙V K . Suppose node 1 is the only source node. When m → ∞, [6] showed that\ni.e., the instantaneous throughput is almost a constant if m is sufﬁciently large. The fact that when z is ﬁxed and m is large,\nJ V f(V, z) = 0, (for large m) \t (5) where J V f(V, z) is the Jacobian of f(V, z). Another useful observation from (2) is that ˙ V K only linearly depends on z i,K . Mathematically, this implies\n(J z f)(V, z) = (J z f)(V). \t (6) While (6) is precise, (5) is a good approximation with large m. Equations (5) and (6) constitute the basis for the resource allocation strategy to be discussed.\nSince RNC is decoupled from MAC and PHY layers, it is particularly easy to discuss resource allocation and its effect on RNC at an abstract level. When there is a single resource to be allocated to N nodes, the allocation scheme is represented by a N -dimensional column vector r, whose i-th component represents the allocation to node i. Consequently, the effect of resource allocation is captured in the mapping\nor more concisely, z i,K = z i,K (r). In vector form, we may write z = z(r).\nAn allocation scheme is invariably a deliberate design to achieve a certain objective. In this article, we assume the objective is a function of throughputs, which can be solved with the system of differential equations in (2). Speciﬁcally, we assume the objective to be maximized can be written as T ( ˙ V) where T can be any continuous function in the ﬁrst quadrant with partial derivatives deﬁned almost everywhere. As a result, we wish to solve\nmaximize T ( ˙ V) \t (8) subject to ˙ V = f(V, z) \t (9)\nEquation (8) takes a distinct form from previous resource allocation problems for RNC. Rather than treating RNC as a static transport strategy, (8) looks at it from the dynamical system point of view, which means the allocation may also be dynamic and changes over time. Moreover, it can take the form of state feedback\nwhere g is some function of V. The second distinction is that (8) is the ﬁrst formulation that takes full multicast advantage of a wireless network, while previous formulations inevitably break down the wireless transmission into independent links to approximately convert the wireless network to a wired network. Doing so, they lose a portion of the multicast advantage.\nWhile a problem of the form of (8) falls in the traditional category of optimal control and is usually solved using calcu- lus of variations, there are a few reasons that this approach may not be appropriate. First, calculus of variations is as computationally intensive as expensive, which can be practi- cally prohibitive in wireless networks. Second, the wireless communication environment can be dynamic (e.g., due to fading or mobility), and may require certain adaptivity in the devices. Fortunately, when we restrict our objective T to be a function of throughputs, the special problem structure of RNC can be utilized to derive a simple gradient based control which is adaptive.\nConsider the objective function T ( ˙ V) which can be any function that has a gradient almost anywhere in the ﬁrst quad- rant. Our choice of feedback (see (11)) is g = ∇ r T ( ˙ V). Note without (13), it is not clear how to compute ∇ r T ( ˙ V) because\n˙ V is apparently affected by a number of factors including topology, transmission rates and the coding operation. By applying (2), the effect of the resource vector r is abstracted in (10), the topology information encoded in the partially ordered index K ⊂ N and the dynamism represented as the differential operator. The system of equations in (2) thus allow us to ﬁnd an expression for the feedback as 1\nwhere ∇ ˙ V T is the gradient of T ( ˙ V), J z f the Jacobian of f(V, z) with respect to z, J r (z) the Jacobian of z(r). Note we have introduced a > 0 as a feedback gain parameter. Combin- ing (9) and (12) we have a closed-loop system that describes the rank evolution with a dynamic resource allocation strategy\n˙ r = aJ r zJ z f∇ ˙ V T. \t (13) Strictly speaking, the feedback in (12) is not a gradient of the objective function T . It is nevertheless capable of continuously computing the instantaneous resource vector r in the direction that T improves.\nIn this section we will show that choosing the particular feedback in the form of (12) most effectively improves the objective function T . As we will see, the system of differential equations in (2) not only facilitates design, but also analysis. The main theorem is the following\nTheorem 1: By introducing the feedback (12) in (13), ˙ T ≥ 0. Among all possible feedback ˙r = g such that g = aJ r zJ z f∇ ˙ V T , ˙ T is maximized by (12).\nProof: ˙ T ≥ 0 can be seen from the following computation ˙ T = ( ∇ ˙ V T ) ¨ V = (∇ ˙ V T ) ˙f (V; z)\n= ( ∇ ˙ V T ) J z fJ r z˙r (due to (5)) = ( ∇ ˙ V T ) aJ z fJ r zJ r zJ z f∇ ˙ V T = a( ∇ ˙ V T ) J z fJ r zJ r zJ z f∇ ˙ V T = a ( ∇ ˙ V T ) J z fJ r z 2 ≥ 0.\nGiven any g such that g = aJ r zJ z f ∇ ˙ V T , repeating the computation as shown in (14), we get\nNote (16) achieves equality when the feedback is chosen as shown in (12).\nNote Theorem 1 is true regardless whether T is concave or whether T is monotonic. It is also true regardless whether z = z(r) is concave or monotonic. Therefore it can be applied to a wide range of problems. Theorem 1 is also true when T is non- differentiable on a null set since what really matters is ˙ T dt. As a result, when we have multiple interested destinations d 1 , d 2 , . . . ∈ D, an objective of the form\ncan still be maximized with the chosen feedback. With Theo- rem 1, we immediately have\nCorollary 1: If r is contained in a bounded set (i.e., ﬁnite resource allocation), z(r) is continuous and T is continuous, with the feedback in (12), T converges.\nProof: We have ˙ V K =\nBecause r is bounded, it is contained in a compact set. Therefore z is contained in a compact set and from (18) ˙ V is contained in a compact set. Since T is continuous on this compact set, T is also bounded. This implies that, if T is monotonically increasing, it must converge.\nFrom (14) we see that ˙ T (the rate of convergence) can be calculated if an expression is known for J r (z). In the absence of the exact knowledge of J r (z), we also see the feedback gain a can be used to speed up convergence. However, the tradeoff is, with a too large we are at the risk of changing z too fast thus invalidating (5). It remains to be answered how different the solution and optimality will be if we vary a without invalidating (5). The next theorem shows that the solutions for V and r are basically the same except for a proper scaling and the optimality is insensitive for a range of a. This is generally not true when dealing with other dynamical systems where different feedback gains lead to very different trajectories. Before we proceed to the theorem, it would be convenient to deﬁne f a to be the same as f , except that the ﬁeld size q is replaced by q a .\nTheorem 2: Let V a , r a , z a satisfy (13) with an arbitrary a > 0. Let V(t) = aV a (t/a), r(t) = r a (t/a) and z(t) = z a (t/a). Then V, r and z satisfy\nare an arbitrary component of z, r, V, respectively. Likewise, assume z a , r a , V a are an arbitrary component of z a , r a , V a , respectively. Then we have\n∂r a (t/a), \t (22) ∂f\n∂z a (t/a), (by (6)) (23) ∂T ( ˙ V)\nV a (t/a + Δt/a)) − T ( ˙V a (t/a)) ˙ V a (t/a + Δt/a) − ˙V a (t/a)\na . \t (24) From (22) \u2013 (24) and\n˙ r a (t) = aJ r a z a J z a f∇ ˙ V a T (V a ), \t (25) we know\nIn [6], a concentration result has been obtained regardless of q as long as q is sufﬁciently large. In practice, the effect of ﬁnite q on the concentration speed is minimal if q ≥ 2, because in this case q −x → 0 quickly as x > 0 increases. Rank evolution is therefore insensitive to a wide range of q, with which it concentrates to the same solution. As a result, as long as q a\n1 and q 1/a 1, different a\u2019s in (13) yield the same system trajectory given by\n˙ r = J r zJ z f∇ ˙ V T ( ˙ V), \t (27) after proper scaling as described in Theorem 2. Hence we have\nCorollary 2: If a is chosen such that f ≈ f a ≈ f 1/a , T converges to the same value.\nProof: This is true because after scaling V, z, r satisfy (27). But ˙ V(t) = ˙ V a (t/a), so\nWhen choosing a, we want it to be large for fast conver- gence, but not so large that q 1/a ≈ 1 in (20). On the other hand, we want to avoid making a so small that q a ≈ 1 in (23). Both extremes would undermine the concentration assumption. In general, concentration is essential for RNC to achieve the throughput, and it is also the key assumption for what we have discussed so far to remain valid. To do this, given the real ﬁeld size q used, we may set a threshold q th < q below which the concern for concentration will arise. Then pick a such that\nq a , q 1/a ≥ q th , \t (29) i.e., from the interval [log q th / log q, log q/ log q th ].\nIf we wish to know how badly the algorithm would perform with a so large that (5) becomes invalid (but the concentration\nassumption still holds), Theorem 3 indicates that (13) may still work.\nTheorem 3: Assume a is so large that (5) is not valid. If T is continuously differentiable in the ﬁrst quadrant and r is constrained in a bounded set, ˙ T ≥ 0 until\nJ r zJ z f a ∇ ˙ V T ( ˙ V) < c/a for some constant c independent of a.\nProof: Since we do not have (5) any more, we must write ˙ T = ( ∇ ˙ V T ) ¨ V\nFrom (18) we already know ˙ V is contained in a compact set. ∇ ˙ V T is thus bounded as T is continuously differentiable. Moreover, we can bound J V f . To see this, note for arbitrary row K of J V f, all entries are zero except for column K and column K ∪ {i} (i ∈ K c ), whose entries are\n(31) ∂ ˙ V K\nTherefore, J V f is also bounded. Hence there exists a constant c independent of a, such that\nNote when ˙ T < 0, it must be true that a ( ∇ ˙ V T ) J z fJ r z 2 < c, which can be regarded as the ﬁrst order stopping criteria. Although Theorem 3 makes the choice of a even more liberal, it is nevertheless advisable to choose a reasonably small, otherwise additional nonlinearities may start to enter the picture. This is especially true when we move from the continuous system (13) to a discretized system that adjusts resource allocation only at time instants it is triggered.\nIn this section, we use the network coding aware power control as an example to demonstrate the performance of the gradient based algorithm as shown in (13). Consider the 6- node network shown in Fig. IV where nodes perform RNC on GF(2) as described in Section II. Node 1 attempts to multicast to nodes in D = {2, 3, 4, 5, 6} and we wish to maximize the worst-case throughput in the network, i.e., maximize the minimum throughput given in (17). We assume the MAC has been ﬁxed so that node i (i = 1, . . . , 6) transmits at λ i = 1 packet per millisecond. However, the transmit power of each node can be ﬂexibly adjusted from 0 to 15dBm. The initial transmit powers are set uniformly to 13dBm. Let P Tx i denote the transmit powers at node i, h ji denote the link gains from node i to node j, σ 2 = −101dBm denote the thermal noise power at every receiver. We also associate with each node i\na processing gain g i = 8. Consequently, we can model the signal-to-interference-noise ratio (SINR) at node j when j attempts to decode the transmission from i as\nFor the link gains, we use the ITU indoor attenuation model [9] based on distance. The path loss PL over distance d is given by\nwhere f c is the center frequency, n the path loss exponent and P f (n) the ﬂoor penetration factor. Consequently the link gain is given by h = 10 PL /10 . In the simulation, we choose f c = 2.4GHz, n = 3, P f (n) = 11. We use uncoded BPSK modulation with a codeword/packet length of L = 160 bits. Assuming a Gaussian distribution for the interference, the bit error rate for j decoding i is given by\nThe packet error rate is given by P ji = 1 − (1 − P bit ji ) L . Assuming independent reception, we thus have\nUsing the model speciﬁed by (34) \u2013 (37), we execute (13) to demonstrate our power control algorithm. Fig. 1b \u2013 1c show the throughputs as functions of time with a = 10, and a = 0.1, respectively, in addition to throughputs achieved without power control. With a = 10, the minimum throughput T (the lower envelop of all the curves) increases quickly. But as z changes too fast, (5) becomes invalid and leads to oscillation of the trajectory of T . Lowering a results in a smoother trajectory with slower convergence. However, in both settings, T eventually achieves the the same value of 1 packet per millisecond. Considering the transmit rate of node 1 (the source) is also 1 packet per millisecond, the gradient based resource allocation has achieved the maximum possible objective without giving up any multicast advantage and also showed signiﬁcant improvement over no power control.\nIn this article we presented a new resource allocation algorithm speciﬁcally designed for RNC and throughput based objectives. Using the dynamical system model of RNC, the algorithm evolves by introducing a gradient based state feed- back. We proved that this feedback adaptively computes the allocation that continuously improves the objective. We also discussed convergence of the algorithm as well as design considerations for the feedback gain. We illustrated the use of the resource allocation methodology by designing power control for maximizing minimum throughput in a multicast.\nThis work is supported in part by the NSF under grant no. CCF-1016551."},"refs":[{"authors":[{"name":"T. Ho"},{"name":"H. Viswanathan"}],"title":{"text":"Dynamic algorithms for multicast with intra- session network coding"}},{"authors":[{"name":"D. Zhang"},{"name":"N. Mandayam"}],"title":{"text":"Resource allocation for multicast in an OFDMA network with random network coding"}},{"authors":[{"name":"D. P. Bertseka"}],"title":{"text":"Network Optimization: Continuous and Discrete Models"}},{"authors":[{"name":"T. Tran"},{"name":"D. Nguyen"},{"name":"T. Nguyen"},{"name":"D. Tran"}],"title":{"text":"Joint network coding and power control for cellular radio networks"}},{"authors":[{"name":"T. Tran"},{"name":"D. Nguyen"},{"name":"T. Nguyen"}],"title":{"text":"A case for joint network coding and power control in wireless linear networks"}},{"authors":[{"name":"D. Zhang"},{"name":"N. Mandayam"}],"title":{"text":"Analyzing random network coding with differential equations and differential inclusions"}},{"authors":[{"name":"T. Ho"},{"name":"M. M´edard"},{"name":"R. Koetter"},{"name":"D. Karger"},{"name":"M. Effros"},{"name":"J. Shi"},{"name":"B. Leong"}],"title":{"text":"A random linear network coding approach to multicast"}},{"authors":[{"name":"D. S. Lun"},{"name":"M. Medard"},{"name":"R. Koetter"},{"name":"M. Effros"}],"title":{"text":"On coding for reliable communication over packet networks"}},{"authors":[],"title":{"text":"Propagation data and prediction methods for the planning of indoor radio communication systems and the radio local area networks in the frequency range 900MHz to 100GHz"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569565535.pdf"},"links":[],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S8.T1.3","endtime":"17:40","authors":"Dan Zhang, Kai Su, Narayan Mandayam","date":"1341336000000","papertitle":"Network Coding Aware Resource Allocation to Improve Throughput","starttime":"17:20","session":"S8.T1: Network Coding:  Code Design and Resource Allocation","room":"Kresge Rehearsal B (030)","paperid":"1569565535"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
