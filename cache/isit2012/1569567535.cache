{"id":"1569567535","paper":{"title":{"text":"Efﬁcient code-based one-time signature from automorphism groups with syndrome compatibility"},"authors":[{"name":"Philippe Gaborit"},{"name":"Julien Schrek"}],"abstr":{"text":"Abstract\u2014In this paper we propose a new one-time signature algorithm based on coding theory. The algorithm uses properties of automorphism group of certain codes to dramatically decrease the size of the public key of the scheme. By considering the action of cyclic shifts or the action of the group P SL 2 (p) we obtain public keys of less than 18 kilobits for a signature of 7 kilobits. Overall the scheme we propose is perfectly ﬁtted to be used with Merkle tree and proposes a very good trade-off between size of key and size of signatures compared to other code-based signature schemes, with multi-time signatures of size 28kb."},"body":{"text":"The problem of ﬁnding efﬁcient signature algorithms is a very difﬁcult problem in cryptography. In terms of code- based cryptography no ideal solution is known, in this paper we propose a new approach to solve this problem, our new protocol presents a good trade-off between existing solutions.\nThere exist three different type of methods to obtain a signature scheme with code-based crypto-systems. The ﬁrst method (similar to the RSA signature) consists in being able to decode a random element of the syndrom space. This point of view is developed by Courtois-Finiasz-Sendrier [4] and necessitates to hide very large codes to obtain a reasonable probability of decoding. The second method uses zero-knowledge identiﬁcation algorithms together with the Fiat-Shamir paradigm which permits to transform such an algorithm into a signature algorithm. It generally leads to very long signature. For coding theory the Stern identiﬁcation protocol [12] is the most efﬁcient. The last method (similar to the El Gamal signature scheme) consists in building a special subset of the syndrome space that the signer is able to invert. In coding theory this is done through the Kabatisansky-Krouk- Smeets signature scheme [7], meanwhile this scheme has two important drawbacks, ﬁrst it is only a few-times signature scheme (in the sense that only a few signatures are possible for a given public key), secondly the size of key is rather large: a few hundred thousand bits. Notice that one interest of a one time signature algorithm is that it can be turned into a signature algorithm with a predeﬁned maximum number of possible signatures.\nOur contribution We propose a new way to deal with one- time signature for coding theory. The idea of our scheme starts from the Kabatiansky-Krouk-Smeets (KKS) signature scheme and the remark that the public key of this scheme is too large. The general idea of our scheme is to use combinatorial\nproperties of codes to construct decodable syndromes from one given syndrome. We introduce the key notion of syndrome compatible groups and we use the size of these groups to decrease dramatically the size of the public key of our scheme. Our protocol needs to use special codes with an automorphism group as large as possible. The security of the KKS scheme is not related to a general syndrome decoding problem but rather to a special variation of the syndrome decosing problem. One nice feature of our protocol is that, when no signature is known, the security of our protocol can be related to the case of decoding only one syndrome as in the usual case but for a special type of code. We explain why decoding these codes is very likely to be a hard problem. In the general case when one signature is known the security of our scheme is based on the fact that an attacker always lack sufﬁcently positions of the secret vectors, so that he is not able to recover a secret from the information given by only one signature.\nEventually the one-time signature we propose is a good- trade off between the size of the signature and the size of the key. Our system is a one-time signature with a not too large public key (less than 20kb) which can be turned into multi- time signature of 28kb through classical Merkle tree. Overall the signature we obtain is very good trade-off besides existing signature schemes like CFS or ZK-based signatures ([12]).\nThe paper is organized as follows, in section 2 we recall basic fact about coding theory, in section 3 we sum-up code- based signatures. In Section 4 we give a high level overview of our scheme, then in section 5 and 6 we describe our scheme. We give example of syndrome compatible groups in section 7, at last in section 8 and 9 we study the security of the scheme and give parameters.\nRecall that the automorphism group of a code is the group of permutation which leaves a code invariant.\nThe fundamental hard problem used in code-based cryptog- raphy is the following problem:\nInstance: A binary r × n matrix H, a word s of F r 2 and an integer w > 0.\nQuestion: Is there a word x in F n 2 of weight ≤ w such that xH T = s?\nThe problem SD is NP-complete. In practice, decoding a general linear code has received a lot attention, both in cryptology and in coding theory. All known algorithms have an exponential complexity ([5], [8]).\nThe interest of one-time signatures in itself is not very im- portant since very few applications needs only one signature. The main interest of one-time signatures is the possibility to use them in relation with a Merkle tree (also known as hash trees). Merkle trees permit to obtain a signature which can be used a predeﬁned number of time with a small public key, and a signature composed of the public key of the one-time signature gathered with its signature and some Merkle tree information (see [2] for more details in a coding context).\n1) The KKS scheme: The idea of the protocol [7] consists in building a public linear syndrome matrix for which the Signer is able to decode any syndrome obtained by column combination of this matrix. More precisely consider H a random (N − K) × N matrix and G a k × N with only n non nul random columns. The public syndrome matrix F is F = H.G t . The matrix F corresponds to the syndromes associated to H from the rows of G. The matrix G and the position of the non null columns of G are secret. Since only up to n columns of G are no null, any linear combination of the columns of F is a syndrome associated to a linear combination of rows of G, which on the average has weight n/2. The number of possible syndromes that one can decode this way is hence 2 k (all the possible combinations of the columns of F ). We refer the reader to the recent analysis of [10] on the KKS protocol to see the protocol in more detail.\n2) Security of the KKS scheme: Obviously the previous KKS protocol cannot be repeated many times, since each time a signature is given, some information on the non null columns of G is given. There are two questions related to the security of KKS. The ﬁrst question concerns semantic security, the KKS problem can be seen as a multi-syndrome decoding problem. It is not known whether this problem is hard or not. In [1] Barreto et al. propose a variation on the KKS scheme, for which they claim a semantic security (in Thm 5 of [1]) but the result seems hardly true. The second aspect of security is the practical security of the scheme. Because of the multiple syndromes known (k syndromes with k of order 150), the problem is very different from the usual syndrome decoding. In particular the linearity of the syndromes with the large number (k) of known syndromes permits to Otmani and Tillich to develop specialized attacks, based precisely on this large number of known syndromes. In practice they broke all proposed set of parameters of [1]. It does not mean that the scheme is completely broken, just that stronger parameters have to be considered. Notice that in practice it leads to very large parameters.\nThe protocol uses the idea of the KKS protocol to consider as public key a parity check matrix H and a syndrome matrix F . For the matrix H, one uses as it possible with the KKS scheme a matrix with a compact representation as a quasi- cyclic matrix or a bordered double circulant matrix (we will deﬁne it more precisely in Section 5). The main difference comes from the syndrome matrix F . The core idea of our protocol is to be able to ﬁnd a large set of syndrome (more than 2 150 say), such that this set can be described in a compact way, typically with only 5 or 12 syndromes given rather than 160 in the KKS case.\nThe main idea works as follows: consider A a random k ×k circulant square matrix where the ﬁrst row is chosen randomly and where each row is deduced from the previous one by a cyclic permutation. Consider now a double circulant matrix H = (I|A) for I the k × k identity matrix. Let us deﬁne σ the cyclic shift of one position among k position and let us denote π σ the associated k × k matrix. For x = (x 1 , x 2 ) with x 1 and x 2 in F k 2 , we can do the following observation:\nbut using the fact that A is cyclic (and hence commutes with π σ ) together with the fact that π t σ = π −1 σ one gets:\nIn other words from the syndrome value H.x t it is possible to construct (in this case by cyclic shifts) new syndromes that we are able to decode. The action of π −1 σ being translated into the action of π σ on the two parts x 1 and x 2 of x. Hence if one is given l different public syndromes s i = H.x t i by considering the action of all cyclic shifts on the syndromes and adding the shifted syndromes, one is able to decode k l different syndromes. The idea of the algorithm works as follows: give as public key a certain number of syndromes, now if one considers a random addition of cyclic shifts of these syndromes, it is possible to decode it.\nAt the difference of the KKS scheme the decoded code- words are not restricted to a part of the columns (the main point which permits to add so much vectors in KKS), but can reach all columns.\nThe fact that for our scheme the decoded words associated to syndromes are not restricted to certain columns implies to choose parameters so that it is hard to practically decode the sum of the shifted syndromes.\nMeanwhile if it implies to carefully choose parameters, our scheme has two strong advantages compared to the KKS scheme: ﬁrst the size of the public key is small and second the set of decodable syndromes is not linear, which limits potential attacks on the scheme.\nIn the next sections we will introduce special matrices and codes for which the number of decodable syndromes deduced from one syndrome is not k but rather k 3 .\nIn all the following we denote by G a permutation group acting on k positions, by g an element of G and by H a k × n matrix with n = rk. We denote by π g the k × k matrix representation of the permutation g and we denote by g r the concatenation of the action of g on r blocks of k positions. The permutation g r is hence a permutation on kr positions such that the kr positions are considered as a sequence of r blocks of k columns on which the restriction of g r is g. The kr × kr matrix representation of g r is:\n   \nπ g 0 · · · 0 0 π g · · · 0 .. . .. . .. . .. .\n   \nDeﬁnition 1 (syndrome compatibility): Let G be a permu- tation group on k positions and H = (I|H 1 |H 2 | · · · |H r−1 ) a k × rk parity check matrix of a certain code, we say that the permutation group G is syndrome compatible with H if for any g in G there exists a k × k matrix L g such that for any 1 ≤ i ≤ r − 1 we have H i .π g = L g .H i . The matrix L g is called the compatible matrix of g for H.\nProposition 2: If a permutation group G is syndrome com- patible with H then for any x in F n 2 and any g ∈ G:\nProof: The proposition is straightforward from the pseudo-commutativity induced by the deﬁnition of the syn- drome compatibility.\nRemark 3: In other words the previous proposition gives conditions which permit to translate the action on a syndrome H.x t of a linear transformation L g , associated to a given per- mutation g of G, into the action of a concatenated permutation matrix Π g (obtained from g) directly on x for the syndrome computation.\nAn example of a syndrome compatible group, is the group G of circular permutations ( ie rotations or shifts in other words) of length k. This group is syndrome compatible with a k × 2k matrix H = (I|H 1 ) where H 1 is a random circular matrix. Indeed, since circular permutations commute with cyclic matrices we get L g = π −1 g (the inverse comes from the transposition). We will consider in the following an application to the group P SL 2 (q) in which L g = π −1 g .\nFor running the algorithm we consider publicly known the following: h a hash function, G a syndrome compatible group with a k × rk parity check matrix H, and two integers w and t. We consider a bijection φ : [1..|G|] → G which associates to any number between 1 and order of G (denoted by |G|) an element of G, we also consider an application L : G → GL(k) which associates to any g ∈ G, the compatible matrix L g for H. Moreover l and s are integers. In the algorithm (m i)\ndenotes the concatenation of m and j. The parameters t and t 1 are security parameters.\nProof: The veriﬁcation works since for any i, H.(x i .Π φ(a i ) ) t = L φ(a i ) (H.x t i ) = L φ(a i ) .s i .\nIn the algorithm parameter w permits to be sure that ﬁnding a signature is hard (and so that its weight is not too high), the parameter t permits to be sure that a part of the non nul positions of the secrets x i is always missing in sign. Notice that the actual value of these parameters are average values so that the probability to do many trials is small.\nWe consider a [k, rk] matrix H = (I|H 1 |..|H r−1 ) for H i random circulant matrices of size k. As we saw in previous examples we can take for group G the group of cyclic shifts of size k. The group G has size k. If one denotes by π a the shift of a positions for 1 ≤ a ≤ k one gets:\nThis class of codes are [2(p+1), p+1] codes (for p a prime) which has been introduced in the late 60\u2019s by Karlin and have since been the object of many papers. This class of codes has the property to contain in general very good codes, in term of miminum distance, moreover it has the property of having a rather large automorphism group: the group P SL ( 2, q) of order (p−1)p(p+1) 2 \t acting at the same time on both part of the columns. We recall in the following the main property of\nthis group and refer to [9](p.492) for more details. We now introduce some deﬁnitions. Let p be a prime. We deﬁne the matrix of squares Q p in the following way: the ﬁrst row of Q p has p positions numbered from 0 to p − 1. Now if the position i for 1 ≤ i ≤ p − 1 is a square modulo p one puts a \u20191\u2019, and if the position number is not one leaves a \u20190\u2019 as for the zero position. Then the other p − 1 rows are obtained as successive cyclic shifts of the ﬁrst row.\nWe also consider the matrix of non squares N p which has \u20191\u2019 in non square positions and \u20190\u2019 in square positions (with always \u20190\u2019 in position zero).\nWe now deﬁne B p the associated (p+1)×2(p+1) bordered double circulant matrix as:\n   \n0 0 · · · 0 1 1 · · · 1 1 \t 0\n   \nwith M p = I p +N p if p = 4l+3 and M p = Q p if p = 4l+1 for l an integer.\nWe denote the columns of U p and V p as (e ∞ , e 0 , e 1 , · · · , e p−1 ), and we consider the three following permutations on positions e i :\n1) Shift S(b): for 0 ≤ b ≤ p − 1, e ∞ .S(b) = e ∞ and e i .S(b) = e i+b (where the sum i + b is considered modulo p.\n2) The square transformation T (s 2 ), 0 ≤ s ≤ p − 1 deﬁned as: e ∞ .T (s 2 ) = e ∞ and e i .S(b) = e s 2 .i with the product s 2 .i considered modulo p.\n3) The negative inverse transformation N : e ∞ .N = e 0 , e 0 .N = e ∞ .N and e i .N = e −1/i , where the inverse is taken modulo p.\nIt is well known that these three transformations generate the group P SL 2 (p) of order (p−1)p(p+1) 2 \t (see for instance [9](p.491)).\n1) The permutations S(b) and T (s 2 ) commute with U p and V p .\nwith L the (p + 1) × (p + 1) square matrix depending on p, with rows (L ∞ , L 0 , · · · , L q−1 ) deﬁned as:\n\u2022 if p = 4l − 1: L ∞ = e ∞ , L 0 = e 0 + e ∞ and if i is quadratic residue: L i = e ∞ + e 0 + e −1/i and if j is not quadratic residue: L j = e 0 + e −1/j ,\n\u2022 if p = 4l + 1: L ∞ = e ∞ , L 0 = e 0 and if i is quadratic residue: L i = e 0 +e −1/i and if j is not quadratic residue: L j = e ∞ + e 0 + e −1/j .\nIn the following proposition we consider that N is acting simultaneously on both part of B p .\nProposition 5: The group P SL 2 (p) is syndrome compati- ble with the matrix B p .\nProof: We saw that the group P SL 2 (p) was generated by the three transformations S(b), T (s 2 ) and N , the ﬁrst two commute with U p and V p , the action of N is translated into a multiplication by a linear matrix L deﬁned in the previous proposition. It proves the result. Moreover a description of the group P SL 2 (p) is easily derived from the three transforma- tions.\nNotice that by using a description of the elements of P SL 2 (p) as y → ay+b cy+d with ad − bc = 1 it is easy to describe P SL 2 (p) from the transformations S(b), T (s 2 ) and N (see [9](p.492) for more details).\nA. General security assumptions on the decoding of quasi- cyclic codes and QDC codes\nAssumption 1 The decoding of random quasi-cyclic codes is a difﬁcult problem.\nThe class of quasi-cyclic codes has been widely used in past years since its introduction. Even though this class of codes may seem weaker since there are more structured, in practice no algorithm to solve this problem do signiﬁcantly better than general algorithm. Recently this problem has been studied in [3] and no real gain was observed, moreover the supposed gain of the order of matrix (n) is far from being reached. A recent paper by Sendrier [11], gives an upper bound in the square root of the size of the group order in the case of the \u2019Decoding one out many\u2019 attack, which can be applied in our case.\nAssumption 2 The decoding of Quadratic Double Circulant with parameters [2p + 2, p + 1] for p a prime, is difﬁcult for decoding more than 3log 2 (p) errors.\nIf one puts aside the two extension columns, these codes can be seen as a particular case of quasi-cyclic codes. In fact they are related to quadratic residue codes over GF(4) (see [9](p.490)), as their binary images. Now, quadratic residue codes have been studied for more than 50 years and no better algorithm is known than decoding them as cyclic codes. Now if one considers a random distribution of the zeros of the cyclic code over GF (4) one easily obtains that the average maximum size of a sequence of zeros of the cyclic code is of order 2log 2 (p) since roughly any position has probability 1/2 to be a zero (and since the rate of the code is 1/2). So that eventually we do not know how to decode more than 3log 2 (p) errors in general for these codes. Beyond that number of errors (and probably below this bound) we do not know how to decode these codes in another way than for random codes.\nThere are two main cases to consider, the ﬁrst case is the case when an attacker does not know any signature and only has the public key of the scheme, the second case more difﬁcult to consider is the case when an attacker knows a signature.\n1) A reduction proof for signature forgery when no signa- ture is known: We have the following theorem:\nTheorem 6: Consider a family of codes QC or QDC from which one code C is used in the protocol. Suppose we choose for parameters in the protocol w lower than the Gilbert- Varshamov bound of the code C and t a given value associated to w as in the protocol. Then if an attacker is able to forge a signature only from the knowledge of the public key (the l syndromes) then he is able to decode the code C up to t errors.\nproof Suppose one is given a code C as in the theorem and a given syndrome associated to a codeword x 1 of weight t, then it is possible to take l − 1 other random codewords x 2 , ..., x l with weight t. We then obtain a family of l syndromes as in the protocol. If an attacker is able to forge a signature he is able to construct a sum of permuted x i , since w is below the GV bound of the code we know that there is a unique solution to a given syndrome. All the x i are known except x 1 therefore it is possible to recover x 1 from the signature which is their permuted sum.\nNow since since we assumed than decoding these codes for errors with weight higher than 4log 2 (p) is hard, it is hard to forge a signature when only the public key is known.\n2) Forgery with a known signature: In this case there is no nice reduction as in the previous case meanwhile this is not surprising since a one time signature scheme cannot be repeated without giving too much information.\nIn that case the idea is the following. First since an attacker knows the permutations used we consider in the following that up to l permutations trials, a known signature is of the form x 1 plus a sum of permuted x i . If an attacker knows a signature then he knows a large part of \u20191\u2019 positions of x 1 (say). On the other side there is always a part of the \u20191\u2019 positions of x 1 which always vanish.\nLet us compute precisely this number: consider l − 1 Bernoulli variables each taking the value 1 with probability\n. What is the probability that the sum modulo 2 of these variables is equal to 0 ? It is not hard to prove that this probability is equal to q = 1+(1−2 t n ) l−1 2 \t . Hence starting it means that if all the l x i have weight t then the number of \u20191\u2019 of x 1 in the permuted sum is qt and hence the number of vanishing \u20191\u2019 positions of x 1 in the signature is (1 − q)t.\nNow the attacker has the following information, he wants to recover x 1 knowing that: qt \u20191\u2019 positions of x 1 belong to the support of the obtained signature of weight w and (1 − q)t \u20191\u2019 positions are unknowns. Suppose one starts from a [n, k] code, then the parity check matrix H is a (n − k) × n matrix. Consider now the matrix formed from the w columns of H associated to non nul positions of the signature, these columns form a code C 1 [n − k, w], now if one multiplies the matrix H by a dual matrix of this code C 1 , it permits to make vanish the w columns of 1, and the problem is now to ﬁnd the (1 − q)t missing positions of x 1 in a [n − w, k] code. Notice that an attacker will always be missing a part of \u20191\u2019 of any x i , this part can be computed (as we did) and this permits to obtain\na kind of lower bound on the security of the signature (when only one signature is known).\nThe complexity of the scheme is quadratic in the size of k, the public key and the signature are linear in the size of k. Practical parameters are chosen so that the three levels of security are met: (1) an attacker must not be able to recover the x i from the s i , (2) an attacker must not be able to construct a signature of weight w and (3) the knowledge of one signature must not be enough to build a new signature. In general (1) is easy to fullﬁll when (2) and (3) need a balance between them. In the following we give parameters for a security of 2 80 according to the security deﬁned in the previous section (in particular the attack of [11] can be applied to (1) and (2)). To evaluate the security of the cost of the attack we used recent results by Finiasz and Sendrier ([5]), and the analysis of the previous section.\n\u2022 Quasi-cyclic scheme: G=cyclic shifts of length k. Take k = 6299, r = 3,l = 12, weight of x i = 263, upper weight of signature w=2714, number of common bits : less than t 1 = 263 − 35 = 228. public key=75kb, signature:18900b.\n\u2022 Quadratic double circulant codes: G = P SL 2 (p). Take p = 3499, l = 5, weight t of x i = 338, upper weight w of the signature=1393, number of common bits : less than t 1 = 338 − 56 = 282. Public key:17kb,signature size:7000b, (signature size with Merkle tree: ∼ 28kb.)"},"refs":[{"authors":[{"name":"S. L. M. Barret"},{"name":"A. Simplcio Jr"},{"name":"J. System"}],"title":{"text":"Paulo  Rafael Misoczki, Marcos : One- time signature scheme from syndrome decoding over generic error- correcting codes"}},{"authors":[],"title":{"text":"Pierre-Louis Cayrel, Ayoub Otmani, Damien Vergnaud: On Kabatianskii-Krouk-Smeets Signatures"}},{"authors":[],"title":{"text":"Christophe Chabot, Matthieu Legeay, Using automorphisms group for decoding 12th internaional workshop on Algebraic and Combinatorial Coding Theory (ACCT 2010)"}},{"authors":[{"name":"N. Courtoi"},{"name":"M. Finias"},{"name":"N. Sendrier : How to achieve a Mc-Eliece- based digital signature scheme"}],"title":{"text":"Proceedings of ASIACRYPT\u201901, LNCS vol 2248, pp"}},{"authors":[{"name":"M. Finias"},{"name":"N. Sendrier : Security Bounds for the Design of Code- based Cryptosystems"}],"title":{"text":"Proceedings of ASIACRYPT\u201909"}},{"authors":[{"name":"P. Gabori"},{"name":"J. Comb"}],"title":{"text":"Quadratic Double Circulant Codes over Fields"}},{"authors":[{"name":"G. Kabatianski"},{"name":"E. Krou"},{"name":"B. J. M. Smeet"}],"title":{"text":"A Digital Signature Scheme Based on Random Error-Correcting Codes"}},{"authors":[{"name":"A. Ma"},{"name":"A. Meure"},{"name":"E. Thoma"}],"title":{"text":"Decoding Random Linear Codes in O(2 0"}},{"authors":[{"name":"J. Mc William"},{"name":"A. Sloane : The Theory of Error-correcting Codes"}],"title":{"text":"F"}},{"authors":[],"title":{"text":"Ayoub Otmani, Jean-Pierre Tillich: An Efﬁcient Attack on All Concrete KKS Proposals"}},{"authors":[],"title":{"text":"Nicolas Sendrier: Decoding One Out of Many"}},{"authors":[{"name":"J. Stern : A new identiﬁcation scheme based on syndrome decoding"}],"title":{"text":"Proceedings of CRYPTO\u201993, LNCS vol 773, pp"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569567535.pdf"},"links":[],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S11.T6.2","endtime":"10:30","authors":"Philippe  Gaborit, Julien Schrek","date":"1341483000000","papertitle":"Efficient code-based one-time signature from automorphism groups with syndrome compatibility","starttime":"10:10","session":"S11.T6: Authentication and Signatures","room":"Kresge Rehearsal A (033)","paperid":"1569567535"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
