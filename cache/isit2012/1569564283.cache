{"id":"1569564283","paper":{"title":{"text":"Computing Extensions of Linear Codes using a Greedy Algorithm"},"authors":[{"name":"Markus Grassl"},{"name":"Sunghyu Han"}],"abstr":{"text":"Abstract\u2014This paper deals with the problem of increasing the minimum distance of a linear code by adding one or more columns to the generator matrix. We present a simple greedy algorithm which surprisingly yields many codes improving the previously known lower bounds on the minimum distance. We also discuss variations of the algorithm that succeed when the greedy algorithm is not feasible or fails."},"body":{"text":"In this paper we consider the question when a linear code C = [n, k, d] q over F q of length n, dimension k, and minimum distance d can be extended to a code C = [n + m, k, d + 1] q . It is a well known fact in coding theory that every binary linear code C = [n, k, d] 2 whose minimum weight d is odd can be extended to a code [n + 1, k, d + 1] 2 by adding a single parity check. This can also be expressed in terms of Construction X [16] applied to the code C, its even-weight subcode C 0 of co-dimension one, and the trivial code [1, 1, 1] 2 . While this result does not have an immediate generalization to non-binary alphabets, Hill and Lizak [8], [9] proved the following theorem:\nTheorem 1: Let C be an [n, k, d] q code with gcd(d, q) = 1 and with all weights congruent to 0 or d (modulo q). Then C can be extended to an [n + 1, k, d + 1] q code all of whose weights are congruent to 0 or d + 1 (modulo q).\nIn order to apply this theorem, knowledge about the weight spectrum of the code C is required. A generalization of this theorem due to Simonis [15] can be applied when additional information on the weight distribution of the code C is available [15]. The special cases with gcd(q, d) = 1 and in particular ternary codes have been treated by Maruta [12]\u2013 [14]. These results are of rather theoretical nature and have mainly be used to prove the non-existence of codes with certain parameters. The application to a speciﬁc code might be difﬁcult since one has to compute information on the weight distribution of the code ﬁrst.\nIn [5] we have presented several approaches to the problem to test if a code C = [n, k, d] q which is explicitly given by a generator matrix G can be extended and to compute an extension if it exists. Based on the set of all codewords of minimum weight, we gave the following criterion for the extendability of a linear code:\nTheorem 2: Let C = [n, k, d] q be a linear code over F q with minimum distance d. Furthermore, let G ∈ F k×n q be a gener- ator matrix for C of full rank. By S d = {c ∈ C| wgt c = d} we denote the set of all codewords of minimum weight and by J d = {v ∈ F k q | wgt(vG) = d} we denote the corresponding information vectors.\nThe code C can be extended to a code C = [n + m, k, d + 1] q if and only if there is a matrix X ∈ F k×m q \t such that\nProof: Let G = (G|X) be the matrix that is obtained by appending the matrix X to G. Encoding an information vector v with the matrix G we get\nThe weight of a non-zero codeword c is d if and only if wgt(vG) = d and k i=1 v i X i = 0.\nNote that in order to apply criterion (1), we have to compute information vectors of all codewords of minimum weight. For this task, one can use a slight modiﬁcation of an algorithm for computing the minimum weight of a general linear code [4], [5].\nThe main idea presented in [5] is to transform criterion (1) into a system of polynomial equations over the alphabet of the code and use Gr¨obner basis techniques to ﬁnd solutions. While many new codes have been found, this approach is limited to moderate dimension k and extensions by a few additional columns, i.e., the size of the matrix X should not be too big.\nKohnert [10], [11] has proposed to compute extensions us- ing integer linear programming by reformulating (1) as hitting- set problem. The ground set of the hitting-set problem is the set of all normalized non-zero vectors that can be appended to the generator matrix, so its size grows exponentially in the dimension of the code.\nZwanzger [17] described a heuristic method for the con- struction of linear codes with given [n, k, ≥ d] q . The approach is based on a function estimating the probability that a code of dimension k and block length n < n over F q is extendable\nto a code with the given properties. Again, the complexity of evaluating this function, and therefore the complexity of the search algorithm as well, grows exponentially in the dimension of the code.\nTo overcome this problem, a simple greedy search was proposed in [7]. In the following, we will present a reﬁned version of that algorithm.\nRecall from (1) that we are searching for a matrix X ∈ F k×m q \t with few columns such that\nwhere X i denotes the i-th row of the matrix X and J d = {v ∈ F k q | wgt(vG) = d} is the set of all information vectors corresponding to a minimum weight codeword. Clearly, it is sufﬁcient to consider only normalized vectors in J d , e.g., those where the ﬁrst non-zero component equals one.\nLemma 3: Let M be the matrix with k rows whose ν = |J d |/(q − 1) columns are the normalized information vectors v ∈ J d . Then condition (2) is equivalent to asking that none of the columns of the m × ν matrix\nProof: Note that the columns of the matrix M , and hence the columns of the matrix Y , can be labeled by the normalized vectors v ∈ J d . A column of Y labeled by a ﬁxed vector v vanishes if and only if eq. (2) is violated for v.\nFor our search algorithm, we may consider the matrix M as generator matrix of a linear code C aux = [ν, κ ≤ k] q . Note that the dimension κ of C aux is smaller than k if the minimum weight codewords of the original code C generate a proper subcode.\nLemma 4: With the deﬁnitions as above, a code C = [n, k, d] q can be extended to a code C = [n + 1, k, d + 1] q if and only if the code C aux of length ν contains a codeword of weight ν.\nProof: Every row of the matrix Y = X t M is a codeword of C aux . Hence the weight of every row of Y is bounded from above by the maximal weight of a codeword of C aux . Hence we ﬁnd a suitable matrix Y with a single row\u2014corresponding to a matrix X with a single column\u2014if and only if the maximal weight in C aux equals the length of the code.\nThis observation can be generalized to the situation of an extension by m columns.\nTheorem 5: Let C aux = [ν, κ] q be the linear code gener- ated by the matrix M whose columns are the (normalized) information vectors of the minimum weight codewords of a code C = [n, k, d] q . The code C can be extended to a code C = [n + m, k, d + 1] q if and only if the code C aux contains m codewords γ 1 , . . . , γ m such that the union of the supports of the codewords equals {1, . . . , ν}.\nProof: Let G = (G|X) be the generator matrix of the code C obtained by adding m columns to the generator matrix\nG of the code C. Then by Lemma 3, none of the columns of the matrix Y = X t M vanishes. Hence the rows of the matrix Y are m codewords γ 1 , . . . , γ m such that the union of their support equals {1, . . . , ν}.\nOn the other hand, starting with m codewords γ 1 , . . . , γ m , we combine them as the rows of a matrix Y and solve eq. (3) for the matrix X.\nIn order to search for the codewords γ i ∈ C aux from Theorem 5, we can use a greedy strategy which searches for a codeword γ 1 ∈ C aux of maximal weight. One way to proceed would be to search for another codeword γ 2 ∈ C aux such that the union of the supports of γ 1 and γ 2 is as large as possible. Instead, we consider the code C (1) aux that is obtained by puncturing C aux at the support of the codeword γ 1 since those positions are already covered. Note that this does not only reduce the length of the auxiliary code, but it reduces the dimension at least by one since we are puncturing at all non-zero positions of a codeword. Hence the complexity of ﬁnding a codeword of maximal weight in C (1) aux is reduced by at least a factor of q compared to a strategy that uses only C aux .\nThe implementation of the Greedy strategy in MAGMA [1] is given in Algorithm 1. Before searching for a codeword in C aux of maximal weight, we compute the weight distribution of C aux . While this might double the computation time by enumerating all codewords of twice, this allows us to use rather efﬁcient built-in functions to search for a single word of speciﬁc weight. It also turned out that it is more convenient to set those columns in the matrix M that have already been covered to zero instead of constructing a new matrix in each iteration step.\nThe running time of the greedy algorithm is dominated by the computation of all words of minimum weight of the original code C and the search for a word of maximal weight in the auxiliary code C (i) aux = [ν i , κ i ] q for which we have to enumerate all q κ i codewords. As already mentioned, the dimension κ i of C aux is strictly decreasing in each step.\nPossibly variations of the greedy strategy may consider more than one codeword of C aux in each step, for example all codewords of the µ largest weights. Then one could either perform a breadth-ﬁrst search or use some backtracking. Another option is to randomize the search for a codeword in C aux of maximal weight, i.e., reducing the complexity by only searching for a codeword of large weight which is not guaranteed to be maximal.\nWe tested the greedy algorithm using the best known linear codes (BKLC) from MAGMA [1] and the linear codes from [3] which establish or improve the lower bound on the minimum distance in Brouwer\u2019s tables [2]. Good candidates for codes [n, k, d] q that can be extended to a code [n + m, k, d + 1] q are those for which the minimum distance remains constant for a large interval, i.e., if n − n is big where n is the minimal length of a known code [n , k, d + 1] q .\nIn Tables I\u2013VII at the end of this article, we list the param- eters of the new codes obtained using the greedy algorithm.\nIn the ﬁrst column we give the parameter of the code from [3] (seed code) which was the starting point for the greedy search. In combination with standard constructions like shortening, puncturing, and lengthening the lower bounds of more than 250 codes in [3] have been improved. (Note that [3] has already been updated accordingly.)\nQuite often\u2014including many of the codes from [7]\u2014we found more new codes by repeatedly applying our greedy algorithm. Sometimes the greedy algorithm did not yield an improved code, but only a code with the same pa- rameters as in [3]. Nonetheless, we continued with the greedy algorithm until either the minimum distance of the new code did no longer reach the lower bound in [3], or an improved code was found. In Tables I\u2013VII, this is re- ﬂected by subsequent codes in the same row whose min- imum distances differ by more than one. (Note that we list only codes which improve the minimum distance. Fur- thermore, every step of the greedy algorithm increases the\nminimum distance by one.) Examples start with the seed codes [183, 21, 88] 3 , [112, 18, 60] 4 , [30, 15, 12] 5 , [88, 17, 46] 5 , [76, 13, 46] 7 , [58, 14, 33] 7 , [97, 11, 65] 8 , and [102, 11, 69] 8 .\nThe seed codes [55, 25, 18] 3 , [58, 28, 18] 3 , and [68, 23, 28] 5 were chosen as candidates since previously the shortest codes increasing the minimum distance by one were [65, 25, 19] 3 , [68, 28, 19] 3 , and [73, 23, 29] 5 , respectively. We cannot apply our full greedy algorithm in those cases as the auxiliary code C aux is too big for complete enumeration. Instead, we have randomly searched for codewords in C aux of high weight and found the new codes [63, 25, 19] 3 , [64, 25, 20] 3 , [66, 25, 21] 3 , [67, 28, 19] 3 , [68, 28, 20] 3 , and [72, 23, 29] 5 .\nFinally, puncturing the new code [179, 25, 80] 3 at care- fully chosen positions (see [6]), we obtain the three ternary codes [176, 25, 78] 3 , [173, 25, 76] 3 , and [171, 25, 75] 3 . Then, in turn, applying the greedy algorithm to the code [171, 25, 75] 3 (typeset in boldface in Table IV), we ﬁnd the new codes [172, 25, 76] 3 and [174, 25, 77] 3 .\nS. Han was supported by the Basic Science Research Program through the National Research Foundation of Korea (NRF), which is supported by the Ministry of Education, Science and Technology (2010-0007232). M. Grassl would like to thank the Institut f¨ur Kryptographie und Sicherheit (IKS), Karlsruhe, Germany, as well as Benoˆıt Gr´emaud at CQT for providing additional computational resources. The Centre for Quantum Technologies (CQT) is a Research Centre of Excellence funded by the Ministry of Education and the National Research Foundation of Singapore."},"refs":[{"authors":[{"name":"W. Bosma"},{"name":"J. J. Cannon"},{"name":"C. Playoust"}],"title":{"text":"The Magma Algebra System I: The User Language"}},{"authors":[{"name":"A. E. Brouwer"}],"title":{"text":"Bounds on the Size of Linear Codes"}},{"authors":[{"name":"M. Grassl"}],"title":{"text":"Tables of linear codes"}},{"authors":[],"title":{"text":"Searching for linear codes with large minimum distance"}},{"authors":[],"title":{"text":"Computing Extensions of Linear Codes"}},{"authors":[{"name":"M. Grassl"},{"name":"G. White"}],"title":{"text":"New Good Linear Codes by Special Punctur- ings"}},{"authors":[{"name":"S. Han"}],"title":{"text":"Finding Good Linear Codes Using a Simple Extension Algo- rithm"}},{"authors":[{"name":"R. Hill"},{"name":"P. Lizak"}],"title":{"text":"Extensions of Linear Codes"}},{"authors":[{"name":"R. Hill"}],"title":{"text":"An Extension Theorem for Linear Codes"}},{"authors":[{"name":"A. Kohnert"}],"title":{"text":"Update on the Extension of Good Linear Codes"}},{"authors":[],"title":{"text":"(l, s)-Extension of Linear Codes"}},{"authors":[{"name":"T. Maruta"}],"title":{"text":"Extendability of Linear Codes over GF (q) with Minimum Distance d, gcd(d, q) = 1"}},{"authors":[],"title":{"text":"A New Extension Theorem for Linear Codes"}},{"authors":[],"title":{"text":"Extendability of Ternary Linear Codes"}},{"authors":[{"name":"J. Simonis"}],"title":{"text":"Adding a Parity-Check Bit"}},{"authors":[{"name":"N. J. A. Sloane"},{"name":"S. M. Reddy"},{"name":"C.-L. Chen"}],"title":{"text":"New Binary Codes"}},{"authors":[{"name":"J. Zwanzger"}],"title":{"text":"A heuristic algorithm for the construction of good linear codes"}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569564283.pdf"},"links":[{"id":"1569559967","weight":5},{"id":"1569564805","weight":5},{"id":"1569565775","weight":5},{"id":"1569566871","weight":5},{"id":"1569566739","weight":5},{"id":"1569566369","weight":5},{"id":"1569557083","weight":5},{"id":"1569558401","weight":5},{"id":"1569565571","weight":5},{"id":"1569556361","weight":5},{"id":"1569565165","weight":5},{"id":"1569566615","weight":5}],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S9.T5.2","endtime":"10:30","authors":"Markus Grassl, Sunghyu Han","date":"1341396600000","papertitle":"Computing Extensions of Linear Codes using a Greedy Algorithm","starttime":"10:10","session":"S9.T5: Linear Codes and UEP Codes","room":"Kresge Little Theatre (035)","paperid":"1569564283"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
