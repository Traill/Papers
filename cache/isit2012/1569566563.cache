{"id":"1569566563","paper":{"title":{"text":"Quantum LDPC codes obtained by non-binary constructions"},"authors":[{"name":"Iryna Andriyanova ∗"},{"name":"Denise Maurice \u2020"},{"name":"Jean-Pierre Tillich \u2020"}],"abstr":{"text":"Abstract\u2014We generalize a construction of non-binary quantum LDPC codes over F 2 m due to [KHIK11] and apply it in particular to toric codes. We obtain in this way not only codes with better rates than toric codes but also improve dramatically the performance of standard iterative decoding. Moreover, the new codes obtained in this fashion inherit the distance properties of the underlying toric codes and have therefore a minimum distance which grows as the square root of the length of the code for ﬁxed m."},"body":{"text":"LDPC codes [Gal63] and their variants are one of the most satisfying answers to the problem of devising codes guaranteed by Shannon\u2019s theorem. They display outstanding performance for a large class of error models with a fast decoding algorithm. Generalizing these codes to the quantum setting seems a promising way to devise powerful quantum error correcting codes for protecting, for instance, the very fragile superpositions manipulated in a quantum computer.\nQuantum generalizations of LDPC codes have indeed been proposed in [MMM04]. However, it has turned out that the design of high performance quantum LDPC codes is much more complicated than in the classical setting. This is due to several reasons, the most obvious of which being that the parity-check matrix of quantum LDPC codes must satisfy cer- tain orthogonality constraints. This complicates signiﬁcantly the construction of such codes. In particular, the plain random constructions that work so well in the classical setting are pointless here. There have been a number of attempts at overcoming this difﬁculty and a variety of methods for con- structing quantum LDPC codes have been proposed [Kit03], [MMM04], [COT05], [COT07], [LGF06], [GFL08], [HI07], [IM07], [Djo08], [SMK08], [Aly07], [Aly08], [HBD08],\n[TZ09], [TL10], [KHIK11]. However, with the exception of [TZ09] which gives a construction of LDPC codes with minimum distance of the order of the square root of the block- length, all of these constructions suffer from disappointingly small minimum distances, namely whenever they have non- vanishing rate and parity-check matrices with bounded row- weight, their minimum distance is either proved to be bounded, or unknown and with little hope for unboundedness.\nThe point has been made several times that minimum distance is not everything, because there are complex decoding issues involved, whose behavior depends only in part on the minimum distance, and also because a poor asymptotic be- havior may be acceptable when one limits oneself to practical\nlengths. This is illustrated for instance in our case by the codes constructed in [KHIK11] whose performance under iterative decoding is quite good even if their minimum distance might be bounded. Their construction can be summarized as follows. There are three ingredients:\n(i) The starting point is a CSS quantum code associated to a couple ( C X , C Z ) of binary LDPC codes satisfying C Z ⊥ ⊂ C X (see Section II) obtained from a construction due to [HI07]. These LDPC codes have parity check matrices H X and H Z which are (2, L)-regular, meaning that each column contains exactly 2 \u201c1\u201d\u2019s and each row contains exactly L-ones.\n(ii) From this construction, a pair of q-ary LDPC codes ( C (q) X , C (q) Z ) is deduced which satisﬁes C (q) Z ⊥ ⊂ C (q) X , where q is some power of two, q = 2 m . These codes have parity-check matrices H (q) X and H (q) Z of the same size as H X and H X respectively and which have nonzero entries whenever the corresponding entry of H X (respectively H Z ) is equal to 1, that is\nwhere x (q) i,j,, x i,j,, z (q) i,j , z i,j denote the entry correspond- ing to the i-th row and the j-th column of H (q) X , H X , H (q) Z , H Z respectively.\n(iii) By denoting the length of C X , C Z , C (q) X , C (q) Z by n, and by replacing each entry of H (q) X and H (q) Z in the ﬁnite ﬁeld F q over q elements by a binary matrix of size 2 m × 2 m , through a ring isomorphism A : F 2 m → M 2 m where M 2 m is a certain subring of binary 2 m ×2 m matrices (i.e. a one-to-one mapping preserving ﬁeld addition and multi- plication), a pair of two parity-check matrices ( ˆ H X , ˆ H Z ) is obtained. They deﬁne a pair of binary codes ( ˆ C X , ˆ C Z ) of length n×m satisfying the CSS condition ˆ C Z ⊥ ⊂ ˆ C X .\nThe point of this construction is that the new quantum code associated to the pair ( ˆ C X , ˆ C Z ) can now be decoded on the extension ﬁeld F q and this improves signiﬁcantly the performance in the same way as the performance of classical binary (2, L) regular LDPC codes is improved by moving to a larger extension ﬁeld F 2 m as shown in [Hu02].\nOur purpose in this article is here to generalize the construc- tion of [KHIK11] and to show that it can be applied to any pair of binary codes ( C X , C Z ) satisfying C Z ⊥ ⊂ C X which are LDPC codes which have parity check matrices which have\nexactly 2 \u201c1\u201d\u2019s per column, not only the particular family of quasi-cyclic codes of this type which are constructed in [HI07]. We apply this generalized construction to the toric codes of [Kit03] which are a particular instance of the CSS construction corresponding to a pair of LDPC codes ( C X , C Z ) which are (2, 4)-regular. It presents the advantage of having a minimum distance which grows like the square root of the length but has also the drawback to be able to encode only 2 qubits. We obtain in this way a new code family which displays several attractive features compared to the toric code family:\n(i) it has the same two dimensional structure as toric codes, this might turn out to be very helpful for its implementation. It represents for instance a quite attractive code choice for performing quantum fault-tolerant computation [Kit03].\n(ii) it inherits the distance properties from the underlying toric code and has therefore a minimum distance which grows like the square root of the length,\n(iii) the number of encoded qubits is not constant anymore as for toric codes but grows as 2m where m is the degree of the extension ﬁeld,\n(iv) whereas iterative decoding displays very bad performances when applied to toric codes, plain iterative decoding behaves much better for this new family of codes and when m = 9 we obtain codes for which iterative decoding performs quite well for instance (see Section V).\nApart from the practical relevance of the codes constructed, there is also a theoretical aspect. This shows for instance that it is possible to obtain families of CSS codes with a prescribed degree distribution on the check nodes with an unbounded minimum distance with the construction strategy of [KHIK11]. It is questionable whether or not the codes constructed in [KHIK11] meet this property (one of the drawback of the codes constructed there is that they start with a certain construction of quasi-cyclic CSS codes which can be easily proved to have bounded minimum distance).\nAll the statements made in this paper are given without proofs. They can be found in the full version of the paper in [AMT12]. We also observe that the results given in this paper can be rephrased into the language of homology on graphs on the multiplicative group of the ﬁnite ﬁeld F q ∗ and that homological constructions of quantum codes can be traced back to [Kit03], [BMD07].\na) CSS codes: The codes constructed in this paper fall into the category of Calderbank-Shor-Steane (CSS) codes [CS96], [Ste96] which belong to a more general class of quantum codes called stabilizer codes [Got97], [CRSS98]. The second class is given by an additive self-orthogonal code over F 4 with respect to the trace hermitian product. For the subclass of CSS codes, this representation in terms of additive self- orthogonal codes is equivalent to a representation in terms of a pair ( C X , C Z ) of binary linear codes satisfying the condition C Z ⊥ ⊂ C X . The quantum minimum distance of such a CSS\nd Q def = min{d X , d Z }, where \t (2) d X def = min{|x|, x ∈ C X \\ C Z ⊥ }, d Z def = min{|x|, x ∈ C Z \\ C X ⊥ }.\nSuch a code allows to protect a subspace of k Q qubits against errors where\nb) LDPC codes: LDPC codes are linear codes which have a sparse parity-check matrix. They can be decoded by using the Tanner graph associated to such a parity-check matrix H. This graph is deﬁned as follows. Assume that\nis an r × n matrix (where n is the length of the code). The associated Tanner graph is bipartite and has:\n(i) vertex set V ∪ C, where the ﬁrst set V is in bijection with the indices of the columns of H, say V = {1, . . . , n} and is called the set of variable nodes, whereas the second set C is called the set of check nodes and is in bijection with the indices of the rows of H: C = {⊕ 1 , . . . , ⊕ r }.\n(ii) edge set E; there is an edge between ⊕ i and j if and only if H ij = 0 and the edge receives label H ij in this case.\nA CSS code deﬁned by a couple of binary code ( C X , C Z ) is said to be a quantum LDPC code if and only if C X and C Z are LDPC codes.\nWe show in this section how to derive for any integer m > 1 from a pair of binary LDPC codes ( C X , C Z ) with parity-check matrices H X and H Z satisfying\n(2) all the columns of H X and H Z have exactly 2 \u201c1\u201d\u2019s in it, a pair of 2 m -ary LDPC codes ( C (q) X , C (q) Z ) with parity-check matrices H (q) X and H (q) Z satisfying\n(2) all the columns of H X and H Z have exactly 2 non zero elements in it.\nThis generalizes the construction of [KHIK11] to other codes than the ones obtained from [HI07] by using the ring isomor- phism A from the ﬁnite ﬁeld F 2 m to M 2 m which is described in Subsection II.C of [KHIK11].\nWe show the existence of the couple ( C (q) X , C (q) Z ) by providing an efﬁcient algorithm which outputs a couple of matrices (H (q) X , H (q) Z ) meeting (1) and (2). To explain how the algorithm works let us bring in the following deﬁnition\nDeﬁnition 1: To each row k of H Z we associate a parity- check matrix H X (k) consisting of the submatrix of H X formed by the columns j of H X such that z k,j = 0 and by keeping only the non zero rows in it. Let G X (k) be the Tanner graph associated to this parity-check matrix.\nLemma 1: The degree of every variable node of G X (k) is two, whereas the degree of every check node is an even positive number.\nProof: The fact that the degree of every variable node is exactly two is a direct consequence of the fact that the columns of H X (k) are all of weight 2 since the columns of H X have exactly this property. The second claim can be veriﬁed as follows. Each check node corresponds to a row of H X (k) which corresponds itself to some row of H X . We denote such a row by i. The degree of the check node corresponding to i is nothing but the weight of row i of H X (k). It is equal to the number of j\u2019s such that we both have x i,j = z k,j = 1. Notice that H X H Z T = 0 implies in particular that\nThis implies the aforementioned claim about the degree of the check node, since the aforementioned number of j\u2019s is necessarily even in order to meet (4).\nSince the degrees of all the vertices of G X (k) is even, G X (k) can be decomposed in an edge-disjoint subset of cycles Cyc X (k). Each variable node vertex j belongs to a unique cycle of this kind whereas a check node ⊕ i may belong to several cycles of Cyc X (k). Our strategy to ensure that there is a choice of H (q) X and H (q) Z meeting Condition (1) and H (q) X H (q) Z T = 0 is to look for solutions which satisfy for all rows k of H (q) Z , all cycles C of Cyc X (k), and all check nodes ⊕ i belonging to C\nwhere we denote by E the set of edges of C. Notice that there are exactly two variable nodes which are adjacent to ⊕ i in C. The ﬁrst point is that the sum j x (q) i,j z (q) k,j can be decom- posed as a sum C:C∈Cyc\nwhich implies that ensuring (5) implies (4) and therefore H (q) X H (q) Z T = 0. Moreover the code associated to the cyclic Tanner graph C is non trivial if and only if the product of its labels on its cycle is equal to 1. We deﬁne here for a Tanner graph the product over a cycle by\nLet C = v 1 , c 1 , v 2 , . . . , c k , v 1 be a cycle in the Tanner graph code. Then the product over this cycle is the product of all the coefﬁcients of the edges over this cycle, with a power 1 if it is a check-to-node edge, and −1 if it is node-to-check. We denote this product by Π(C).\nProposition 1: The code associated to Tanner graph which is a unique cycle is not reduced to the zero codeword if and only if the product of the labels over the cycle is equal to 1. In such a case, all the non-zero codewords have only non-zero positions.\nThe algorithm for choosing the entries of H (q) X and H (q) Z is described below as Algorithm 1. The fact that the z (q) k,j \u2019s can be chosen to be different from zero comes from the fact that\nChoose the entries x (q) i,j of H (q) X such that for all rows k of H (q) Z and all cycles of Cyc X (k) the product of the labels x (q) i,j along these cycles is equal to 1.\nChoose non-zero entries z (q) k,j for all variable nodes j of C such that (5) holds for all edges of C.\nend for end for\nthe product of the labels x i,j along C is equal to 1 and from Proposition 1. It just amounts to choose a non-zero codeword in the code whose Tanner graph is given by C and the labels of the edges are given by the x (q) i,j \u2019s. This leads to two matrices H (q) X and H (q) Z which satisfy Condition (1) and H (q) X H (q) Z T = 0. Finally, it remains to explain how we choose the entries x (q) i,j of H (q) X . We will actually provide an algorithm which provides a stronger condition on the x (q) i,j \u2019s, namely that\nThe fact that the product over all cycles of G X will be equal to 1 (and not only the cycles of the subgraphs G X (k)) will be quite useful when applied to the toric code and this stronger condition can be met with Algorithm 2 which gives a very large choice for the coefﬁcients.\nfor all check nodes ⊕ k of the Tanner graph G X associated to H X do\nChoose arbitrarily a non zero element a k and non-zero elements b jk for all variable nodes j adjacent to ⊕ k .\nx (q) k,j ← a k b kj b ij {Here ⊕ i and ⊕ k denote the two check nodes adjacent to j.}\nis easily achieved in the case of column weight 2 essentially by the fact that the number of check nodes of the Tanner graphs G X (k) is always less than or equal to the number of variable nodes (since by Lemma 1 the degree of the check nodes is greater than or equal to 2 and the degree of the variable nodes is constant and equal to 2), this is not the case anymore when the column weight is higher.\nThe quantum toric code (see [Kit03] for more details) is a CSS code of length 2n 2 which encodes 2 qubits. It is conve- nient to deﬁne the Tanner graphs G X and G Z of the couple ( C X , C Z ) of binary codes of the CSS code simultaneously. Let C X and C Z be the set of variable nodes of G X and G Z respectively and we identify the variable node sets V X and V Z of both codes, say V X = V Z = V . These graphs are deﬁned as follows:\nC X = {(i, j) ∈ [0..2n − 1] × [0..2n − 1] : i odd, j even} C Z = {(i, j) ∈ [0..2n − 1] × [0..2n − 1] : i even, j odd}\nA check node (i, j) is connected to 4 variable nodes (i±1, j ± 1) in both graphs (where addition is performed modulo 2n). The degree of the variable nodes is of course 2.\nThe construction, summarized on Fig 1, has the shape of a torus of length and width n.\nEven if this code has as many checks as qubits, its di- mension is positive: the rank of H X and H Z associated to G X and G Z is n 2 − 1 instead of n 2 , thus the dimension is dim( C X )−dim( C Z ⊥ ) = n 2 +1−(n 2 −1) = 2 (from (3)). The code has a rather large minimum distance [Kit03], however its performances when decoded with standard belief propagation are quite bad, because of the presence of many small cycles and also because the (classical) minimum distance of C X and C Z is only 4.\nNow we construct a q-ary version of this code, in the same way as in Section III. In other terms, we just put some non-zero labels on the edges of the graph. For simplicity of notation we will further use x i,j to design x (q) i,j , the label in F q \\ {0} on the edge between check i and node j.\nLabeling is performed through Algorithm 1 by choosing the coefﬁcients a i and b jk at random in Algorithm 2. We obtain a couple ( C (q) X , C (q) Z ) of q-ary codes satisfying\nWe obtain the extended toric code by applying the aforemen- tioned ring isomorphism to the entries of the parity-check matrices H (q) X and H (q) Z of C (q) X and C (q) Z : the resulting code has length 2mn 2 . We denote the couple of binary codes deﬁning this toric code by ( ˆ C X , ˆ C Z ).\nStrictly speaking, by applying Algorithm 1, the dimension of C (q) X minus the dimension of C (q) Z ⊥ could be smaller than dim C X − dim C Z . Indeed H (q) X and H (q) Z might now be of full rank and we might have dim C (q) X = dim C (q) Z ⊥ = n 2 . This would imply that dim ˆ C X = dim ˆ C Z ⊥ and the quantum dimension of the extended toric code would be 0. However, when we apply Algorithm 2 to choose the labels (so that the product of the labels x i,j over all cycles of G X is equal to 1), then it will turn out that dim C (q) X − dim C (q) Z ⊥ = dim C X − dim C Z ⊥ = 2, so that dim ˆ C X − dim ˆ C Z = 2m. This means that\nC (q) X and C (q) Z are constructed such that C (q) X veriﬁes (6) and C (q) Z ⊥ ⊂ C (q) X , then the extended toric code has dimension 2m.\nLemma 3: If C (q) X veriﬁes (6), then it has q-ary dimension n 2 + 1.\nFrom these two lemmas, we obtain that the dimension of C (q) X and C (q) Z is n 2 + 1, which gives dim C (q) X − dim( C (q) Z ⊥ ) = 2. This implies that the quantum dimension of the extended toric code is dim( ˆ C X ) − dim( ˆ C Z ⊥ ) = m(dim C (q) X − dim( C (q) Z ⊥ )) = 2m.\nThe proof of the two lemmas is given in the full version of the paper [AMT12].\nChoosing the product of the labels to be equal to 1 on all cycles of G X brings another beneﬁt: it allows to control the minimum distance, since we have in this case\nThe proof is given in the full version of the paper [AMT12]. This implies that\nTheorem 2 (minimum distance of the extended toric code): The minimum distance of the extended toric code is ≥ n.\nProof: The minimum distance of the extended toric code is the minimal weight of a word from ˆ C X \\ ˆ C Z ⊥ or ˆ C Z \\\nˆ C X ⊥ . which is greater than or equal to the weight of the corresponding (by the ring isomorphism A) word in C (q) X \\\nWe have implemented standard belief propagation over F 2 m to decode extended toric codes for several values of n and m (see Section III of [KHIK11]) but which correspond to the same ﬁnal length 2mn 2 , which is 1152 here. We have chosen (i) m = 1, n = 24,\n(ii) m = 4, n = 12 (iii) m = 9, n = 8.\nThe channel error model is the depolarizing channel model with depolarizing probability p, meaning that the probability of an X, Y or Z error is p/3 which implies that the codes ˆ C X and ˆ C Z see a binary symmetric channel of probability 2p 3 .\nThe performance of belief propagation is quite bad in the binary case (that is for standard toric code), even if the qubit error rate is rather low, the whole error is typically badly estimated. On the other hand the performances get better by moving from F 2 to F 16 and become quite good over F 512 . This is remarkable since the length of these CSS codes is constant but the rate increases with m. For instance, the rate of the toric code is 1 576 whereas the rate of the extended toric code over F 512 is equal to 1 64 . It would be interesting to carry over the renormalizing approach of [DCP10] which improves dramatically belief propagation over standard toric codes and study how much it is able to improve the performance of standard belief propagation over these larger alphabets.\nThis work was supported by the French ANR Deﬁs program under contract ANR-08-EMER-003 (COCQ project)."},"refs":[{"authors":[{"name":"[CRSS98] A. R. Calderbank E. M."},{"name":" Rains P. W."}],"title":{"text":"IEEE Trans."}}]},"file":{"jsonClass":"File","file":"/home/arnfred/Code/trailhead/resources/isit2012/1569566563.pdf"},"links":[],"meta":{"jsonClass":"HashMap$HashTrieMap","sessionid":"S2.T9.3","endtime":"12:30","authors":"Iryna Andriyanova, Denise Maurice, Jean-Pierre Tillich","date":"1341231000000","papertitle":"Quantum LDPC codes obtained by non-binary constructions","starttime":"12:10","session":"S2.T9: Quantum Codes from Classical Codes,","room":"Stratton West Lounge (201)","paperid":"1569566563"},"cluster":{"jsonClass":"Map$EmptyMap$"}}
