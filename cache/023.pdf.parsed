[[[ ID ]]]
23
[[[ INDEX ]]]
0
[[[ TITLE ]]]
An Efﬁcient Algorithm for Finding Dominant Trapping Sets of Irregular LDPC Codes
[[[ AUTHORS ]]]
Mehdi Karimi
Amir H. Banihashemi,
[[[ ABSTR ]]]
Abstract—This paper presents an efﬁcient algorithm for ﬁnd- ing the dominant trapping sets of irregular low-density parity- check (LDPC) codes. The algorithm can be used to estimate the error ﬂoor of irregular LDPC codes or to be part of the apparatus to design irregular LDPC codes with low error ﬂoors. The algorithm is initiated with a set of short cycles, variable nodes with low degree, and cycles with low approximate cycle extrinsic message degree (ACE), as the input. The input structures are then expanded recursively to dominant trapping sets of increasing size. The algorithm is devised based on the careful inspection of the graphical structure of dominant trapping sets and the relationship of such structures to short cycles, low-degree variable nodes and cycles with low ACE. In particular, the important role of degree-2 variable nodes in the structure of dominant trapping sets is discussed. Simulation results on several LDPC codes demonstrate the accuracy and efﬁciency of the proposed algorithm. In particular, the algorithm is signiﬁcantly faster than the existing search algorithms for dominant trapping sets.
[[[ BODY ]]]
For a given LDPC code, the knowledge of dominant trap- ping sets is important. On one hand, efﬁcient methods for estimating the error ﬂoor of an LDPC code, which rely on the importance sampling technique, operate by biasing the noise toward the dominant trapping sets of the code, see, e.g., [3]. On the other hand, by knowing the dominant trapping sets, several decoder modiﬁcations can be applied to improve the error ﬂoor performance (see, e.g., [4]). Furthermore, the knowledge of dominant trapping sets can be used to design LDPC codes with low error ﬂoor [1]. While the knowledge of the problematic sets that dominate the error ﬂoor performance is most helpful in the design and analysis of LDPC codes, attaining such knowledge, regardless of differences in the graphical structure of these sets (e.g., stopping sets, absorbing sets, or elementary trapping sets), is a hard problem, see, e.g., [10].
The complexity of the exhaustive brute force search method for ﬁnding problematic structures of size t in a code of length n is proportional to ( n t ), which becomes quickly infeasible as n and t increase (e.g., for t = 10 and n = 1000, ( 1000 10 ) ≈ 2.6 × 10 23 ). Efﬁcient search algorithms have been devised to ﬁnd small (dominant) stopping and trapping sets, see, e.g., [3], [15], [2], [8]. The reach of these algorithms however is still very limited. For example, the complexity of the algorithm of [15] is only affordable for codes with lengths up to ∼ 500. Even for these lengths, the algorithm can only ﬁnd trapping sets of maximum size 11 with only one or two unsatisﬁed check nodes. This is while for many codes, some of the dominant trapping sets may have larger
size and/or more than two unsatisﬁed check nodes. In another recent work, [14], the authors proposed to build a database of all possible conﬁgurations for trapping sets of different sizes in a graph with speciﬁc degree distribution and girth. They then used a parent-child relationship between the trapping sets of different sizes to simplify the search of the larger trapping sets. This technique however becomes increasingly complex as the degree of variable nodes, the irregularity of the degree distributions and the size of the trapping sets increase. It is therefore important to look for more efﬁcient algorithms to ﬁnd the problematic structures that dominate the error ﬂoor performance of LDPC codes, particularly for irregular codes. This is the subject of the present paper.
In an earlier work [7], we developed an efﬁcient algorithm (Algorithm 1) for ﬁnding the dominant trapping sets of LDPC codes. The algorithm operated by expanding an initial set of trapping sets, which consisted of short cycles, in an iterative fashion. It was demonstrated in [7] that the algorithm was able to ﬁnd the dominant trapping sets of regular LDPC codes efﬁciently and accurately. In this work, we generalize the work of [7] to be also applicable to irregular codes. Although the idea of iterative expansion of smaller trapping sets to obtain larger ones, is still the same for irregular codes, there are also some important differences. One main difference is in the initial input set: For regular codes, this set includes short cycles of the graph; for irregular codes, in addition to short cycles, the set also includes variable nodes of small degree and cycles with low approximate cycle extrinsic message degree (ACE) [13]. Another difference is in the expansion of the additional input sets which is based on a careful study of the structure of dominant trapping sets for irregular codes. Such structures often include degree-2 variable nodes.
The proposed algorithm is applicable to any Tanner graph (structured or random) and can be tailored to ﬁnd a variety of graphical structures, such as elementary trapping sets and absorbing sets among others. Results on several LDPC codes verify the high efﬁciency and accuracy of the algorithm. For example, for a tested code, the search speed is improved by a factor of more than three orders of magnitude compared to the method of [2].
Let G = (L ∪ R , E) be the bipartite graph, or Tanner graph, corresponding to the LDPC code C, where L is the set of variable nodes, R is the set of check nodes and E is the set of edges. We use the notations m and n v 2 to denote the number of check nodes and the number of variable nodes
of degree 2, respectively. For a subset s ⊂ L , Γ(s) denotes the set of neighbors of s in R . The induced subgraph of s, represented by G s , is the graph containing nodes s ∪Γ(s) with edges {(u, v) ∈ E : u ∈ s, v ∈ Γ(s)}. The set of check nodes in Γ(s) with odd degree in G s is denoted by O (s). Similarly, F (s) represents the set of check nodes in Γ(s) with even degree in G s . In this paper, we interchangeably use the terms satisﬁed check nodes and unsatisﬁed check nodes to denote the check nodes in F (s) and O(s), respectively. We call a set s ⊂ L an (a, b) trapping set, if |s| = a and |O(s)| = b. An (a, b) trapping set is called dominant if it has the smallest b for a given a. With a slight abuse of notation, the term “dominant” may sometimes be used to mean trapping sets with a small (not necessarily smallest) value of b. An (a, b) trapping set s is called elementary if all the check nodes in G s have degree one or two. It is well-known that most of the dominant trapping sets are elementary [3]. A set s ⊂ L is an (a, b) absorbing set if s is an (a, b) trapping set and if all the nodes in s are connected to more nodes in F (s) than nodes in O (s). A set s ⊂ L is an (a, b) fully absorbing set if s is an (a, b) absorbing set and if all the nodes in L\s have strictly more neighbors in R \O(s) than in O(s).
For the irregular LDPC codes which do not have variable nodes of degree 2, Algorithm 1 of [7] without any modiﬁca- tion can be used to ﬁnd the dominant trapping sets. (Algorithm 1 is also provided in Appendix A for convenient referral.) In this section, we study the effect of degree-2 variable nodes on the structure of trapping sets in irregular LDPC codes, and present simple steps to ﬁnd the corresponding trapping sets.
It is well-known that irregular LDPC codes optimized for the best threshold usually have a large fraction of degree-2 variable nodes [11]. As a consequence, most of the check nodes in these codes may be connected to several variable nodes of degree 2.
Example 1: For all the degree distributions optimized for rate-1/2 LDPC codes on the binary-input AWGN (BIAWGN) channel [11], %43 to %55 of variable nodes are of degree 2. This implies that, on average, every check node in the corresponding codes is connected to about 2 variable nodes of degree 2.
The average number of degree-2 variable nodes connected to each check node becomes even larger for the optimized codes of higher rate. This is explained in the next example.
Example 2: For the optimized degree distribution of rate 8/9 over the BIAWGN channel with the maximum variable node degree 10 [11], %31 of variable nodes are of degree 2. This implies that, on average, every check node in a code with this degree distribution is connected to about 6 variable nodes of degree 2.
Consequently, it is very likely to see chains of degree-2 variable nodes, referred to as 2-chains, in the Tanner graph of LDPC codes with optimized degree distributions. The length of a 2-chain is deﬁned as the number of the edges in the subgraph induced by the degree-2 variable nodes of the chain.
That is, the length of a 2-chain containing k variable nodes of degree 2 is 2k. A 2-chain of length 2k is a (k, 2) trapping set (with the exception of the case where the chain is closed and forms a cycle; in that case, we refer to the 2-chain as a 2-cycle. A 2-cycle of length 2k, is a (k, 0) trapping set). Having only 2 unsatisﬁed check nodes, 2-chains of length 2k are among the most dominant trapping sets of size k. Fig. 1 (a) shows a 2-chain of length 10 (a (5, 2) trapping set). Note that this trapping set also contains two (4, 2), three (3, 2) and four (2, 2) trapping sets as its subsets. It is worth noting that although for the cases where n v 2 = m − 1 (e.g., the eIRA construction of [16]), and n v 2 = m (e.g., the codes studied in [12]), the graph may have no or only one 2-cycle, it can have many 2-chains of different lengths. For example, it is easy to see that for the case where m = n v 2 and all the degree-2 variable nodes are contained in a single cycle, there are m 2-chains of length 2k, 1 ≤ k ≤ m − 1.
Another aspect of having 2-chains in the Tanner graph of irregular LDPC codes is that they might participate in short cycles with other variable nodes of higher degrees. These cycles have low ACE (ACE is deﬁned as i d i − 2, where d i is the degree of the i th variable node in the cycle [13]). It has been shown that cycles with low ACE deteriorate the error rate performance, and that avoiding them in the construction of irregular LDPC codes generally improves the error rate [13].
Example 3: Consider the case where m = n v 2 and all the degree-2 variable nodes are contained in a single cycle. In this case, there exist two 2-chains between any two check nodes of the code. This implies that every variable node of degree d v > 2 along with the 2-chains connecting its check nodes form several trapping sets with at most d v − 2 unsatisﬁed check nodes.
Example 4: Fig. 1 (b) shows a (7, 1) trapping set composed of one variable node of degree 3 and a chain of six variable nodes of degree 2.
Example 5: The (12, 1) trapping sets of the (1944, 972) LDPC code adopted in IEEE.802.11 [6] are single cycles of length 24, each consisting of a 2-chain of length 22 and one degree-3 variable node.
Even in the cases where n v 2 < m (but not much smaller), it is likely to see cycles mostly constructed by 2-chains.
Example 6: Fig. 1 (c) shows a (7, 2) trapping set composed of two variable nodes of degree 3 and ﬁve variable nodes of degree 2. Note that all the (7, 2) trapping sets of the (1944, 972) LDPC code of IEEE.802.11 standard have the structure of either Fig. 1 (a) or Fig. 1(c).
Due to the important role that 2-chains (and 2-cycles) play in the formation of dominant trapping sets, we study the necessary condition to avoid these structures in the following theorem (the proof is provided in Appendix B).
Theorem 1: Let m be the number of check nodes and n v 2 be the number of degree-2 variable nodes in the graph G corresponding to an irregular code C. If G has no 2-chains of length 2k or larger (and no 2-cycles of length less than or equal to 2k) then
Theorem 1 can be used to determine the maximum number of degree-2 variable nodes in an irregular graph to avoid 2- chains (and 2-cycles) of a speciﬁc length.
Example 7: For an irregular code with 1000 check nodes of degree d c = 6, to avoid (4, 2) trapping sets corresponding to 2-chains of length 8, the number of variable nodes of degree 2 must be at most 910.
Theorem 1 can be also used to obtain some information about the existing trapping sets in a code.
Example 8: For the same scenario as that of Example 7 (i.e., m = 1000, d c = 6), the eIRA construction [16] results in n v 2 = m − 1 = 999. For these parameters, the smallest value of k which satisﬁes the inequality of Theorem 1 is k = 9. This implies that the eIRA code has 2-chains of length 16 and smaller, corresponding to (k, 2) trapping sets for all k < 9.
In this section, we present a simple process to ﬁnd the dominant trapping sets involving degree-2 variable nodes. The process can be used in combination with Algorithm 1 of [7] to ﬁnd the dominant trapping sets of irregular graphs containing degree-2 variable nodes. It is important to note that for the trapping sets found by Algorithm 1, each variable node is connected to at least 2 satisﬁed check nodes. Therefore, 2- chains and other trapping sets containing variable node(s) of degree 2 with one satisﬁed check node are not found by Algorithm 1. In fact, it appears that being connected to 2 satisﬁed check nodes is too strong of a condition for a variable node of degree 2 to be part of a dominant trapping set. For this reason, we consider also trapping sets whose variable nodes of degree 2 are connected to only one satisﬁed check node. To obtain such trapping sets using the expansion of smaller trapping sets, we consider an (a−1, b) trapping set s which is expanded to a trapping set s by the connection of a variable node v of degree 2 to an unsatisﬁed check node of s. Three cases are possible:
a ) v is not connected to any other check node of Γ(s). In this case, s = s ∪ {v} is an (a, b) trapping set. If s is elementary, so is s .
b ) v is also connected to a satisﬁed check node of s. In this case, s = s ∪ {v} is an (a, b) non-elementary trapping set.
c ) v is also connected to another unsatisﬁed check node of s. In this case, s = s ∪ {v} is an (a, b − 2) trapping set. If
Such expansion of a trapping set can be performed multiple times by adding one neighboring variable node of degree 2, each time. This is summarized in Algorithm 2. In a general case, Algorithm 2 can be used with Algorithm 1 to expand the trapping sets found by Algorithm 1. This is summarized in Algorithm 3.
Algorithm 2: One recursion of ﬁnding dominant trapping sets of size up to k with the number of unsatisﬁed check nodes up to T constructed by adding degree-2 variable nodes to the input trapping sets for an irregular LDPC code with the Tanner graph G = (L ∪ R , E) .
( L in and L out are the lists of input and output trapping sets, respectively)
4: 	 Select an element of L in with size less than k, and denote it as t i .
5: 	 Form the set N 2 (t i ) which contains variable nodes of degree 2 in L \t i that are connected to at least one unsatisﬁed check node of t i (O(t i ))
9: 	 L out ← L out ∪ {t }. 10: 	 end if 11: 	 end for
Remark 1: Note that in Algorithm 2, the number of un- satisﬁed check nodes of the resultant trapping sets does not increase in each recursion. Hence, to ﬁnd trapping sets of size a with less than b unsatisﬁed check nodes, one should consider all the (a , b ) trapping sets with a < a, b < b. 1 It should be mentioned that since every single variable node of degree d v can be regarded as a (1, d v ) trapping set, to ﬁnd the trapping sets with less than b unsatisﬁed check nodes, we consider also all the variable nodes of degree d v ≤ b as part of the initial set. For example, for the case of b = 3, starting with a single variable node of degree d v = 2, 3, two typical structures of the resultant trapping sets are shown in Figures 1(a) and (d). Note that starting from a degree-2 variable node and performing the above steps results in ﬁnding a 2-chain.
Remark 2: It should be noted that for the irregular LDPC codes with a small fraction of degree-2 variable nodes, Al- gorithm 2 may not ﬁnd all the dominant trapping sets of the code. For this case, one may use Algorithm 3.
Algorithm 3: One recursion of ﬁnding dominant trapping sets of size up to k with the number of
unsatisﬁed check nodes up to T for an irregular LDPC code with the Tanner graph G = (L ∪ R , E) .
Remark 3: For the irregular codes, in addition to short cycles, cycles with low ACE are also considered as part of the initial input set of Algorithm 1. This is because these cycles may not be found using the expansion process of Algorithm 1. Algorithm 1 ﬁnds the smallest trapping sets containing the input, which are usually the combination of the input and a short cycle (or a structure described in Lemmas 2-4 of [7]). Since variable nodes of large degree are more likely to be part of such structures, the outputs of Algorithm 1 are usually the combinations of the input and variable node(s) of large degree. This is while cycles with low ACE are generally constructed by low degree variable nodes. Cycles with low ACE can be easily found by monitoring the ACE value during the execution of a cycle ﬁnding algorithm.
For the simulations, we assume binary phase-shift keying (BPSK) modulation over the AWGN channel with coherent detection. Notations E b and N 0 are used for the average energy per information bit and the one-sided power spectral density of the AWGN, respectively.
We present the results of applying the proposed algorithm to three irregular LDPC codes. To ﬁnd the dominant trapping sets of the irregular codes, we used two approaches. In the ﬁrst approach, we used Algorithms 1 and 2 in the framework described in Algorithm 3. In this approach, as the ﬁrst step, we used the short cycles of the codes, as well as the low ACE cycles as the initial input set, and applied Algorithm 1. We then used the trapping sets found by Algorithm 1 along with the variable nodes of low degree, and applied Algorithm 2 to expand them. As the second approach, we only used the variable nodes of low degree and cycles with low ACE as the initial input set, and then used Algorithm 2 to recursively expand them to larger trapping sets. Interestingly, for all the three codes, the results of the second approach were very close to those of the ﬁrst one. The reported running times in the following examples are for a desktop computer with 2-GHz CPU and 1 GB of RAM.
Example 9: For this example, we consider the irregular LDPC code constructed by the PEG algorithm [5](PEGirReg252x504 code [17]). This code was also investigated in [8] for its fully absorbing sets. For Algorithm 1, the short cycles of length g, g + 2, where g is the girth, and the cycles with length less than 20 and ACE less than 4 were used as the initial input set. The algorithm was constrained to ﬁnd only trapping sets of size less than
12 and the threshold T was selected such that only the 4 most dominant trapping sets for each size were considered. The resultant trapping sets and variable nodes of degree 2 and 3 were then expanded by adding neighboring degree-2 variable nodes, and ﬁnally were examined to ﬁnd the fully absorbing sets. Table I shows the fully absorbing sets found by Algorithm 3 and the exhaustive search algorithm of [8]. It should be noted that, similar to [8], we relaxed the condition that degree-2 variable nodes of (fully) absorbing sets must be connected to two satisﬁed check nodes. As can be seen from Table I, the proposed algorithm found almost all the fully absorbing sets of this code 2 . Moreover, the proposed algorithm found a number of (a, 1) trapping sets for a ≥ 7, which were not found by the algorithm of [8]. For the second approach, the cycles of length up to 20 with ACE lower than 4 and the variable nodes of degree 2 and 3 were used as the initial inputs, and the algorithm found almost the same trapping sets as in the ﬁrst approach. For the running time, the ﬁrst and the second approaches took 15 minutes and 5 minutes, respectively. This is while the algorithm of [8] took about 7 hours to obtain the trapping sets of size up to 5 for a regular code of similar length and rate.
Example 10: For this example, we used the (1944, 972) structured irregular code with rate 1/2, adopted in IEEE.802.11 standard [6]. We used the same parameters as in the previous example for the two approaches. Table II shows the number of dominant trapping sets of different sizes found by the algorithm of [2] and the proposed approaches. For this code, both of our approaches found exactly the same set of trapping sets. In fact, all the trapping sets listed in Table II have one of the following three structures: a 2-chain, a single cycle with low ACE, and the combination of a 2- chain and a single cycle of low ACE. For example, all the trapping sets of size less than 7 listed in Table II are 2-chains, and all the (12, 1) trapping sets are single cycles of eleven degree-2 variable nodes and one degree-3 variable node. As can be seen in Table II, for all classes of trapping sets, the
proposed algorithms found at least as many trapping sets as the algorithm of [2] did. The ﬁrst and the second approaches took 45 and 5 minutes, respectively, to ﬁnd all the trapping sets in Table II. This is while the algorithm of [2] took 5 days (on a 2.8-GHz CPU) to ﬁnd the results reported in Table II.
Based on the importance sampling technique of [3], the trapping sets in Table II with size l, 6 ≤ l ≤ 12, were used to estimate the error ﬂoor of this code for a 3-bit quantized min-sum decoder over the AWGN channel. Figure 2 shows the error ﬂoor estimation and the Monte Carlo simulation results for this code. As can be seen in Figure 2, the importance sampling estimation closely matches the Monte Carlo simulation, further verifying the dominance of the trapping sets found by the proposed algorithm.
Example 11: As the last example, we use the following degree distribution optimized for the min-sum algorithm and construct a (1000, 499) LDPC code using the PEG algorithm [5]: λ (x) = .30370x + .27754x 2 + .02843x 5 + . 20014x 6 + .19019x 19 and ρ (x) = .0160x 5 + .9840x 6 . The girth of the resultant graph is 6, and we use the short cycles of length 6 and 8, and cycles of length up to 20 with ACE less than 4 as the initial input set of Algorithm 2. It takes the algorithm 1 minute to ﬁnd the trapping sets of size up to 10.
Based on the obtained trapping sets and using the importance sampling, we estimate the error ﬂoor of the code. Figure 3 shows the estimation and Monte Carlo simulations for this code. As can be seen in this ﬁgure, the estimation closely matches the Monte Carlo simulation results, verifying that the dominant trapping sets of the code have been found by the algorithm.
[[[ REFS ]]]
R. Asvadi
H. Banihashemi
M. Ahmadian-Attari
--
Lowering the Error Floor of LDPC Codes Using Cyclic Liftings
----
S. Abu-Surra
D. DeClercq
D. Divsalar
W. Ryan
--
Trapping set enumerators for speciﬁc LDPC codes
----
C. Cole
S. Wilson
E. Hall
T. Giallorenzi
--
A general method for ﬁnding low error rates of LDPC codes
----
Y. Han
W. E. Ryan
--
LDPC decoder strategies for achieving low error ﬂoors
----
X.-Y. Hu
E. Eleftheriou
D. M. Arnold
--
Regular and irregular progressive edge-growth Tanner graphs
----

--
IEEE-802
----
M. Karimi
A. H. Banihashemi
--
An Efﬁcient Algorithm for Finding Dominant Trapping Sets of LDPC Codes
----
G. B. Kyung
C.-C. Wang
--
Exhaustive search for small fully absorbing sets and the corresponding low error-ﬂoor decoder
----
G. B. Kyung
--
private communication
----
A. McGregor
O. Milenkovic
--
On the hardness of approximating stopping and trapping sets in LDPC codes
----
T. J. Richardson
M. A. Shokrollahi
R. L. Urbanke
--
Design of capacity-approaching irregular low density parity-check codes
----
J. Tillich
G. Zemor
--
On the minimum distance of structured LDPC codes with two variable nodes of degree 2 per parity-check equation
----
T. Tian
C. Jones
J. D. Villasenor
R. D. Wesel
--
Selective avoidance of cycles in irregular LDPC code construction
----
B. Vasic
S. Chilappagari
D. Nguyen
S. Planjery
--
Trapping set ontology
----
C.-C. Wang
R. Kulkarni
V. Poor
--
Finding All Small Error-Prone Substructures in LDPC Codes
----
W. E. Ryan
Y. Li
--
Design of efﬁciently-encodable moderate-length high-rate irregular LDPC codes
----

--
Online]Available: http://www
[[[ META ]]]
parsed -> yes
file -> E:\isit2011\023.pdf
[[[ LINKS ]]]

